{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"blueye.sdk Read Latest Documentation - Browse GitHub Code Repository A Python package for remote control of the Blueye underwater drones. About Blueye Underwater Drones Blueye produces and sells three models of underwater drones, the Blueye Pioneer, Blueye Pro, and Blueye X3. The Pioneer and the Pro are drones designed for inspection, while the X3 is extensible with three guest ports that allow attaching for example grippers or sonars. Visit blueyerobotics.com for more information about the Blueye products. This SDK and the Blueye drones A Blueye drone is normally controlled via a mobile device through the Blueye App ( iOS / Android ). The mobile device is connected via Wi-Fi to a surface unit, and the drone is connected to the surface unit via a tether cable. This python SDK exposes the functionality of the Blueye app through a Python object. The SDK enables remote control of a Blueye drone as well as reading telemetry data and viewing video streams. It is not meant for executing code on the drone itself. To control the drone you connect your laptop to the surface unit Wi-Fi and run code that interfaces with the through the Python object. Check out the Quick Start Guide to get started with using the SDK.","title":"About the Blueye Drones"},{"location":"#blueyesdk","text":"Read Latest Documentation - Browse GitHub Code Repository A Python package for remote control of the Blueye underwater drones.","title":"blueye.sdk"},{"location":"#about-blueye-underwater-drones","text":"Blueye produces and sells three models of underwater drones, the Blueye Pioneer, Blueye Pro, and Blueye X3. The Pioneer and the Pro are drones designed for inspection, while the X3 is extensible with three guest ports that allow attaching for example grippers or sonars. Visit blueyerobotics.com for more information about the Blueye products.","title":"About Blueye Underwater Drones"},{"location":"#this-sdk-and-the-blueye-drones","text":"A Blueye drone is normally controlled via a mobile device through the Blueye App ( iOS / Android ). The mobile device is connected via Wi-Fi to a surface unit, and the drone is connected to the surface unit via a tether cable. This python SDK exposes the functionality of the Blueye app through a Python object. The SDK enables remote control of a Blueye drone as well as reading telemetry data and viewing video streams. It is not meant for executing code on the drone itself. To control the drone you connect your laptop to the surface unit Wi-Fi and run code that interfaces with the through the Python object. Check out the Quick Start Guide to get started with using the SDK.","title":"This SDK and the Blueye drones"},{"location":"contributing/","text":"Development Project structure and context blueye.sdk is a Python package that exposes the functionality of the Blueye app. The SDK depends on three projects: ProtocolDefinitons : TCP commands are sent from a computer or mobile device to the drone, and UDP messages with telemetry data are sent from the drone back to the top side device. These TCP commands and UDP telemetry messages are defined as json files in this project. blueye.protocol : Implements a TCP client for connecting to a Blueye drone and sending the TCP commands defined in ProtocolDefinitions , and a UDP client for receiving and parsing the telemetry messages defined in ProtocolDefinitions blueye.sdk : Wraps the TCP and UDP client from blueye.protocol into an easy to use Python object. blueye.sdk also adds functionality for downloading log files from the drone. Tests To run the tests when connected to a surface unit with an active drone, do: pytest To run tests when not connected to a drone, do: pytest -k \"not connected_to_drone\" Documentation The documentation is written in markdown and converted to html with portray . To generate and open the documentation locally run portray in_browser Formatting To keep the code style consistent Black is used for code formatting. To format code with black run black . in the project root directory. Adding a pre-commit hook ensures black is run before every commit pre-commit install adds a pre-commit hook for black formatting. Can't find what you are looking for? We're continuously improving this project and if you feel features are missing or something feels clunky, please open an issue and suggest a change. Bug reports and fixes are of course always welcome!","title":"Development"},{"location":"contributing/#development","text":"","title":"Development"},{"location":"contributing/#project-structure-and-context","text":"blueye.sdk is a Python package that exposes the functionality of the Blueye app. The SDK depends on three projects: ProtocolDefinitons : TCP commands are sent from a computer or mobile device to the drone, and UDP messages with telemetry data are sent from the drone back to the top side device. These TCP commands and UDP telemetry messages are defined as json files in this project. blueye.protocol : Implements a TCP client for connecting to a Blueye drone and sending the TCP commands defined in ProtocolDefinitions , and a UDP client for receiving and parsing the telemetry messages defined in ProtocolDefinitions blueye.sdk : Wraps the TCP and UDP client from blueye.protocol into an easy to use Python object. blueye.sdk also adds functionality for downloading log files from the drone.","title":"Project structure and context"},{"location":"contributing/#tests","text":"To run the tests when connected to a surface unit with an active drone, do: pytest To run tests when not connected to a drone, do: pytest -k \"not connected_to_drone\"","title":"Tests"},{"location":"contributing/#documentation","text":"The documentation is written in markdown and converted to html with portray . To generate and open the documentation locally run portray in_browser","title":"Documentation"},{"location":"contributing/#formatting","text":"To keep the code style consistent Black is used for code formatting. To format code with black run black . in the project root directory. Adding a pre-commit hook ensures black is run before every commit pre-commit install adds a pre-commit hook for black formatting.","title":"Formatting"},{"location":"contributing/#cant-find-what-you-are-looking-for","text":"We're continuously improving this project and if you feel features are missing or something feels clunky, please open an issue and suggest a change. Bug reports and fixes are of course always welcome!","title":"Can't find what you are looking for?"},{"location":"docs/configuration/","text":"There are settings on the drone that are remotely configurable from the Blueye mobile app. These can also be set directly from the SDK. Configure time and date The drone does not keep track of time internally. The SDK sets the time on the drone automatically when you connect initially. But you can also configure time and date manually like this import time from blueye.sdk import Drone myDrone = Drone () time_to_set_on_drone = int ( time . time ()) # Unix Timestamp myDrone . config . set_drone_time ( time_to_set_on_drone ) or if we for example want to offset the drone time 5 hours relative to our current system time we can do something like this: from blueye.sdk import Drone from datetime import timezone , timedelta , datetime myDrone = Drone () offset_in_hours = timedelta ( hours = 5 ) equivalent_timezone = timezone ( offset_in_hours ) unix_timestamp = datetime . now ( tz = equivalent_timezone ) . timestamp () myDrone . config . set_drone_time ( int ( unix_timestamp )) Calibrate pressure sensor for water density The water density on the drone default to a reasonable density for salt water: 1025 grams per liter. For more accurate depth readings, the water density can be configured manually to suit your local conditions from blueye.sdk import Drone , WaterDensities myDrone = Drone () # Salt water myDrone . config . water_density = WaterDensities . salty # 1.025 kg/L # Brackish water myDrone . config . water_density = WaterDensities . brackish # 1.011 kg/L # Fresh water myDrone . config . water_density = WaterDensities . fresh # 0.997 kg/L # Can also be set to arbitrary values myDrone . config . water_density = 1.234 Configure camera parameters There are 6 different camera parameters that can be set. For a full list of camera parameters and their possible values see the camera reference section. For example you could set the bit rate like this from blueye.sdk import Drone myDrone = Drone () myDrone . camera . bitrate = 8_000_000 # 8 Mbit bitrate Due to a bug in the camera streaming on the drone a camera stream has to have been opened at least once before camera parameters can be set on the drone, see issue #67 . For instructions on how to start a video stream see, the Quick Start Guide .","title":"Configure drone parameters"},{"location":"docs/configuration/#configure-time-and-date","text":"The drone does not keep track of time internally. The SDK sets the time on the drone automatically when you connect initially. But you can also configure time and date manually like this import time from blueye.sdk import Drone myDrone = Drone () time_to_set_on_drone = int ( time . time ()) # Unix Timestamp myDrone . config . set_drone_time ( time_to_set_on_drone ) or if we for example want to offset the drone time 5 hours relative to our current system time we can do something like this: from blueye.sdk import Drone from datetime import timezone , timedelta , datetime myDrone = Drone () offset_in_hours = timedelta ( hours = 5 ) equivalent_timezone = timezone ( offset_in_hours ) unix_timestamp = datetime . now ( tz = equivalent_timezone ) . timestamp () myDrone . config . set_drone_time ( int ( unix_timestamp ))","title":"Configure time and date"},{"location":"docs/configuration/#calibrate-pressure-sensor-for-water-density","text":"The water density on the drone default to a reasonable density for salt water: 1025 grams per liter. For more accurate depth readings, the water density can be configured manually to suit your local conditions from blueye.sdk import Drone , WaterDensities myDrone = Drone () # Salt water myDrone . config . water_density = WaterDensities . salty # 1.025 kg/L # Brackish water myDrone . config . water_density = WaterDensities . brackish # 1.011 kg/L # Fresh water myDrone . config . water_density = WaterDensities . fresh # 0.997 kg/L # Can also be set to arbitrary values myDrone . config . water_density = 1.234","title":"Calibrate pressure sensor for water density"},{"location":"docs/configuration/#configure-camera-parameters","text":"There are 6 different camera parameters that can be set. For a full list of camera parameters and their possible values see the camera reference section. For example you could set the bit rate like this from blueye.sdk import Drone myDrone = Drone () myDrone . camera . bitrate = 8_000_000 # 8 Mbit bitrate Due to a bug in the camera streaming on the drone a camera stream has to have been opened at least once before camera parameters can be set on the drone, see issue #67 . For instructions on how to start a video stream see, the Quick Start Guide .","title":"Configure camera parameters"},{"location":"docs/migrating-to-v2/","text":"Upgrading to v2 Version 2 of the Blueye SDK (unfortunately) introduces a few breaking changes. The following guide outlines what has changed, and what you need to change to be compatible with the new version. Change of underlying communication protocol The underlying communications protocol has been changed from UDP/TCP to protobuf messages sent over ZeroMQ sockets. This means that the drone now supports multiple simultaneous clients, and as such, the 'slave-mode' functionality is no longer necessary and has been removed. Another added benefit is the ability to list and disconnect other clients connected to the drone. Requirement on Blunux v3.2 or newer The SDK now requires v3.2 or newer of the Blunux operating system to be installed on the drone to able to connect to it. Dropped support Python 3.7 One or several of our subdependencies has dropped support for 3.7, and in an effort to reduce the maintenance burden we decided to drop support for 3.7 when adding support for 3.11. New range for lights control Previously the valid range for the lights property was an int between 0 and 255, it has now been updated to a float in the range 0 to 1. # Previously my_drone . lights = 64 # Updated my_drone . lights = 0.25 Error flags are a dictionary of bools Error flags are now represented as a dictionary of bools instead of bitflags in an int . See the ErrorFlags message in blueye.protocol for an overview of the possible error states. # Previously depth_read_error : bool = my_drone . error_flags & ( 1 << 2 ) # Updated depth_read_error : bool = my_drone . error_flags [ \"depth_read\" ] Changed return type in active_video_streams property The active_video_streams property has been modified to return a dictionary containing \"main\" and \"guestport\" as keys. This change provides the option to be able to read the number of active video streams for both the main camera and (optinally) a guestport camera. # Previously streams_on_main_camera = my_drone . active_video_streams # Updated streams_on_main_camera = my_drone . active_video_streams [ \"main\" ] Water Density Unit changed from g/L to kg/L The unit for water density has been updated from grams per liter (g/L) to kilograms per liter (kg/L). Make sure to adjust your calculations or conversions accordingly. # Previously density : int = my_drone . config . water_density print ( density ) # Will print 1025 # Updated density : float = my_drone . config . water_density print ( density ) # Will print 1.025 Camera Stabilization uses on/off instead of toggle The camera stabilization functionality now uses separate methods for enabling and disabling instead of a single toggle method. Update your code to use the appropriate methods based on the desired behavior. # Previously my_drone . camera . toggle_stabilization () print ( my_drone . camera . stabilization_enabled ) # Updated my_drone . camera . stabilization_enabled = True print ( my_drone . camera . stabilization_enabled ) tilt_speed has been renamed to tilt_velocity The function tilt_speed has been renamed to tilt_velocity to better reflect its purpose and usage. Update your code to use the new function name. # Previously my_drone . camera . tilt . set_speed ( 1 ) # Updated my_drone . camera . tilt . set_velocity ( 1 ) New subclass for battery data The battery_state_of_charge property has been moved to a subclass on the Drone -object. In addition the state of charge range for the battery has been adjusted to a scale of 0 to 1, instead of the previous 0 to 100 range. # Previously state_of_charge : int = my_drone . battery_state_of_charge # Updated state_of_charge : float = my_drone . battery . state_of_charge Custom Overlay Classes Replaced with Enums Custom overlay classes have been replaced with enums defined in the blueye.protocol package. Make sure to update your code to use the new enums for overlay functionality. # Previously from blueye.sdk import DepthUnitOverlay , FontSizeOverlay , LogoOverlay , TemperatureUnitOverlay my_drone . camera . overlay . depth_unit = DepthUnitOverlay . METERS my_drone . camera . overlay . font_size = FontSizeOverlay . PX15 my_drone . camera . overlay . logo = LogoOverlay . BLUEYE my_drone . camera . overlay . temperature_unit = TemperatureUnitOverlay . CELSIUS # Updated import blueye.protocol as bp my_drone . camera . overlay . depth_unit = bp . DepthUnit . DEPTH_UNIT_METERS my_drone . camera . overlay . font_size = bp . FontSize . FONT_SIZE_PX15 my_drone . camera . overlay . logo = bp . LogoType . LOGO_TYPE_DEFAULT my_drone . camera . overlay . temperature_unit = bp . TemperatureUnit . TEMPERATURE_UNIT_CELSIUS Telemetry properties will now return None if no data exists Properties that read telemetry data, such as lights , tilt_angle , depth , pose , battery_state_of_charge , error_flags , active_video_streams , auto_depth_active , and auto_heading_active , will now return None if no telemetry message has been received from the drone. Previously if a UDP message had not arrived, a KeyError exception would have been raised. # Previously print ( my_drone . pose ) # If no state message has been received yet this could throw a KeyError # Updated print ( my_drone . pose ) # This will now print \"None\" if no AttitudeTel-message has been received. New initialization parameters to the Drone object The AutoConnect parameter has been renamed to auto_connect for consistency and clarity. # Previously my_drone = Drone ( AutoConnect = False ) # Updated my_drone = Drone ( auto_connect = False ) The udpTimeout parameter has been renamed to timeout for consistency and clarity. # Previously my_drone = Drone ( udpTimeout = 5 ) # Updated my_drone = Drone ( timeout = 5 )","title":"Updating from v1 to v2"},{"location":"docs/migrating-to-v2/#upgrading-to-v2","text":"Version 2 of the Blueye SDK (unfortunately) introduces a few breaking changes. The following guide outlines what has changed, and what you need to change to be compatible with the new version.","title":"Upgrading to v2"},{"location":"docs/migrating-to-v2/#change-of-underlying-communication-protocol","text":"The underlying communications protocol has been changed from UDP/TCP to protobuf messages sent over ZeroMQ sockets. This means that the drone now supports multiple simultaneous clients, and as such, the 'slave-mode' functionality is no longer necessary and has been removed. Another added benefit is the ability to list and disconnect other clients connected to the drone.","title":"Change of underlying communication protocol"},{"location":"docs/migrating-to-v2/#requirement-on-blunux-v32-or-newer","text":"The SDK now requires v3.2 or newer of the Blunux operating system to be installed on the drone to able to connect to it.","title":"Requirement on Blunux v3.2 or newer"},{"location":"docs/migrating-to-v2/#dropped-support-python-37","text":"One or several of our subdependencies has dropped support for 3.7, and in an effort to reduce the maintenance burden we decided to drop support for 3.7 when adding support for 3.11.","title":"Dropped support Python 3.7"},{"location":"docs/migrating-to-v2/#new-range-for-lights-control","text":"Previously the valid range for the lights property was an int between 0 and 255, it has now been updated to a float in the range 0 to 1. # Previously my_drone . lights = 64 # Updated my_drone . lights = 0.25","title":"New range for lights control"},{"location":"docs/migrating-to-v2/#error-flags-are-a-dictionary-of-bools","text":"Error flags are now represented as a dictionary of bools instead of bitflags in an int . See the ErrorFlags message in blueye.protocol for an overview of the possible error states. # Previously depth_read_error : bool = my_drone . error_flags & ( 1 << 2 ) # Updated depth_read_error : bool = my_drone . error_flags [ \"depth_read\" ]","title":"Error flags are a dictionary of bools"},{"location":"docs/migrating-to-v2/#changed-return-type-in-active_video_streams-property","text":"The active_video_streams property has been modified to return a dictionary containing \"main\" and \"guestport\" as keys. This change provides the option to be able to read the number of active video streams for both the main camera and (optinally) a guestport camera. # Previously streams_on_main_camera = my_drone . active_video_streams # Updated streams_on_main_camera = my_drone . active_video_streams [ \"main\" ]","title":"Changed return type in active_video_streams property"},{"location":"docs/migrating-to-v2/#water-density-unit-changed-from-gl-to-kgl","text":"The unit for water density has been updated from grams per liter (g/L) to kilograms per liter (kg/L). Make sure to adjust your calculations or conversions accordingly. # Previously density : int = my_drone . config . water_density print ( density ) # Will print 1025 # Updated density : float = my_drone . config . water_density print ( density ) # Will print 1.025","title":"Water Density Unit changed from g/L to kg/L"},{"location":"docs/migrating-to-v2/#camera-stabilization-uses-onoff-instead-of-toggle","text":"The camera stabilization functionality now uses separate methods for enabling and disabling instead of a single toggle method. Update your code to use the appropriate methods based on the desired behavior. # Previously my_drone . camera . toggle_stabilization () print ( my_drone . camera . stabilization_enabled ) # Updated my_drone . camera . stabilization_enabled = True print ( my_drone . camera . stabilization_enabled )","title":"Camera Stabilization uses on/off instead of toggle"},{"location":"docs/migrating-to-v2/#tilt_speed-has-been-renamed-to-tilt_velocity","text":"The function tilt_speed has been renamed to tilt_velocity to better reflect its purpose and usage. Update your code to use the new function name. # Previously my_drone . camera . tilt . set_speed ( 1 ) # Updated my_drone . camera . tilt . set_velocity ( 1 )","title":"tilt_speed has been renamed to tilt_velocity"},{"location":"docs/migrating-to-v2/#new-subclass-for-battery-data","text":"The battery_state_of_charge property has been moved to a subclass on the Drone -object. In addition the state of charge range for the battery has been adjusted to a scale of 0 to 1, instead of the previous 0 to 100 range. # Previously state_of_charge : int = my_drone . battery_state_of_charge # Updated state_of_charge : float = my_drone . battery . state_of_charge","title":"New subclass for battery data"},{"location":"docs/migrating-to-v2/#custom-overlay-classes-replaced-with-enums","text":"Custom overlay classes have been replaced with enums defined in the blueye.protocol package. Make sure to update your code to use the new enums for overlay functionality. # Previously from blueye.sdk import DepthUnitOverlay , FontSizeOverlay , LogoOverlay , TemperatureUnitOverlay my_drone . camera . overlay . depth_unit = DepthUnitOverlay . METERS my_drone . camera . overlay . font_size = FontSizeOverlay . PX15 my_drone . camera . overlay . logo = LogoOverlay . BLUEYE my_drone . camera . overlay . temperature_unit = TemperatureUnitOverlay . CELSIUS # Updated import blueye.protocol as bp my_drone . camera . overlay . depth_unit = bp . DepthUnit . DEPTH_UNIT_METERS my_drone . camera . overlay . font_size = bp . FontSize . FONT_SIZE_PX15 my_drone . camera . overlay . logo = bp . LogoType . LOGO_TYPE_DEFAULT my_drone . camera . overlay . temperature_unit = bp . TemperatureUnit . TEMPERATURE_UNIT_CELSIUS","title":"Custom Overlay Classes Replaced with Enums"},{"location":"docs/migrating-to-v2/#telemetry-properties-will-now-return-none-if-no-data-exists","text":"Properties that read telemetry data, such as lights , tilt_angle , depth , pose , battery_state_of_charge , error_flags , active_video_streams , auto_depth_active , and auto_heading_active , will now return None if no telemetry message has been received from the drone. Previously if a UDP message had not arrived, a KeyError exception would have been raised. # Previously print ( my_drone . pose ) # If no state message has been received yet this could throw a KeyError # Updated print ( my_drone . pose ) # This will now print \"None\" if no AttitudeTel-message has been received.","title":"Telemetry properties will now return None if no data exists"},{"location":"docs/migrating-to-v2/#new-initialization-parameters-to-the-drone-object","text":"The AutoConnect parameter has been renamed to auto_connect for consistency and clarity. # Previously my_drone = Drone ( AutoConnect = False ) # Updated my_drone = Drone ( auto_connect = False ) The udpTimeout parameter has been renamed to timeout for consistency and clarity. # Previously my_drone = Drone ( udpTimeout = 5 ) # Updated my_drone = Drone ( timeout = 5 )","title":"New initialization parameters to the Drone object"},{"location":"docs/protobuf-protocol/","text":"Protocol Documentation control.proto Control These messages define control messages accepted by the Blueye drone. ActivateGuestPortsCtrl Activated the guest port power AutoAltitudeCtrl Issue a command to set auto altitude to a desired state. Field Type Label Description state AutoAltitudeState State of the altitude controller AutoDepthCtrl Issue a command to set auto depth to a desired state. Field Type Label Description state AutoDepthState State of the depth controller AutoHeadingCtrl Issue a command to set auto heading to a desired state. Field Type Label Description state AutoHeadingState State of the heading controller CancelCalibrationCtrl Issue a command to cancel compass calibration. DeactivateGuestPortsCtrl Deactivate the guest port power FinishCalibrationCtrl Issue a command to finish compass calibration. GenericServoCtrl Issue a command to set a generic servo value. Field Type Label Description servo GenericServo Message with the desired servo value. GripperCtrl Issue a command to control the gripper. Field Type Label Description gripper_velocities GripperVelocities The desired gripping and rotation velocity. GuestportLightsCtrl Issue a command to set the guest port light intensity. Field Type Label Description lights Lights Message with the desired light intensity. LaserCtrl Issue a command to set the laser intensity. Field Type Label Description laser Laser Message with the desired laser intensity. LightsCtrl Issue a command to set the main light intensity. Field Type Label Description lights Lights Message with the desired light intensity. MotionInputCtrl Issue a command to move the drone in the surge, sway, heave, or yaw direction. Field Type Label Description motion_input MotionInput Message with the desired movement in each direction. MultibeamServoCtrl Issue a command to set multibeam servo angle. Field Type Label Description servo MultibeamServo Message with the desired servo angle. PilotGPSPositionCtrl Issue a command with the GPS position of the pilot. Field Type Label Description position LatLongPosition The GPS position of the pilot. PingerConfigurationCtrl Issue a command to set the pinger configuration. Field Type Label Description configuration PingerConfiguration Message with the pinger configuration to set. RecordCtrl Issue a command to start video recording. Field Type Label Description record_on RecordOn Message specifying which cameras to record. ResetOdometerCtrl Issue a command to reset the odometer. ResetPositionCtrl Issue a command to reset the position estimate. Field Type Label Description settings ResetPositionSettings Reset settings. RestartGuestPortsCtrl Restart the guest ports by turning power on and off Field Type Label Description restart_info GuestPortRestartInfo Message with information about how long to keep the guest ports off. StartCalibrationCtrl Issue a command to start compass calibration. StationKeepingCtrl Issue a command to set station keeping to a desired state. Field Type Label Description state StationKeepingState State of the station keeping controller SystemTimeCtrl Issue a command to set the system time on the drone. Field Type Label Description system_time SystemTime Message with the system time to set. TakePictureCtrl Issue a command to take a picture. TiltStabilizationCtrl Issue a command to enable or disable tilt stabilization. Field Type Label Description state TiltStabilizationState Message with the tilt stabilization state to set. TiltVelocityCtrl Issue a command to tilt the drone camera. Field Type Label Description velocity TiltVelocity Message with the desired tilt velocity (direction and speed). WatchdogCtrl Issue a watchdog message to indicate that the remote client is connected and working as expected. If a watchdog message is not received every second, the drone will turn off lights and other auto functions to indicate that connection with the client has been lost. Field Type Label Description connection_duration ConnectionDuration Message with the number of seconds the client has been connected. client_id uint32 The ID of the client, received in the ConnectClientRep response. WaterDensityCtrl Issue a command to set the water density. Field Type Label Description density WaterDensity Message with the water density to set. WeatherVaningCtrl Issue a command to set station keeping with weather vaning to a desired state. Field Type Label Description state WeatherVaningState State of the weather vaning controller Top message_formats.proto Common messages These are used for logging as well as building requests and responses. Altitude Drone altitude over seabed, typically obtained from a DVL. Field Type Label Description value float Drone altitude over seabed (m) is_valid bool If altitude is valid or not Attitude The attitude of the drone. Field Type Label Description roll float Roll angle (-180\u00b0..180\u00b0) pitch float Pitch angle (-180\u00b0..180\u00b0) yaw float Yaw angle (-180\u00b0..180\u00b0) AutoAltitudeState Auto altitude state. Field Type Label Description enabled bool If auto altitude is enabled AutoDepthState Auto depth state. Field Type Label Description enabled bool If auto depth is enabled AutoHeadingState Auto heading state. Field Type Label Description enabled bool If auto heading is enabled Battery Essential battery information. Field Type Label Description voltage float Battery voltage (V) level float Battery level (0..1) temperature float Battery temperature (\u00b0C) BatteryBQ40Z50 Battery information message. Detailed information about all aspects of the connected Blueye Smart Battery, using the BQ40Z50 BMS. Field Type Label Description voltage BatteryBQ40Z50.Voltage Voltage of the battery cells temperature BatteryBQ40Z50.Temperature Temperature of the battery cells status BatteryBQ40Z50.BatteryStatus Battery status flags current float Current (A) average_current float Average current (A) relative_state_of_charge float Relative state of charge (0..1) absolute_state_of_charge float Absolute state of charge (0..1) remaining_capacity float Remaining capacity (Ah) full_charge_capacity float Full charge capacity (Ah) runtime_to_empty uint32 Runtime to empty (s) average_time_to_empty uint32 Average time to empty (s) average_time_to_full uint32 Average time to full (s) time_to_full_at_current_rate uint32 Time to fully charged at current rate (s) time_to_empty_at_current_rate uint32 Time to empty at current rate (s) charging_current float Charging current (A) charging_voltage float Charging voltage (V) cycle_count uint32 Number of charging cycles design_capacity float Design capacity (Ah) manufacture_date google.protobuf.Timestamp Manufacture date serial_number uint32 Serial number manufacturer_name string Manufacturer name device_name string Device name device_chemistry string Battery chemistry BatteryBQ40Z50.BatteryStatus Battery status from BQ40Z50 ref data sheet 0x16. Field Type Label Description overcharged_alarm bool terminate_charge_alarm bool over_temperature_alarm bool terminate_discharge_alarm bool remaining_capacity_alarm bool remaining_time_alarm bool initialization bool discharging_or_relax bool fully_charged bool fully_discharged bool error BatteryBQ40Z50.BatteryStatus.BatteryError Battery error codes BatteryBQ40Z50.Temperature Battery temperature. Field Type Label Description average float Average temperature accross cells (\u00b0C) cell_1 float Cell 1 temperature (\u00b0C) cell_2 float Cell 2 temperature (\u00b0C) cell_3 float Cell 3 temperature (\u00b0C) cell_4 float Cell 4 temperature (\u00b0C) BatteryBQ40Z50.Voltage Battery voltage levels. Field Type Label Description total float Battery pack voltage level (V) cell_1 float Cell 1 voltage level (V) cell_2 float Vell 2 voltage level (V) cell_3 float Cell 3 voltage level (V) cell_4 float Cell 4 voltage level (V) BinlogRecord Wrapper message for each entry in the drone telemetry logfile. Each entry contains the unix timestamp in UTC, the monotonic timestamp (time since boot), and an Any message wrapping the custom Blueye message. See separate documentation for the logfile format for more details. Field Type Label Description payload google.protobuf.Any The log entry payload. unix_timestamp google.protobuf.Timestamp Unix timestamp in UTC. clock_monotonic google.protobuf.Timestamp Posix CLOCK_MONOTONIC timestamp. CPUTemperature CPU temperature. Field Type Label Description value float CPU temperature (\u00b0C) CalibrationState Compass calibration state. Field Type Label Description status CalibrationState.Status Current calibration status progress_x_positive float Progress for the positive X axis (0..1) progress_x_negative float Progress for the negative X axis (0..1) progress_y_positive float Progress for the positive Y axis (0..1) progress_y_negative float Progress for the negative X axis (0..1) progress_z_positive float Progress for the positive Z axis (0..1) progress_z_negative float Progress for the negative Z axis (0..1) progress_thruster float Progress for the thruster calibration (0..1) CameraParameters Camera parameters. Field Type Label Description h264_bitrate int32 Bitrate of the h264 stream (bit/sec) mjpg_bitrate int32 Bitrate of the MJPG stream used for still pictures (bit/sec) exposure int32 Shutter speed (1/10000 * s), -1 for automatic exposure white_balance int32 White balance temperature (2800..9300), -1 for automatic white balance hue int32 Hue (-40..40), 0 as default gain float Iso gain (0..1) resolution Resolution Stream, recording and image resolution framerate Framerate Stream and recording framerate camera Camera Which camera the parameters belong to. CanisterHumidity Canister humidity. Humidity measured in the top or bottom canister of the drone. Field Type Label Description humidity float Air humidity (%) CanisterTemperature Canister temperature. Temperature measured in the top or bottom canister of the drone. Field Type Label Description temperature float Temperature (\u00b0C) ClientInfo Information about a remote client. Field Type Label Description type string The type of client (such as Blueye App, Observer App, SDK, etc) version string Client software version string device_type string Device type, such as mobile, tablet, or computer platform string Platform, such as iOS, Android, Linux, etc platform_version string Platform software version string name string Name of the client ConnectedClient Information about a connected client with an id assigned by the drone. Field Type Label Description client_id uint32 The assigned client id client_info ClientInfo Client information. ConnectionDuration Connection duration of a remote client. Field Type Label Description value int32 time since connected to drone (s) ControlForce Control Force is used for showing the requested control force in each direction in Newtons. Field Type Label Description surge float Force in surge (N) sway float Force in sway (N) heave float Force in heave (N) yaw float Moment in yaw (Nm) ControlMode Control mode from drone supervisor Field Type Label Description auto_depth bool If auto depth is enabled auto_heading bool If auto heading is enabled auto_altitude bool If auto altitude is enabled station_keeping bool If station keeping is enabled weather_vaning bool If weather vaning is enabled ControllerHealth Controller health is used for showing the state of the controller with an relative error and load from 0 to 1. Field Type Label Description depth_error float Depth error in meters (m) depth_health float Depth controller load (0..1) heading_error float Heading error in degrees (\u00b0) heading_health float Heading controller load (0..1) CpProbe Reading from a Cathodic Protection Potential probe. Field Type Label Description measurement float Potential measurement (V) is_measurement_valid bool Indicating if the measurement is valid Depth Water depth of the drone. Field Type Label Description value float Drone depth below surface (m) DiveTime Amount of time the drone has been submerged. The drone starts incrementing this value when the depth is above 250 mm. Field Type Label Description value int32 Number of seconds the drone has been submerged DroneInfo Information about the drone. This message contains serial numbers and version informattion for internal components in the drone. Primarily used for diagnostics, or to determine the origin of a logfile. Field Type Label Description blunux_version string Blunux version string serial_number bytes Drone serial number hardware_id bytes Main computer unique identifier model Model Drone model mb_serial bytes Motherboard serial number bb_serial bytes Backbone serial number ds_serial bytes Drone stack serial number mb_uid bytes Motherboard unique identifier bb_uid bytes Backbone unique identifier gp GuestPortInfo GuestPortInfo depth_sensor PressureSensorType Type of depth sensor that is connected to the drone ErrorFlags Known error states for the drone. Field Type Label Description pmu_comm_ack bool Acknowledge message not received for a message published to internal micro controller pmu_comm_stream bool Error in communication with internal micro controller depth_read bool Error reading depth sensor value depth_spike bool Sudden spike in value read from depth sensor inner_pressure_read bool Error reading inner pressure of the drone inner_pressure_spike bool Sudden spike in inner preassure compass_calibration bool Compass needs calibration tilt_calibration bool Error during calibration of tilt endpoints gp1_read bool Guest port 1 read error gp2_read bool Guest port 2 read error gp3_read bool Guest port 3 read error gp1_not_flashed bool Guest port 1 not flashed gp2_not_flashed bool Guest port 2 not flashed gp3_not_flashed bool Guest port 3 not flashed gp1_unknown_device bool Unknown device on guest port 1 gp2_unknown_device bool Unknown device on guest port 2 gp3_unknown_device bool Unknown device on guest port 3 gp1_device_connection bool Guest port 1 connection error gp2_device_connection bool Guest port 2 connection error gp3_device_connection bool Guest port 3 connection error gp1_device bool Guest port 1 device error gp2_device bool Guest port 2 device error gp3_device bool Guest port 3 device error drone_serial_not_set bool Drone serial number not set drone_serial bool Drone serial number error mb_eeprom_read bool MB eeprom read error bb_eeprom_read bool BB eeprom read error mb_eeprom_not_flashed bool MB eeprom not flashed bb_eeprom_not_flashed bool BB eeprom not flashed main_camera_connection bool We don't get buffers from the main camera main_camera_firmware bool The main camera firmware is wrong guestport_camera_connection bool We don't get buffers from the guestport camera guestport_camera_firmware bool The guestport camera firmware is wrong mb_serial bool MB serial number error bb_serial bool BB serial number error ds_serial bool DS serial number error gp_current_read bool Error reading GP current gp_current bool Max GP current exceeded gp1_bat_current bool Max battery current exceeded on GP1 gp2_bat_current bool Max battery current exceeded on GP2 gp3_bat_current bool Max battery current exceeded on GP3 gp_20v_current bool Max 20V current exceeded on GP ForwardDistance Distance to an object infront of the drone, typically obtained from an 1D pinger. Field Type Label Description value float Distance in front of drone (m) is_valid bool If distance reading is valid or not GenericServo Servo message used to represent the angle of the servo. Field Type Label Description value float Servo value (0..1) guest_port_number GuestPortNumber Guest port the servo is on GripperVelocities Gripper velocity values. Field Type Label Description grip_velocity float The gripping velocity (-1.0..1.0) rotate_velocity float The rotating velocity (-1.0..1.0) GuestPortConnectorInfo GuestPort connector information. Field Type Label Description device_list GuestPortDeviceList List of devices on this connector error GuestPortError Guest port error guest_port_number GuestPortNumber Guest port the connector is connected to GuestPortCurrent GuestPort current readings. Field Type Label Description gp1_bat double Current on GP1 battery voltage (A) gp2_bat double Current on GP2 battery voltage (A) gp3_bat double Current on GP3 battery voltage (A) gp_20v double Current on common 20V supply (A) GuestPortDevice GuestPort device. Field Type Label Description device_id GuestPortDeviceID Blueye device identifier manufacturer string Manufacturer name name string Device name serial_number string Serial number depth_rating float Depth rating (m) required_blunux_version string Required Blunux version (x.y.z) GuestPortDeviceList List of guest port devices. Field Type Label Description devices GuestPortDevice repeated List of guest port devices GuestPortInfo GuestPort information. Field Type Label Description gp1 GuestPortConnectorInfo GuestPortConnectorInfo 1 gp2 GuestPortConnectorInfo GuestPortConnectorInfo 2 gp3 GuestPortConnectorInfo GuestPortConnectorInfo 3 GuestPortRestartInfo GuestPort restart information. Field Type Label Description power_off_duration double Duration to keep the guest ports off (s) Imu Imu data in drone body frame x - forward y - right z - down Field Type Label Description accelerometer Vector3 Acceleration (g) gyroscope Vector3 Angular velocity (rad/s) magnetometer Vector3 Magnetic field (\u03bcT) temperature float Temperature (\u00b0C) IperfStatus Connection speed between drone and Surface Unit. Field Type Label Description sent float Transfer rate from drone to Surface Unit (Mbit/s) received float Transfer rate from Surface Unit to drone (Mbit/s) Laser Laser message used to represent the intensity of connected laser. If the laser does not support dimming but only on and off, a value of 0 turns the laser off, and any value above 0 turns the laser on. Field Type Label Description value float Laser intensity, any value above 0 turns the laser on (0..1) LatLongPosition Latitude and longitude position in WGS 84 decimal degrees format. Field Type Label Description latitude double Latitude (\u00b0) longitude double Longitude (\u00b0) Lights Lights message used to represent the intensity of the main light or external lights. Field Type Label Description value float Light intensity (0..1) MedusaSpectrometerData Medusa gamma ray sensor spectrometer data Field Type Label Description drone_time google.protobuf.Timestamp Time stamp when the data is received sensor_time google.protobuf.Timestamp Time stamp the sensor reports realtime float Time the sensor actually measured (s) livetime float Time the measurement took (s) total uint32 Total counts inside the spectrum countrate uint32 Counts per second inside the spectrum (rounded) cosmics uint32 Detected counts above the last channel MotionInput Motion input from client. Used to indicate the desired motion in each direction. Typically these values map to the left and right joystick for motion, and the left and right trigger for the slow and boost modifiers. Field Type Label Description surge float Forward (positive) and backwards (negative) movement. (-1..1) sway float Right (positive) and left (negative) lateral movement (-1..1) heave float Descend (positive) and ascend (negative) movement (-1..1) yaw float Left (positive) and right (negative) movement (-1..1) slow float Multiplier used to reduce the speed of the motion (0..1) boost float Multiplier used to increase the speed of the motion (0..1) MultibeamServo Servo message used to represent the angle of the servo. Field Type Label Description angle float Servo degrees (-30..30) NStreamers Number of spectators connected to video stream. Field Type Label Description main int32 The number of clients to the main camera stream guestport int32 The number of clients to the guestport camera stream NavigationSensorStatus Navigation sensor used in the position observer with validity state Field Type Label Description sensor_id NavigationSensorID Sensor id is_valid bool Sensor validity OverlayParameters Overlay parameters. All available parameters that can be used to configure telemetry overlay on video recordings. Field Type Label Description temperature_enabled bool If temperature should be included depth_enabled bool If depth should be included heading_enabled bool If heading should be included tilt_enabled bool If camera tilt angle should be included thickness_enabled bool If camera tilt angle should be included date_enabled bool If date should be included distance_enabled bool If distance should be included altitude_enabled bool If altitude should be included cp_probe_enabled bool If cp-probe should be included medusa_enabled bool If medusa measurement should be included drone_location_enabled bool If the drone location coordinates should be included logo_type LogoType Which logo should be used depth_unit DepthUnit Which unit should be used for depth: Meter, Feet or None temperature_unit TemperatureUnit Which unit should be used for temperature: Celcius or Fahrenheit thickness_unit ThicknessUnit Which unit should be used for thickness: Millimeters or Inches timezone_offset int32 Timezone offset from UTC (min) margin_width int32 Horizontal margins of text elements (px) margin_height int32 Vertical margins of text elements (px) font_size FontSize Font size of text elements title string Optional title subtitle string Optional subtitle date_format string Posix strftime format string for time stamp shading float Pixel intensity to subtract from text background (0..1), 0: transparent, 1: black PingerConfiguration Pinger configuration. Used to specify the configuration the BR 1D-Pinger. Field Type Label Description mounting_direction PingerConfiguration.MountingDirection Mounting direction of the pinger PositionEstimate Position estimate from the Extended Kalman filter based observer if a DVL is connected. Field Type Label Description northing float Position from reset point (m) easting float Position from reset point (m) heading float Gyro based heading estimate (continous radians) surge_rate float Velocity in surge (m/s) sway_rate float Velocity in sway (m/s) yaw_rate float Rotaion rate in yaw (rad/s) ocean_current float Estimated ocean current (m/s) odometer float Travelled distance since reset (m) is_valid bool If the estimate can be trusted global_position LatLongPosition Best estimate of the global position in decimal degrees navigation_sensors NavigationSensorStatus repeated List of available sensors with status RecordOn Which cameras are supposed to be recording Field Type Label Description main bool Record the main camera guestport bool Record external camera RecordState Camera recording state. Field Type Label Description main_is_recording bool If the main camera is recording main_seconds int32 Main record time (s) guestport_is_recording bool If the guestport camera is recording guestport_seconds int32 Guestport record time (s) Reference Reference for the control system. Note that the internal heading referece is not relative to North. Use (ControlHealth.heading_error + pose.yaw) instead. Field Type Label Description surge float Reference from joystick surge input (0..1) sway float Reference from joystick sway input (0..1) heave float Reference from joystick heave input (0..1) yaw float Reference from joystick yaw input (0..1) depth float Reference drone depth below surface (m) heading float Reference used in auto heading mode, gyro based (\u00b0) altitude float Reference used in auto altitude mode (m) ResetPositionSettings ResetPositionSettings used during reset of the position estimate. Field Type Label Description heading_source_during_reset HeadingSource Option to use the drone compass or due North as heading during reset manual_heading float Heading in degrees (0-359) reset_coordinate_source ResetCoordinateSource Option to use the device GPS or a manual coordinate. reset_coordinate LatLongPosition Reset coordinate in decimal degrees StationKeepingState Station keeping state. Field Type Label Description enabled bool If station keeping is enabled StorageSpace Storage space. Field Type Label Description total_space int64 Total bytes of storage space (B) free_space int64 Available bytes of storage space (B) SystemTime System time. Field Type Label Description unix_timestamp google.protobuf.Timestamp Unix timestamp ThicknessGauge Thickness measurement data from a Cygnus Thickness Gauge. Field Type Label Description thickness_measurement float Thickness measurement of a steel plate echo_count uint32 Indicating the quality of the reading when invalid (0-3) sound_velocity uint32 Speed of sound in the steel member (m/s) is_measurement_valid bool Indicating if the measurement is valid TiltAngle Angle of tilt camera in degrees. Field Type Label Description value float Tilt angle (\u00b0) TiltStabilizationState Tilt stabilization state. Blueye drones with mechanical tilt has the ability to enable camera stabilization. Field Type Label Description enabled bool If tilt stabilization is enabled TiltVelocity Relative velocity of tilt Field Type Label Description value float Relative angular velocity of tilt (-1..1), negative means down and positive means up Vector3 Vector with 3 elements Field Type Label Description x double x-component y double y-component z double z-component WaterDensity Water density. Used to specify the water density the drone is operating in, to achieve more accruate depth measurements. Field Type Label Description value float Salinity (kg/l) WaterTemperature Water temperature measured by the drone's combined depth and temperature sensor. Field Type Label Description value float Water temperature (\u00b0C) WeatherVaningState Weather vaning state. Field Type Label Description enabled bool If weather vaning is enabled BatteryBQ40Z50.BatteryStatus.BatteryError Battery errror code from BQ40Z50 BMS data sheet. Name Number Description BATTERY_ERROR_UNSPECIFIED 0 BATTERY_ERROR_OK 1 BATTERY_ERROR_BUSY 2 BATTERY_ERROR_RESERVED_COMMAND 3 BATTERY_ERROR_UNSUPPORTED_COMMAND 4 BATTERY_ERROR_ACCESS_DENIED 5 BATTERY_ERROR_OVERFLOW_UNDERFLOW 6 BATTERY_ERROR_BAD_SIZE 7 BATTERY_ERROR_UNKNOWN_ERROR 8 CalibrationState.Status Status of the compass calibration procedure. When calibration is started, the status will indicate the active (upfacing) axis. Name Number Description STATUS_UNSPECIFIED 0 Unspecified status STATUS_NOT_CALIBRATING 1 Compass is not currently calibrating STATUS_CALIBRATING_NO_AXIS 2 Compass is calibrating but active calibration axis cannot be determined STATUS_CALIBRATING_X_POSITIVE 3 Compass is calibrating and the positive X axis is active STATUS_CALIBRATING_X_NEGATIVE 4 Compass is calibrating and the negative X axis is active STATUS_CALIBRATING_Y_POSITIVE 5 Compass is calibrating and the positive Y axis is active STATUS_CALIBRATING_Y_NEGATIVE 6 Compass is calibrating and the negative Y axis is active STATUS_CALIBRATING_Z_POSITIVE 7 Compass is calibrating and the positive Z axis is active STATUS_CALIBRATING_Z_NEGATIVE 8 Compass is calibrating and the negative Z axis is active STATUS_CALIBRATING_THRUSTER 9 Compass is calibrating for thruster interferance Camera Which camera to control. Name Number Description CAMERA_UNSPECIFIED 0 Camera not specified CAMERA_MAIN 1 Main camera CAMERA_GUESTPORT 2 Guestport camera DepthUnit Available depth units. Name Number Description DEPTH_UNIT_UNSPECIFIED 0 Depth unit not specified DEPTH_UNIT_METERS 1 Depth should be displayed as meters DEPTH_UNIT_FEET 2 Depth should be displayed as feet FontSize Available font sizes for overlay text elements. Name Number Description FONT_SIZE_UNSPECIFIED 0 Font size not specified FONT_SIZE_PX15 1 15 px FONT_SIZE_PX20 2 20 px FONT_SIZE_PX25 3 25 px FONT_SIZE_PX30 4 30 px FONT_SIZE_PX35 5 35 px FONT_SIZE_PX40 6 40 px Framerate Available camera framerates. Name Number Description FRAMERATE_UNSPECIFIED 0 Framerate not specified FRAMERATE_FPS_30 1 30 frames per second FRAMERATE_FPS_25 2 25 frames per second GuestPortDeviceID GuestPort device ID. Name Number Description GUEST_PORT_DEVICE_ID_UNSPECIFIED 0 Unspecified GUEST_PORT_DEVICE_ID_BLIND_PLUG 1 Blueye blind plug GUEST_PORT_DEVICE_ID_TEST_STATION 2 Blueye test station GUEST_PORT_DEVICE_ID_DEBUG_SERIAL 3 Blueye debug serial GUEST_PORT_DEVICE_ID_BLUEYE_LIGHT 4 Blueye Light GUEST_PORT_DEVICE_ID_BLUEYE_CAM 5 Blueye Cam GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_LUMEN 6 Blue Robotics Lumen GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_NEWTON 7 Blue Robotics Newton GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_PING_SONAR 8 Blue Robotics Ping Sonar GUEST_PORT_DEVICE_ID_BLUEPRINT_LAB_REACH_ALPHA 9 Blueprint Lab Reach Alpha GUEST_PORT_DEVICE_ID_WATERLINKED_DVL_A50 10 Waterlinked DVL A50 GUEST_PORT_DEVICE_ID_IMPACT_SUBSEA_ISS360 11 Impact Subsea ISS360 Sonar GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_SEATRAC_X010 12 Blueprint Subsea Seatrac X110 GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_OCULUS_M750D 13 Blueprint Subsea Oculus M750d GUEST_PORT_DEVICE_ID_CYGNUS_MINI_ROV_THICKNESS_GAUGE 14 Cygnus Mini ROV Thickness Gauge GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_PING360_SONAR 15 Blue Robotics Ping360 Scanning Imaging Sonar GUEST_PORT_DEVICE_ID_TRITECH_GEMINI_720IM 16 Tritech Gemini 720im Multibeam Sonar GUEST_PORT_DEVICE_ID_BLUEYE_LIGHT_PAIR 17 Blueye Light Pair GUEST_PORT_DEVICE_ID_TRITECH_GEMINI_MICRON 18 Tritech Micron Gemini GUEST_PORT_DEVICE_ID_OCEAN_TOOLS_DIGICP 19 Ocean Tools DigiCP GUEST_PORT_DEVICE_ID_TRITECH_GEMINI_720IK 20 Tritech Gemini 720ik Multibeam Sonar GUEST_PORT_DEVICE_ID_NORTEK_NUCLEUS_1000 21 Nortek Nucleus 1000 DVL GUEST_PORT_DEVICE_ID_BLUEYE_GENERIC_SERVO 22 Blueye Generic Servo GUEST_PORT_DEVICE_ID_BLUEYE_MULTIBEAM_SERVO 23 Blueye Multibeam Servo GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_DETACHABLE_NEWTON 24 Detachable Blue Robotics Newton GUEST_PORT_DEVICE_ID_INSITU_AQUA_TROLL_500 25 In-Situ Aqua TROLL 500 GUEST_PORT_DEVICE_ID_MEDUSA_RADIOMETRICS_MS100 26 Medusa Radiometrics Gamma Ray Sensor GUEST_PORT_DEVICE_ID_LASER_TOOLS_SEA_BEAM 27 Laser Tools Sea Beam Underwater Laser GUEST_PORT_DEVICE_ID_SPOT_X_LASER_SCALERS 28 Spot X Laser Scalers GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_OCULUS_M1200D 29 Blueprint Subsea Oculus M1200d GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_OCULUS_M3000D 30 Blueprint Subsea Oculus M3000d GuestPortError GuestPort error. Name Number Description GUEST_PORT_ERROR_UNSPECIFIED 0 Unspecified value GUEST_PORT_ERROR_NOT_CONNECTED 1 Device not connected GUEST_PORT_ERROR_READ_ERROR 2 EEPROM read error GUEST_PORT_ERROR_NOT_FLASHED 3 Connector not flashed GUEST_PORT_ERROR_CRC_ERROR 4 Wrong CRC for protobuf message GUEST_PORT_ERROR_PARSE_ERROR 5 Protobuf message cannot be parsed GuestPortNumber GuestPort number. Name Number Description GUEST_PORT_NUMBER_UNSPECIFIED 0 Unspecified GUEST_PORT_NUMBER_PORT_1 1 Guest port 1 GUEST_PORT_NUMBER_PORT_2 2 Guest port 2 GUEST_PORT_NUMBER_PORT_3 3 Guest port 3 HeadingSource Heading source used during reset of the position estimate. Name Number Description HEADING_SOURCE_UNSPECIFIED 0 Unspecified HEADING_SOURCE_DRONE_COMPASS 1 Uses the drone compass to set the heading HEADING_SOURCE_MANUAL_INPUT 2 Used when the user sets the heading manually LogoType Available logo types. Name Number Description LOGO_TYPE_UNSPECIFIED 0 Logo type not specified LOGO_TYPE_NONE 1 Do not add any logo LOGO_TYPE_DEFAULT 2 Add default logo LOGO_TYPE_CUSTOM 3 Add user defined logo Model Drone models produced by Blueye Name Number Description MODEL_UNSPECIFIED 0 ModelName not specified MODEL_PIONEER 1 Blueye Pioneer, the first model MODEL_PRO 2 Blueye Pro, features camera tilt MODEL_X3 3 Blueye X3, features support for peripherals NavigationSensorID List of navigation sensors that can be used by the position observer Name Number Description NAVIGATION_SENSOR_ID_UNSPECIFIED 0 Unspecified NAVIGATION_SENSOR_ID_WATERLINKED_DVL_A50 1 Water Linked DVL A50 NAVIGATION_SENSOR_ID_WATERLINKED_UGPS_G2 2 Water Linked UGPS G2 PingerConfiguration.MountingDirection Name Number Description MOUNTING_DIRECTION_UNSPECIFIED 0 Mounting direction is unspecified MOUNTING_DIRECTION_FORWARDS 1 Pointing forwards from the drones perspective MOUNTING_DIRECTION_DOWNWARDS 2 Pointing downwards from the drones perspective PressureSensorType Depth sensors used by the drone. Name Number Description PRESSURE_SENSOR_TYPE_UNSPECIFIED 0 Depth sensor type not specified PRESSURE_SENSOR_TYPE_NOT_CONNECTED 1 No se PRESSURE_SENSOR_TYPE_MS5837_30BA26 2 Thh MS5837 30BA26 pressure sensor PRESSURE_SENSOR_TYPE_KELLER_PA7LD 3 The extended depth sensor using the Keller PA7LD pressure sensor PRESSURE_SENSOR_TYPE_MS5637_02BA03 4 The internal pressure sensor using the MS5637 02BA03 pressure sensor ResetCoordinateSource Name Number Description RESET_COORDINATE_SOURCE_UNSPECIFIED 0 Unspecified, fallback to device GPS RESET_COORDINATE_SOURCE_DEVICE_GPS 1 Uses the device GPS to set the reset point RESET_COORDINATE_SOURCE_MANUAL 2 Uses a coordinate in decimal degrees to set the reset point Resolution Available camera resolutions. Name Number Description RESOLUTION_UNSPECIFIED 0 Resolution not specified RESOLUTION_FULLHD_1080P 1 1080p Full HD resolution RESOLUTION_HD_720P 2 720p HD resolution TemperatureUnit Available temperature units. Name Number Description TEMPERATURE_UNIT_UNSPECIFIED 0 Temperature unit not specfied TEMPERATURE_UNIT_CELSIUS 1 Temperature should be displayed as Celcius TEMPERATURE_UNIT_FAHRENHEIT 2 Temperature should be displayed as Fahrenheit ThicknessUnit Available thickness units. Name Number Description THICKNESS_UNIT_UNSPECIFIED 0 Thickness unit not specified THICKNESS_UNIT_MILLIMETERS 1 Thickness should be displayed as millimeters THICKNESS_UNIT_INCHES 2 Thickness should be displayed as inches Top req_rep.proto Request reply These messages define request / reply messages for the Blueye drone. ConnectClientRep Response after connecting a client to the drone. Contains information about which client is in control, and a list of all connected clients. Field Type Label Description client_id uint32 The assigned ID of this client. client_id_in_control uint32 The ID of the client in control of the drone. connected_clients ConnectedClient repeated List of connected clients. ConnectClientReq Connect a new client to the drone. Field Type Label Description client_info ClientInfo Information about the client connecting to the drone. DisconnectClientRep Response after disconnecting a client from the drone. Contains information about which clients are connected and in control. Field Type Label Description client_id_in_control uint32 The ID of the client in control of the drone. connected_clients ConnectedClient repeated List of connected clients. DisconnectClientReq Disconnect a client from the drone. This request will remove the client from the list of connected clients. It allows clients to disconnect instantly, without waiting for a watchdog to clear the client in control, or promote a new client to be in control. Field Type Label Description client_id uint32 The assigned ID of the client to disconnect. GetBatteryRep Response with essential battery information. Field Type Label Description battery Battery Essential battery information. GetBatteryReq Request essential battery information. Can be used to instantly get battery information, instead of having to wait for the BatteryTel message to be received. GetCameraParametersRep Response with the currently set camera parameters. Field Type Label Description camera_parameters CameraParameters The currently set camera parameters. GetCameraParametersReq Request to get the currently set camera parameters. Field Type Label Description camera Camera Which camera to read camera parameters from. GetOverlayParametersRep Response with the currently set video overlay parameters. Field Type Label Description overlay_parameters OverlayParameters The currently set overlay parameters. GetOverlayParametersReq Request to get currently set video overlay parameters. PingRep Response message from a PingReq request. PingReq The simplest message to use to test request/reply communication with the drone. The drone replies with a PingRep message immediately after receiving the PingReq. SetCameraParametersRep Response after setting the camera parameters. SetCameraParametersReq Request to set camera parameters. Field Type Label Description camera_parameters CameraParameters The camera parameters to apply. SetOverlayParametersRep Response after setting video overlay parameters. SetOverlayParametersReq Request to set video overlay parameters. Field Type Label Description overlay_parameters OverlayParameters The video overlay parameters to apply. SetPubFrequencyRep Response aftrer updating publish frequency Field Type Label Description success bool True if message name valid and frequency successfully updated. SetPubFrequencyReq Request to update the publish frequency Field Type Label Description message_type string Message name, f. ex. \"AttitudeTel\" frequency float Publish frequency (max 100 Hz). SetThicknessGaugeParametersRep Response after setting thicknes gauge parameters. SetThicknessGaugeParametersReq Request to set parameters for ultrasonic thickness gauge. The sound velocity is used to calculate the thickness of the material being measured. Field Type Label Description sound_velocity uint32 Sound velocity in m/s SyncTimeRep Response after setting the system time on the drone. Field Type Label Description success bool If the time was set successfully. SyncTimeReq Request to set the system time on the drone. Field Type Label Description time SystemTime The time to set on the drone. Top telemetry.proto Telemetry These messages define telemetry messages from the Blueye drone. AltitudeTel Receive the current altitude of the drone. Field Type Label Description altitude Altitude The altitude of the drone. AttitudeTel Receive the current attitude of the drone. Field Type Label Description attitude Attitude The attitude of the drone. BatteryBQ40Z50Tel Receive detailed information about a battery using the BQ40Z50 battery management system. Field Type Label Description battery BatteryBQ40Z50 Detailed battery information. BatteryTel Receive essential information about the battery status. Field Type Label Description battery Battery Essential battery information. CPUTemperatureTel Field Type Label Description temperature CPUTemperature CalibratedImuTel Calibrated IMU data Field Type Label Description imu Imu CalibrationStateTel Field Type Label Description calibration_state CalibrationState CanisterBottomHumidityTel Receive humidity information from the bottom canister. Field Type Label Description humidity CanisterHumidity Humidity information CanisterBottomTemperatureTel Receive temperature information from the bottom canister. Field Type Label Description temperature CanisterTemperature Temperature information. CanisterTopHumidityTel Receive humidity information from the top canister. Field Type Label Description humidity CanisterHumidity Humidity information CanisterTopTemperatureTel Receive temperature information from the top canister. Field Type Label Description temperature CanisterTemperature Temperature information. ConnectedClientsTel List of connected clients telemetry message. Field Type Label Description client_id_in_control uint32 The client id of the client in control. connected_clients ConnectedClient repeated List of connected clients. ControlForceTel Field Type Label Description control_force ControlForce ControlModeTel Receive the current state of the control system. Field Type Label Description state ControlMode State of the control system. ControllerHealthTel Field Type Label Description controller_health ControllerHealth CpProbeTel Cathodic Protection Potential probe telemetry message Field Type Label Description cp_probe CpProbe Reading from cp probe. DataStorageSpaceTel Field Type Label Description storage_space StorageSpace DepthTel Field Type Label Description depth Depth DiveTimeTel Receive the dive time of the drone. Field Type Label Description dive_time DiveTime The current dive time of the drone. DroneInfoTel Receive metadata and information about the connected drone. Field Type Label Description drone_info DroneInfo Various metadata such as software versions and serial number. DroneTimeTel Receive time information from the drone. Field Type Label Description real_time_clock SystemTime The real-time clock of the drone. monotonic_clock SystemTime The monotonic clock of the drone (time since power on). ErrorFlagsTel Receive currently set error flags. Field Type Label Description error_flags ErrorFlags Currently set error flags on the drone. ForwardDistanceTel Field Type Label Description forward_distance ForwardDistance GenericServoTel State of a generic servo Field Type Label Description servo GenericServo Servo state GuestPortCurrentTel GuestPort current readings Field Type Label Description current GuestPortCurrent GuestPortLightsTel Receive the status of any guest port lights connected to the drone. Field Type Label Description lights Lights Imu1Tel Raw IMU data from IMU 1 Field Type Label Description imu Imu Imu2Tel Raw IMU data from IMU 2 Field Type Label Description imu Imu IperfTel Field Type Label Description status IperfStatus LaserTel Receive the status of any lasers connected to the drone. Field Type Label Description laser Laser LightsTel Receive the status of the main lights of the drone. Field Type Label Description lights Lights MedusaSpectrometerDataTel Medusa gamma ray sensor spectrometer data Field Type Label Description data MedusaSpectrometerData MultibeamServoTel State of the servo installed in the multibeam Field Type Label Description servo MultibeamServo Multibeam servo state NStreamersTel Field Type Label Description n_streamers NStreamers PilotGPSPositionTel Field Type Label Description position LatLongPosition PositionEstimateTel Field Type Label Description position_estimate PositionEstimate RecordStateTel Field Type Label Description record_state RecordState ReferenceTel Field Type Label Description reference Reference ThicknessGaugeTel Thickness gauge measurement telemetry message. Field Type Label Description thickness_gauge ThicknessGauge Tickness measurement with a cygnus gauge. TiltAngleTel Field Type Label Description angle TiltAngle TiltStabilizationTel Field Type Label Description state TiltStabilizationState VideoStorageSpaceTel Field Type Label Description storage_space StorageSpace WaterTemperatureTel Field Type Label Description temperature WaterTemperature Scalar Value Types .proto Type Notes C++ Java Python Go C# PHP Ruby double double double float float64 double float Float float float float float float32 float float Float int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required) int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required) uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required) sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required) sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required) fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required) sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum bool bool boolean boolean bool bool boolean TrueClass/FalseClass string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8) bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Protobuf protocol"},{"location":"docs/protobuf-protocol/#protocol-documentation","text":"","title":"Protocol Documentation"},{"location":"docs/protobuf-protocol/#controlproto","text":"Control These messages define control messages accepted by the Blueye drone.","title":"control.proto"},{"location":"docs/protobuf-protocol/#activateguestportsctrl","text":"Activated the guest port power","title":"ActivateGuestPortsCtrl"},{"location":"docs/protobuf-protocol/#autoaltitudectrl","text":"Issue a command to set auto altitude to a desired state. Field Type Label Description state AutoAltitudeState State of the altitude controller","title":"AutoAltitudeCtrl"},{"location":"docs/protobuf-protocol/#autodepthctrl","text":"Issue a command to set auto depth to a desired state. Field Type Label Description state AutoDepthState State of the depth controller","title":"AutoDepthCtrl"},{"location":"docs/protobuf-protocol/#autoheadingctrl","text":"Issue a command to set auto heading to a desired state. Field Type Label Description state AutoHeadingState State of the heading controller","title":"AutoHeadingCtrl"},{"location":"docs/protobuf-protocol/#cancelcalibrationctrl","text":"Issue a command to cancel compass calibration.","title":"CancelCalibrationCtrl"},{"location":"docs/protobuf-protocol/#deactivateguestportsctrl","text":"Deactivate the guest port power","title":"DeactivateGuestPortsCtrl"},{"location":"docs/protobuf-protocol/#finishcalibrationctrl","text":"Issue a command to finish compass calibration.","title":"FinishCalibrationCtrl"},{"location":"docs/protobuf-protocol/#genericservoctrl","text":"Issue a command to set a generic servo value. Field Type Label Description servo GenericServo Message with the desired servo value.","title":"GenericServoCtrl"},{"location":"docs/protobuf-protocol/#gripperctrl","text":"Issue a command to control the gripper. Field Type Label Description gripper_velocities GripperVelocities The desired gripping and rotation velocity.","title":"GripperCtrl"},{"location":"docs/protobuf-protocol/#guestportlightsctrl","text":"Issue a command to set the guest port light intensity. Field Type Label Description lights Lights Message with the desired light intensity.","title":"GuestportLightsCtrl"},{"location":"docs/protobuf-protocol/#laserctrl","text":"Issue a command to set the laser intensity. Field Type Label Description laser Laser Message with the desired laser intensity.","title":"LaserCtrl"},{"location":"docs/protobuf-protocol/#lightsctrl","text":"Issue a command to set the main light intensity. Field Type Label Description lights Lights Message with the desired light intensity.","title":"LightsCtrl"},{"location":"docs/protobuf-protocol/#motioninputctrl","text":"Issue a command to move the drone in the surge, sway, heave, or yaw direction. Field Type Label Description motion_input MotionInput Message with the desired movement in each direction.","title":"MotionInputCtrl"},{"location":"docs/protobuf-protocol/#multibeamservoctrl","text":"Issue a command to set multibeam servo angle. Field Type Label Description servo MultibeamServo Message with the desired servo angle.","title":"MultibeamServoCtrl"},{"location":"docs/protobuf-protocol/#pilotgpspositionctrl","text":"Issue a command with the GPS position of the pilot. Field Type Label Description position LatLongPosition The GPS position of the pilot.","title":"PilotGPSPositionCtrl"},{"location":"docs/protobuf-protocol/#pingerconfigurationctrl","text":"Issue a command to set the pinger configuration. Field Type Label Description configuration PingerConfiguration Message with the pinger configuration to set.","title":"PingerConfigurationCtrl"},{"location":"docs/protobuf-protocol/#recordctrl","text":"Issue a command to start video recording. Field Type Label Description record_on RecordOn Message specifying which cameras to record.","title":"RecordCtrl"},{"location":"docs/protobuf-protocol/#resetodometerctrl","text":"Issue a command to reset the odometer.","title":"ResetOdometerCtrl"},{"location":"docs/protobuf-protocol/#resetpositionctrl","text":"Issue a command to reset the position estimate. Field Type Label Description settings ResetPositionSettings Reset settings.","title":"ResetPositionCtrl"},{"location":"docs/protobuf-protocol/#restartguestportsctrl","text":"Restart the guest ports by turning power on and off Field Type Label Description restart_info GuestPortRestartInfo Message with information about how long to keep the guest ports off.","title":"RestartGuestPortsCtrl"},{"location":"docs/protobuf-protocol/#startcalibrationctrl","text":"Issue a command to start compass calibration.","title":"StartCalibrationCtrl"},{"location":"docs/protobuf-protocol/#stationkeepingctrl","text":"Issue a command to set station keeping to a desired state. Field Type Label Description state StationKeepingState State of the station keeping controller","title":"StationKeepingCtrl"},{"location":"docs/protobuf-protocol/#systemtimectrl","text":"Issue a command to set the system time on the drone. Field Type Label Description system_time SystemTime Message with the system time to set.","title":"SystemTimeCtrl"},{"location":"docs/protobuf-protocol/#takepicturectrl","text":"Issue a command to take a picture.","title":"TakePictureCtrl"},{"location":"docs/protobuf-protocol/#tiltstabilizationctrl","text":"Issue a command to enable or disable tilt stabilization. Field Type Label Description state TiltStabilizationState Message with the tilt stabilization state to set.","title":"TiltStabilizationCtrl"},{"location":"docs/protobuf-protocol/#tiltvelocityctrl","text":"Issue a command to tilt the drone camera. Field Type Label Description velocity TiltVelocity Message with the desired tilt velocity (direction and speed).","title":"TiltVelocityCtrl"},{"location":"docs/protobuf-protocol/#watchdogctrl","text":"Issue a watchdog message to indicate that the remote client is connected and working as expected. If a watchdog message is not received every second, the drone will turn off lights and other auto functions to indicate that connection with the client has been lost. Field Type Label Description connection_duration ConnectionDuration Message with the number of seconds the client has been connected. client_id uint32 The ID of the client, received in the ConnectClientRep response.","title":"WatchdogCtrl"},{"location":"docs/protobuf-protocol/#waterdensityctrl","text":"Issue a command to set the water density. Field Type Label Description density WaterDensity Message with the water density to set.","title":"WaterDensityCtrl"},{"location":"docs/protobuf-protocol/#weathervaningctrl","text":"Issue a command to set station keeping with weather vaning to a desired state. Field Type Label Description state WeatherVaningState State of the weather vaning controller Top","title":"WeatherVaningCtrl"},{"location":"docs/protobuf-protocol/#message_formatsproto","text":"Common messages These are used for logging as well as building requests and responses.","title":"message_formats.proto"},{"location":"docs/protobuf-protocol/#altitude","text":"Drone altitude over seabed, typically obtained from a DVL. Field Type Label Description value float Drone altitude over seabed (m) is_valid bool If altitude is valid or not","title":"Altitude"},{"location":"docs/protobuf-protocol/#attitude","text":"The attitude of the drone. Field Type Label Description roll float Roll angle (-180\u00b0..180\u00b0) pitch float Pitch angle (-180\u00b0..180\u00b0) yaw float Yaw angle (-180\u00b0..180\u00b0)","title":"Attitude"},{"location":"docs/protobuf-protocol/#autoaltitudestate","text":"Auto altitude state. Field Type Label Description enabled bool If auto altitude is enabled","title":"AutoAltitudeState"},{"location":"docs/protobuf-protocol/#autodepthstate","text":"Auto depth state. Field Type Label Description enabled bool If auto depth is enabled","title":"AutoDepthState"},{"location":"docs/protobuf-protocol/#autoheadingstate","text":"Auto heading state. Field Type Label Description enabled bool If auto heading is enabled","title":"AutoHeadingState"},{"location":"docs/protobuf-protocol/#battery","text":"Essential battery information. Field Type Label Description voltage float Battery voltage (V) level float Battery level (0..1) temperature float Battery temperature (\u00b0C)","title":"Battery"},{"location":"docs/protobuf-protocol/#batterybq40z50","text":"Battery information message. Detailed information about all aspects of the connected Blueye Smart Battery, using the BQ40Z50 BMS. Field Type Label Description voltage BatteryBQ40Z50.Voltage Voltage of the battery cells temperature BatteryBQ40Z50.Temperature Temperature of the battery cells status BatteryBQ40Z50.BatteryStatus Battery status flags current float Current (A) average_current float Average current (A) relative_state_of_charge float Relative state of charge (0..1) absolute_state_of_charge float Absolute state of charge (0..1) remaining_capacity float Remaining capacity (Ah) full_charge_capacity float Full charge capacity (Ah) runtime_to_empty uint32 Runtime to empty (s) average_time_to_empty uint32 Average time to empty (s) average_time_to_full uint32 Average time to full (s) time_to_full_at_current_rate uint32 Time to fully charged at current rate (s) time_to_empty_at_current_rate uint32 Time to empty at current rate (s) charging_current float Charging current (A) charging_voltage float Charging voltage (V) cycle_count uint32 Number of charging cycles design_capacity float Design capacity (Ah) manufacture_date google.protobuf.Timestamp Manufacture date serial_number uint32 Serial number manufacturer_name string Manufacturer name device_name string Device name device_chemistry string Battery chemistry","title":"BatteryBQ40Z50"},{"location":"docs/protobuf-protocol/#batterybq40z50batterystatus","text":"Battery status from BQ40Z50 ref data sheet 0x16. Field Type Label Description overcharged_alarm bool terminate_charge_alarm bool over_temperature_alarm bool terminate_discharge_alarm bool remaining_capacity_alarm bool remaining_time_alarm bool initialization bool discharging_or_relax bool fully_charged bool fully_discharged bool error BatteryBQ40Z50.BatteryStatus.BatteryError Battery error codes","title":"BatteryBQ40Z50.BatteryStatus"},{"location":"docs/protobuf-protocol/#batterybq40z50temperature","text":"Battery temperature. Field Type Label Description average float Average temperature accross cells (\u00b0C) cell_1 float Cell 1 temperature (\u00b0C) cell_2 float Cell 2 temperature (\u00b0C) cell_3 float Cell 3 temperature (\u00b0C) cell_4 float Cell 4 temperature (\u00b0C)","title":"BatteryBQ40Z50.Temperature"},{"location":"docs/protobuf-protocol/#batterybq40z50voltage","text":"Battery voltage levels. Field Type Label Description total float Battery pack voltage level (V) cell_1 float Cell 1 voltage level (V) cell_2 float Vell 2 voltage level (V) cell_3 float Cell 3 voltage level (V) cell_4 float Cell 4 voltage level (V)","title":"BatteryBQ40Z50.Voltage"},{"location":"docs/protobuf-protocol/#binlogrecord","text":"Wrapper message for each entry in the drone telemetry logfile. Each entry contains the unix timestamp in UTC, the monotonic timestamp (time since boot), and an Any message wrapping the custom Blueye message. See separate documentation for the logfile format for more details. Field Type Label Description payload google.protobuf.Any The log entry payload. unix_timestamp google.protobuf.Timestamp Unix timestamp in UTC. clock_monotonic google.protobuf.Timestamp Posix CLOCK_MONOTONIC timestamp.","title":"BinlogRecord"},{"location":"docs/protobuf-protocol/#cputemperature","text":"CPU temperature. Field Type Label Description value float CPU temperature (\u00b0C)","title":"CPUTemperature"},{"location":"docs/protobuf-protocol/#calibrationstate","text":"Compass calibration state. Field Type Label Description status CalibrationState.Status Current calibration status progress_x_positive float Progress for the positive X axis (0..1) progress_x_negative float Progress for the negative X axis (0..1) progress_y_positive float Progress for the positive Y axis (0..1) progress_y_negative float Progress for the negative X axis (0..1) progress_z_positive float Progress for the positive Z axis (0..1) progress_z_negative float Progress for the negative Z axis (0..1) progress_thruster float Progress for the thruster calibration (0..1)","title":"CalibrationState"},{"location":"docs/protobuf-protocol/#cameraparameters","text":"Camera parameters. Field Type Label Description h264_bitrate int32 Bitrate of the h264 stream (bit/sec) mjpg_bitrate int32 Bitrate of the MJPG stream used for still pictures (bit/sec) exposure int32 Shutter speed (1/10000 * s), -1 for automatic exposure white_balance int32 White balance temperature (2800..9300), -1 for automatic white balance hue int32 Hue (-40..40), 0 as default gain float Iso gain (0..1) resolution Resolution Stream, recording and image resolution framerate Framerate Stream and recording framerate camera Camera Which camera the parameters belong to.","title":"CameraParameters"},{"location":"docs/protobuf-protocol/#canisterhumidity","text":"Canister humidity. Humidity measured in the top or bottom canister of the drone. Field Type Label Description humidity float Air humidity (%)","title":"CanisterHumidity"},{"location":"docs/protobuf-protocol/#canistertemperature","text":"Canister temperature. Temperature measured in the top or bottom canister of the drone. Field Type Label Description temperature float Temperature (\u00b0C)","title":"CanisterTemperature"},{"location":"docs/protobuf-protocol/#clientinfo","text":"Information about a remote client. Field Type Label Description type string The type of client (such as Blueye App, Observer App, SDK, etc) version string Client software version string device_type string Device type, such as mobile, tablet, or computer platform string Platform, such as iOS, Android, Linux, etc platform_version string Platform software version string name string Name of the client","title":"ClientInfo"},{"location":"docs/protobuf-protocol/#connectedclient","text":"Information about a connected client with an id assigned by the drone. Field Type Label Description client_id uint32 The assigned client id client_info ClientInfo Client information.","title":"ConnectedClient"},{"location":"docs/protobuf-protocol/#connectionduration","text":"Connection duration of a remote client. Field Type Label Description value int32 time since connected to drone (s)","title":"ConnectionDuration"},{"location":"docs/protobuf-protocol/#controlforce","text":"Control Force is used for showing the requested control force in each direction in Newtons. Field Type Label Description surge float Force in surge (N) sway float Force in sway (N) heave float Force in heave (N) yaw float Moment in yaw (Nm)","title":"ControlForce"},{"location":"docs/protobuf-protocol/#controlmode","text":"Control mode from drone supervisor Field Type Label Description auto_depth bool If auto depth is enabled auto_heading bool If auto heading is enabled auto_altitude bool If auto altitude is enabled station_keeping bool If station keeping is enabled weather_vaning bool If weather vaning is enabled","title":"ControlMode"},{"location":"docs/protobuf-protocol/#controllerhealth","text":"Controller health is used for showing the state of the controller with an relative error and load from 0 to 1. Field Type Label Description depth_error float Depth error in meters (m) depth_health float Depth controller load (0..1) heading_error float Heading error in degrees (\u00b0) heading_health float Heading controller load (0..1)","title":"ControllerHealth"},{"location":"docs/protobuf-protocol/#cpprobe","text":"Reading from a Cathodic Protection Potential probe. Field Type Label Description measurement float Potential measurement (V) is_measurement_valid bool Indicating if the measurement is valid","title":"CpProbe"},{"location":"docs/protobuf-protocol/#depth","text":"Water depth of the drone. Field Type Label Description value float Drone depth below surface (m)","title":"Depth"},{"location":"docs/protobuf-protocol/#divetime","text":"Amount of time the drone has been submerged. The drone starts incrementing this value when the depth is above 250 mm. Field Type Label Description value int32 Number of seconds the drone has been submerged","title":"DiveTime"},{"location":"docs/protobuf-protocol/#droneinfo","text":"Information about the drone. This message contains serial numbers and version informattion for internal components in the drone. Primarily used for diagnostics, or to determine the origin of a logfile. Field Type Label Description blunux_version string Blunux version string serial_number bytes Drone serial number hardware_id bytes Main computer unique identifier model Model Drone model mb_serial bytes Motherboard serial number bb_serial bytes Backbone serial number ds_serial bytes Drone stack serial number mb_uid bytes Motherboard unique identifier bb_uid bytes Backbone unique identifier gp GuestPortInfo GuestPortInfo depth_sensor PressureSensorType Type of depth sensor that is connected to the drone","title":"DroneInfo"},{"location":"docs/protobuf-protocol/#errorflags","text":"Known error states for the drone. Field Type Label Description pmu_comm_ack bool Acknowledge message not received for a message published to internal micro controller pmu_comm_stream bool Error in communication with internal micro controller depth_read bool Error reading depth sensor value depth_spike bool Sudden spike in value read from depth sensor inner_pressure_read bool Error reading inner pressure of the drone inner_pressure_spike bool Sudden spike in inner preassure compass_calibration bool Compass needs calibration tilt_calibration bool Error during calibration of tilt endpoints gp1_read bool Guest port 1 read error gp2_read bool Guest port 2 read error gp3_read bool Guest port 3 read error gp1_not_flashed bool Guest port 1 not flashed gp2_not_flashed bool Guest port 2 not flashed gp3_not_flashed bool Guest port 3 not flashed gp1_unknown_device bool Unknown device on guest port 1 gp2_unknown_device bool Unknown device on guest port 2 gp3_unknown_device bool Unknown device on guest port 3 gp1_device_connection bool Guest port 1 connection error gp2_device_connection bool Guest port 2 connection error gp3_device_connection bool Guest port 3 connection error gp1_device bool Guest port 1 device error gp2_device bool Guest port 2 device error gp3_device bool Guest port 3 device error drone_serial_not_set bool Drone serial number not set drone_serial bool Drone serial number error mb_eeprom_read bool MB eeprom read error bb_eeprom_read bool BB eeprom read error mb_eeprom_not_flashed bool MB eeprom not flashed bb_eeprom_not_flashed bool BB eeprom not flashed main_camera_connection bool We don't get buffers from the main camera main_camera_firmware bool The main camera firmware is wrong guestport_camera_connection bool We don't get buffers from the guestport camera guestport_camera_firmware bool The guestport camera firmware is wrong mb_serial bool MB serial number error bb_serial bool BB serial number error ds_serial bool DS serial number error gp_current_read bool Error reading GP current gp_current bool Max GP current exceeded gp1_bat_current bool Max battery current exceeded on GP1 gp2_bat_current bool Max battery current exceeded on GP2 gp3_bat_current bool Max battery current exceeded on GP3 gp_20v_current bool Max 20V current exceeded on GP","title":"ErrorFlags"},{"location":"docs/protobuf-protocol/#forwarddistance","text":"Distance to an object infront of the drone, typically obtained from an 1D pinger. Field Type Label Description value float Distance in front of drone (m) is_valid bool If distance reading is valid or not","title":"ForwardDistance"},{"location":"docs/protobuf-protocol/#genericservo","text":"Servo message used to represent the angle of the servo. Field Type Label Description value float Servo value (0..1) guest_port_number GuestPortNumber Guest port the servo is on","title":"GenericServo"},{"location":"docs/protobuf-protocol/#grippervelocities","text":"Gripper velocity values. Field Type Label Description grip_velocity float The gripping velocity (-1.0..1.0) rotate_velocity float The rotating velocity (-1.0..1.0)","title":"GripperVelocities"},{"location":"docs/protobuf-protocol/#guestportconnectorinfo","text":"GuestPort connector information. Field Type Label Description device_list GuestPortDeviceList List of devices on this connector error GuestPortError Guest port error guest_port_number GuestPortNumber Guest port the connector is connected to","title":"GuestPortConnectorInfo"},{"location":"docs/protobuf-protocol/#guestportcurrent","text":"GuestPort current readings. Field Type Label Description gp1_bat double Current on GP1 battery voltage (A) gp2_bat double Current on GP2 battery voltage (A) gp3_bat double Current on GP3 battery voltage (A) gp_20v double Current on common 20V supply (A)","title":"GuestPortCurrent"},{"location":"docs/protobuf-protocol/#guestportdevice","text":"GuestPort device. Field Type Label Description device_id GuestPortDeviceID Blueye device identifier manufacturer string Manufacturer name name string Device name serial_number string Serial number depth_rating float Depth rating (m) required_blunux_version string Required Blunux version (x.y.z)","title":"GuestPortDevice"},{"location":"docs/protobuf-protocol/#guestportdevicelist","text":"List of guest port devices. Field Type Label Description devices GuestPortDevice repeated List of guest port devices","title":"GuestPortDeviceList"},{"location":"docs/protobuf-protocol/#guestportinfo","text":"GuestPort information. Field Type Label Description gp1 GuestPortConnectorInfo GuestPortConnectorInfo 1 gp2 GuestPortConnectorInfo GuestPortConnectorInfo 2 gp3 GuestPortConnectorInfo GuestPortConnectorInfo 3","title":"GuestPortInfo"},{"location":"docs/protobuf-protocol/#guestportrestartinfo","text":"GuestPort restart information. Field Type Label Description power_off_duration double Duration to keep the guest ports off (s)","title":"GuestPortRestartInfo"},{"location":"docs/protobuf-protocol/#imu","text":"Imu data in drone body frame x - forward y - right z - down Field Type Label Description accelerometer Vector3 Acceleration (g) gyroscope Vector3 Angular velocity (rad/s) magnetometer Vector3 Magnetic field (\u03bcT) temperature float Temperature (\u00b0C)","title":"Imu"},{"location":"docs/protobuf-protocol/#iperfstatus","text":"Connection speed between drone and Surface Unit. Field Type Label Description sent float Transfer rate from drone to Surface Unit (Mbit/s) received float Transfer rate from Surface Unit to drone (Mbit/s)","title":"IperfStatus"},{"location":"docs/protobuf-protocol/#laser","text":"Laser message used to represent the intensity of connected laser. If the laser does not support dimming but only on and off, a value of 0 turns the laser off, and any value above 0 turns the laser on. Field Type Label Description value float Laser intensity, any value above 0 turns the laser on (0..1)","title":"Laser"},{"location":"docs/protobuf-protocol/#latlongposition","text":"Latitude and longitude position in WGS 84 decimal degrees format. Field Type Label Description latitude double Latitude (\u00b0) longitude double Longitude (\u00b0)","title":"LatLongPosition"},{"location":"docs/protobuf-protocol/#lights","text":"Lights message used to represent the intensity of the main light or external lights. Field Type Label Description value float Light intensity (0..1)","title":"Lights"},{"location":"docs/protobuf-protocol/#medusaspectrometerdata","text":"Medusa gamma ray sensor spectrometer data Field Type Label Description drone_time google.protobuf.Timestamp Time stamp when the data is received sensor_time google.protobuf.Timestamp Time stamp the sensor reports realtime float Time the sensor actually measured (s) livetime float Time the measurement took (s) total uint32 Total counts inside the spectrum countrate uint32 Counts per second inside the spectrum (rounded) cosmics uint32 Detected counts above the last channel","title":"MedusaSpectrometerData"},{"location":"docs/protobuf-protocol/#motioninput","text":"Motion input from client. Used to indicate the desired motion in each direction. Typically these values map to the left and right joystick for motion, and the left and right trigger for the slow and boost modifiers. Field Type Label Description surge float Forward (positive) and backwards (negative) movement. (-1..1) sway float Right (positive) and left (negative) lateral movement (-1..1) heave float Descend (positive) and ascend (negative) movement (-1..1) yaw float Left (positive) and right (negative) movement (-1..1) slow float Multiplier used to reduce the speed of the motion (0..1) boost float Multiplier used to increase the speed of the motion (0..1)","title":"MotionInput"},{"location":"docs/protobuf-protocol/#multibeamservo","text":"Servo message used to represent the angle of the servo. Field Type Label Description angle float Servo degrees (-30..30)","title":"MultibeamServo"},{"location":"docs/protobuf-protocol/#nstreamers","text":"Number of spectators connected to video stream. Field Type Label Description main int32 The number of clients to the main camera stream guestport int32 The number of clients to the guestport camera stream","title":"NStreamers"},{"location":"docs/protobuf-protocol/#navigationsensorstatus","text":"Navigation sensor used in the position observer with validity state Field Type Label Description sensor_id NavigationSensorID Sensor id is_valid bool Sensor validity","title":"NavigationSensorStatus"},{"location":"docs/protobuf-protocol/#overlayparameters","text":"Overlay parameters. All available parameters that can be used to configure telemetry overlay on video recordings. Field Type Label Description temperature_enabled bool If temperature should be included depth_enabled bool If depth should be included heading_enabled bool If heading should be included tilt_enabled bool If camera tilt angle should be included thickness_enabled bool If camera tilt angle should be included date_enabled bool If date should be included distance_enabled bool If distance should be included altitude_enabled bool If altitude should be included cp_probe_enabled bool If cp-probe should be included medusa_enabled bool If medusa measurement should be included drone_location_enabled bool If the drone location coordinates should be included logo_type LogoType Which logo should be used depth_unit DepthUnit Which unit should be used for depth: Meter, Feet or None temperature_unit TemperatureUnit Which unit should be used for temperature: Celcius or Fahrenheit thickness_unit ThicknessUnit Which unit should be used for thickness: Millimeters or Inches timezone_offset int32 Timezone offset from UTC (min) margin_width int32 Horizontal margins of text elements (px) margin_height int32 Vertical margins of text elements (px) font_size FontSize Font size of text elements title string Optional title subtitle string Optional subtitle date_format string Posix strftime format string for time stamp shading float Pixel intensity to subtract from text background (0..1), 0: transparent, 1: black","title":"OverlayParameters"},{"location":"docs/protobuf-protocol/#pingerconfiguration","text":"Pinger configuration. Used to specify the configuration the BR 1D-Pinger. Field Type Label Description mounting_direction PingerConfiguration.MountingDirection Mounting direction of the pinger","title":"PingerConfiguration"},{"location":"docs/protobuf-protocol/#positionestimate","text":"Position estimate from the Extended Kalman filter based observer if a DVL is connected. Field Type Label Description northing float Position from reset point (m) easting float Position from reset point (m) heading float Gyro based heading estimate (continous radians) surge_rate float Velocity in surge (m/s) sway_rate float Velocity in sway (m/s) yaw_rate float Rotaion rate in yaw (rad/s) ocean_current float Estimated ocean current (m/s) odometer float Travelled distance since reset (m) is_valid bool If the estimate can be trusted global_position LatLongPosition Best estimate of the global position in decimal degrees navigation_sensors NavigationSensorStatus repeated List of available sensors with status","title":"PositionEstimate"},{"location":"docs/protobuf-protocol/#recordon","text":"Which cameras are supposed to be recording Field Type Label Description main bool Record the main camera guestport bool Record external camera","title":"RecordOn"},{"location":"docs/protobuf-protocol/#recordstate","text":"Camera recording state. Field Type Label Description main_is_recording bool If the main camera is recording main_seconds int32 Main record time (s) guestport_is_recording bool If the guestport camera is recording guestport_seconds int32 Guestport record time (s)","title":"RecordState"},{"location":"docs/protobuf-protocol/#reference","text":"Reference for the control system. Note that the internal heading referece is not relative to North. Use (ControlHealth.heading_error + pose.yaw) instead. Field Type Label Description surge float Reference from joystick surge input (0..1) sway float Reference from joystick sway input (0..1) heave float Reference from joystick heave input (0..1) yaw float Reference from joystick yaw input (0..1) depth float Reference drone depth below surface (m) heading float Reference used in auto heading mode, gyro based (\u00b0) altitude float Reference used in auto altitude mode (m)","title":"Reference"},{"location":"docs/protobuf-protocol/#resetpositionsettings","text":"ResetPositionSettings used during reset of the position estimate. Field Type Label Description heading_source_during_reset HeadingSource Option to use the drone compass or due North as heading during reset manual_heading float Heading in degrees (0-359) reset_coordinate_source ResetCoordinateSource Option to use the device GPS or a manual coordinate. reset_coordinate LatLongPosition Reset coordinate in decimal degrees","title":"ResetPositionSettings"},{"location":"docs/protobuf-protocol/#stationkeepingstate","text":"Station keeping state. Field Type Label Description enabled bool If station keeping is enabled","title":"StationKeepingState"},{"location":"docs/protobuf-protocol/#storagespace","text":"Storage space. Field Type Label Description total_space int64 Total bytes of storage space (B) free_space int64 Available bytes of storage space (B)","title":"StorageSpace"},{"location":"docs/protobuf-protocol/#systemtime","text":"System time. Field Type Label Description unix_timestamp google.protobuf.Timestamp Unix timestamp","title":"SystemTime"},{"location":"docs/protobuf-protocol/#thicknessgauge","text":"Thickness measurement data from a Cygnus Thickness Gauge. Field Type Label Description thickness_measurement float Thickness measurement of a steel plate echo_count uint32 Indicating the quality of the reading when invalid (0-3) sound_velocity uint32 Speed of sound in the steel member (m/s) is_measurement_valid bool Indicating if the measurement is valid","title":"ThicknessGauge"},{"location":"docs/protobuf-protocol/#tiltangle","text":"Angle of tilt camera in degrees. Field Type Label Description value float Tilt angle (\u00b0)","title":"TiltAngle"},{"location":"docs/protobuf-protocol/#tiltstabilizationstate","text":"Tilt stabilization state. Blueye drones with mechanical tilt has the ability to enable camera stabilization. Field Type Label Description enabled bool If tilt stabilization is enabled","title":"TiltStabilizationState"},{"location":"docs/protobuf-protocol/#tiltvelocity","text":"Relative velocity of tilt Field Type Label Description value float Relative angular velocity of tilt (-1..1), negative means down and positive means up","title":"TiltVelocity"},{"location":"docs/protobuf-protocol/#vector3","text":"Vector with 3 elements Field Type Label Description x double x-component y double y-component z double z-component","title":"Vector3"},{"location":"docs/protobuf-protocol/#waterdensity","text":"Water density. Used to specify the water density the drone is operating in, to achieve more accruate depth measurements. Field Type Label Description value float Salinity (kg/l)","title":"WaterDensity"},{"location":"docs/protobuf-protocol/#watertemperature","text":"Water temperature measured by the drone's combined depth and temperature sensor. Field Type Label Description value float Water temperature (\u00b0C)","title":"WaterTemperature"},{"location":"docs/protobuf-protocol/#weathervaningstate","text":"Weather vaning state. Field Type Label Description enabled bool If weather vaning is enabled","title":"WeatherVaningState"},{"location":"docs/protobuf-protocol/#batterybq40z50batterystatusbatteryerror","text":"Battery errror code from BQ40Z50 BMS data sheet. Name Number Description BATTERY_ERROR_UNSPECIFIED 0 BATTERY_ERROR_OK 1 BATTERY_ERROR_BUSY 2 BATTERY_ERROR_RESERVED_COMMAND 3 BATTERY_ERROR_UNSUPPORTED_COMMAND 4 BATTERY_ERROR_ACCESS_DENIED 5 BATTERY_ERROR_OVERFLOW_UNDERFLOW 6 BATTERY_ERROR_BAD_SIZE 7 BATTERY_ERROR_UNKNOWN_ERROR 8","title":"BatteryBQ40Z50.BatteryStatus.BatteryError"},{"location":"docs/protobuf-protocol/#calibrationstatestatus","text":"Status of the compass calibration procedure. When calibration is started, the status will indicate the active (upfacing) axis. Name Number Description STATUS_UNSPECIFIED 0 Unspecified status STATUS_NOT_CALIBRATING 1 Compass is not currently calibrating STATUS_CALIBRATING_NO_AXIS 2 Compass is calibrating but active calibration axis cannot be determined STATUS_CALIBRATING_X_POSITIVE 3 Compass is calibrating and the positive X axis is active STATUS_CALIBRATING_X_NEGATIVE 4 Compass is calibrating and the negative X axis is active STATUS_CALIBRATING_Y_POSITIVE 5 Compass is calibrating and the positive Y axis is active STATUS_CALIBRATING_Y_NEGATIVE 6 Compass is calibrating and the negative Y axis is active STATUS_CALIBRATING_Z_POSITIVE 7 Compass is calibrating and the positive Z axis is active STATUS_CALIBRATING_Z_NEGATIVE 8 Compass is calibrating and the negative Z axis is active STATUS_CALIBRATING_THRUSTER 9 Compass is calibrating for thruster interferance","title":"CalibrationState.Status"},{"location":"docs/protobuf-protocol/#camera","text":"Which camera to control. Name Number Description CAMERA_UNSPECIFIED 0 Camera not specified CAMERA_MAIN 1 Main camera CAMERA_GUESTPORT 2 Guestport camera","title":"Camera"},{"location":"docs/protobuf-protocol/#depthunit","text":"Available depth units. Name Number Description DEPTH_UNIT_UNSPECIFIED 0 Depth unit not specified DEPTH_UNIT_METERS 1 Depth should be displayed as meters DEPTH_UNIT_FEET 2 Depth should be displayed as feet","title":"DepthUnit"},{"location":"docs/protobuf-protocol/#fontsize","text":"Available font sizes for overlay text elements. Name Number Description FONT_SIZE_UNSPECIFIED 0 Font size not specified FONT_SIZE_PX15 1 15 px FONT_SIZE_PX20 2 20 px FONT_SIZE_PX25 3 25 px FONT_SIZE_PX30 4 30 px FONT_SIZE_PX35 5 35 px FONT_SIZE_PX40 6 40 px","title":"FontSize"},{"location":"docs/protobuf-protocol/#framerate","text":"Available camera framerates. Name Number Description FRAMERATE_UNSPECIFIED 0 Framerate not specified FRAMERATE_FPS_30 1 30 frames per second FRAMERATE_FPS_25 2 25 frames per second","title":"Framerate"},{"location":"docs/protobuf-protocol/#guestportdeviceid","text":"GuestPort device ID. Name Number Description GUEST_PORT_DEVICE_ID_UNSPECIFIED 0 Unspecified GUEST_PORT_DEVICE_ID_BLIND_PLUG 1 Blueye blind plug GUEST_PORT_DEVICE_ID_TEST_STATION 2 Blueye test station GUEST_PORT_DEVICE_ID_DEBUG_SERIAL 3 Blueye debug serial GUEST_PORT_DEVICE_ID_BLUEYE_LIGHT 4 Blueye Light GUEST_PORT_DEVICE_ID_BLUEYE_CAM 5 Blueye Cam GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_LUMEN 6 Blue Robotics Lumen GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_NEWTON 7 Blue Robotics Newton GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_PING_SONAR 8 Blue Robotics Ping Sonar GUEST_PORT_DEVICE_ID_BLUEPRINT_LAB_REACH_ALPHA 9 Blueprint Lab Reach Alpha GUEST_PORT_DEVICE_ID_WATERLINKED_DVL_A50 10 Waterlinked DVL A50 GUEST_PORT_DEVICE_ID_IMPACT_SUBSEA_ISS360 11 Impact Subsea ISS360 Sonar GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_SEATRAC_X010 12 Blueprint Subsea Seatrac X110 GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_OCULUS_M750D 13 Blueprint Subsea Oculus M750d GUEST_PORT_DEVICE_ID_CYGNUS_MINI_ROV_THICKNESS_GAUGE 14 Cygnus Mini ROV Thickness Gauge GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_PING360_SONAR 15 Blue Robotics Ping360 Scanning Imaging Sonar GUEST_PORT_DEVICE_ID_TRITECH_GEMINI_720IM 16 Tritech Gemini 720im Multibeam Sonar GUEST_PORT_DEVICE_ID_BLUEYE_LIGHT_PAIR 17 Blueye Light Pair GUEST_PORT_DEVICE_ID_TRITECH_GEMINI_MICRON 18 Tritech Micron Gemini GUEST_PORT_DEVICE_ID_OCEAN_TOOLS_DIGICP 19 Ocean Tools DigiCP GUEST_PORT_DEVICE_ID_TRITECH_GEMINI_720IK 20 Tritech Gemini 720ik Multibeam Sonar GUEST_PORT_DEVICE_ID_NORTEK_NUCLEUS_1000 21 Nortek Nucleus 1000 DVL GUEST_PORT_DEVICE_ID_BLUEYE_GENERIC_SERVO 22 Blueye Generic Servo GUEST_PORT_DEVICE_ID_BLUEYE_MULTIBEAM_SERVO 23 Blueye Multibeam Servo GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_DETACHABLE_NEWTON 24 Detachable Blue Robotics Newton GUEST_PORT_DEVICE_ID_INSITU_AQUA_TROLL_500 25 In-Situ Aqua TROLL 500 GUEST_PORT_DEVICE_ID_MEDUSA_RADIOMETRICS_MS100 26 Medusa Radiometrics Gamma Ray Sensor GUEST_PORT_DEVICE_ID_LASER_TOOLS_SEA_BEAM 27 Laser Tools Sea Beam Underwater Laser GUEST_PORT_DEVICE_ID_SPOT_X_LASER_SCALERS 28 Spot X Laser Scalers GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_OCULUS_M1200D 29 Blueprint Subsea Oculus M1200d GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_OCULUS_M3000D 30 Blueprint Subsea Oculus M3000d","title":"GuestPortDeviceID"},{"location":"docs/protobuf-protocol/#guestporterror","text":"GuestPort error. Name Number Description GUEST_PORT_ERROR_UNSPECIFIED 0 Unspecified value GUEST_PORT_ERROR_NOT_CONNECTED 1 Device not connected GUEST_PORT_ERROR_READ_ERROR 2 EEPROM read error GUEST_PORT_ERROR_NOT_FLASHED 3 Connector not flashed GUEST_PORT_ERROR_CRC_ERROR 4 Wrong CRC for protobuf message GUEST_PORT_ERROR_PARSE_ERROR 5 Protobuf message cannot be parsed","title":"GuestPortError"},{"location":"docs/protobuf-protocol/#guestportnumber","text":"GuestPort number. Name Number Description GUEST_PORT_NUMBER_UNSPECIFIED 0 Unspecified GUEST_PORT_NUMBER_PORT_1 1 Guest port 1 GUEST_PORT_NUMBER_PORT_2 2 Guest port 2 GUEST_PORT_NUMBER_PORT_3 3 Guest port 3","title":"GuestPortNumber"},{"location":"docs/protobuf-protocol/#headingsource","text":"Heading source used during reset of the position estimate. Name Number Description HEADING_SOURCE_UNSPECIFIED 0 Unspecified HEADING_SOURCE_DRONE_COMPASS 1 Uses the drone compass to set the heading HEADING_SOURCE_MANUAL_INPUT 2 Used when the user sets the heading manually","title":"HeadingSource"},{"location":"docs/protobuf-protocol/#logotype","text":"Available logo types. Name Number Description LOGO_TYPE_UNSPECIFIED 0 Logo type not specified LOGO_TYPE_NONE 1 Do not add any logo LOGO_TYPE_DEFAULT 2 Add default logo LOGO_TYPE_CUSTOM 3 Add user defined logo","title":"LogoType"},{"location":"docs/protobuf-protocol/#model","text":"Drone models produced by Blueye Name Number Description MODEL_UNSPECIFIED 0 ModelName not specified MODEL_PIONEER 1 Blueye Pioneer, the first model MODEL_PRO 2 Blueye Pro, features camera tilt MODEL_X3 3 Blueye X3, features support for peripherals","title":"Model"},{"location":"docs/protobuf-protocol/#navigationsensorid","text":"List of navigation sensors that can be used by the position observer Name Number Description NAVIGATION_SENSOR_ID_UNSPECIFIED 0 Unspecified NAVIGATION_SENSOR_ID_WATERLINKED_DVL_A50 1 Water Linked DVL A50 NAVIGATION_SENSOR_ID_WATERLINKED_UGPS_G2 2 Water Linked UGPS G2","title":"NavigationSensorID"},{"location":"docs/protobuf-protocol/#pingerconfigurationmountingdirection","text":"Name Number Description MOUNTING_DIRECTION_UNSPECIFIED 0 Mounting direction is unspecified MOUNTING_DIRECTION_FORWARDS 1 Pointing forwards from the drones perspective MOUNTING_DIRECTION_DOWNWARDS 2 Pointing downwards from the drones perspective","title":"PingerConfiguration.MountingDirection"},{"location":"docs/protobuf-protocol/#pressuresensortype","text":"Depth sensors used by the drone. Name Number Description PRESSURE_SENSOR_TYPE_UNSPECIFIED 0 Depth sensor type not specified PRESSURE_SENSOR_TYPE_NOT_CONNECTED 1 No se PRESSURE_SENSOR_TYPE_MS5837_30BA26 2 Thh MS5837 30BA26 pressure sensor PRESSURE_SENSOR_TYPE_KELLER_PA7LD 3 The extended depth sensor using the Keller PA7LD pressure sensor PRESSURE_SENSOR_TYPE_MS5637_02BA03 4 The internal pressure sensor using the MS5637 02BA03 pressure sensor","title":"PressureSensorType"},{"location":"docs/protobuf-protocol/#resetcoordinatesource","text":"Name Number Description RESET_COORDINATE_SOURCE_UNSPECIFIED 0 Unspecified, fallback to device GPS RESET_COORDINATE_SOURCE_DEVICE_GPS 1 Uses the device GPS to set the reset point RESET_COORDINATE_SOURCE_MANUAL 2 Uses a coordinate in decimal degrees to set the reset point","title":"ResetCoordinateSource"},{"location":"docs/protobuf-protocol/#resolution","text":"Available camera resolutions. Name Number Description RESOLUTION_UNSPECIFIED 0 Resolution not specified RESOLUTION_FULLHD_1080P 1 1080p Full HD resolution RESOLUTION_HD_720P 2 720p HD resolution","title":"Resolution"},{"location":"docs/protobuf-protocol/#temperatureunit","text":"Available temperature units. Name Number Description TEMPERATURE_UNIT_UNSPECIFIED 0 Temperature unit not specfied TEMPERATURE_UNIT_CELSIUS 1 Temperature should be displayed as Celcius TEMPERATURE_UNIT_FAHRENHEIT 2 Temperature should be displayed as Fahrenheit","title":"TemperatureUnit"},{"location":"docs/protobuf-protocol/#thicknessunit","text":"Available thickness units. Name Number Description THICKNESS_UNIT_UNSPECIFIED 0 Thickness unit not specified THICKNESS_UNIT_MILLIMETERS 1 Thickness should be displayed as millimeters THICKNESS_UNIT_INCHES 2 Thickness should be displayed as inches Top","title":"ThicknessUnit"},{"location":"docs/protobuf-protocol/#req_repproto","text":"Request reply These messages define request / reply messages for the Blueye drone.","title":"req_rep.proto"},{"location":"docs/protobuf-protocol/#connectclientrep","text":"Response after connecting a client to the drone. Contains information about which client is in control, and a list of all connected clients. Field Type Label Description client_id uint32 The assigned ID of this client. client_id_in_control uint32 The ID of the client in control of the drone. connected_clients ConnectedClient repeated List of connected clients.","title":"ConnectClientRep"},{"location":"docs/protobuf-protocol/#connectclientreq","text":"Connect a new client to the drone. Field Type Label Description client_info ClientInfo Information about the client connecting to the drone.","title":"ConnectClientReq"},{"location":"docs/protobuf-protocol/#disconnectclientrep","text":"Response after disconnecting a client from the drone. Contains information about which clients are connected and in control. Field Type Label Description client_id_in_control uint32 The ID of the client in control of the drone. connected_clients ConnectedClient repeated List of connected clients.","title":"DisconnectClientRep"},{"location":"docs/protobuf-protocol/#disconnectclientreq","text":"Disconnect a client from the drone. This request will remove the client from the list of connected clients. It allows clients to disconnect instantly, without waiting for a watchdog to clear the client in control, or promote a new client to be in control. Field Type Label Description client_id uint32 The assigned ID of the client to disconnect.","title":"DisconnectClientReq"},{"location":"docs/protobuf-protocol/#getbatteryrep","text":"Response with essential battery information. Field Type Label Description battery Battery Essential battery information.","title":"GetBatteryRep"},{"location":"docs/protobuf-protocol/#getbatteryreq","text":"Request essential battery information. Can be used to instantly get battery information, instead of having to wait for the BatteryTel message to be received.","title":"GetBatteryReq"},{"location":"docs/protobuf-protocol/#getcameraparametersrep","text":"Response with the currently set camera parameters. Field Type Label Description camera_parameters CameraParameters The currently set camera parameters.","title":"GetCameraParametersRep"},{"location":"docs/protobuf-protocol/#getcameraparametersreq","text":"Request to get the currently set camera parameters. Field Type Label Description camera Camera Which camera to read camera parameters from.","title":"GetCameraParametersReq"},{"location":"docs/protobuf-protocol/#getoverlayparametersrep","text":"Response with the currently set video overlay parameters. Field Type Label Description overlay_parameters OverlayParameters The currently set overlay parameters.","title":"GetOverlayParametersRep"},{"location":"docs/protobuf-protocol/#getoverlayparametersreq","text":"Request to get currently set video overlay parameters.","title":"GetOverlayParametersReq"},{"location":"docs/protobuf-protocol/#pingrep","text":"Response message from a PingReq request.","title":"PingRep"},{"location":"docs/protobuf-protocol/#pingreq","text":"The simplest message to use to test request/reply communication with the drone. The drone replies with a PingRep message immediately after receiving the PingReq.","title":"PingReq"},{"location":"docs/protobuf-protocol/#setcameraparametersrep","text":"Response after setting the camera parameters.","title":"SetCameraParametersRep"},{"location":"docs/protobuf-protocol/#setcameraparametersreq","text":"Request to set camera parameters. Field Type Label Description camera_parameters CameraParameters The camera parameters to apply.","title":"SetCameraParametersReq"},{"location":"docs/protobuf-protocol/#setoverlayparametersrep","text":"Response after setting video overlay parameters.","title":"SetOverlayParametersRep"},{"location":"docs/protobuf-protocol/#setoverlayparametersreq","text":"Request to set video overlay parameters. Field Type Label Description overlay_parameters OverlayParameters The video overlay parameters to apply.","title":"SetOverlayParametersReq"},{"location":"docs/protobuf-protocol/#setpubfrequencyrep","text":"Response aftrer updating publish frequency Field Type Label Description success bool True if message name valid and frequency successfully updated.","title":"SetPubFrequencyRep"},{"location":"docs/protobuf-protocol/#setpubfrequencyreq","text":"Request to update the publish frequency Field Type Label Description message_type string Message name, f. ex. \"AttitudeTel\" frequency float Publish frequency (max 100 Hz).","title":"SetPubFrequencyReq"},{"location":"docs/protobuf-protocol/#setthicknessgaugeparametersrep","text":"Response after setting thicknes gauge parameters.","title":"SetThicknessGaugeParametersRep"},{"location":"docs/protobuf-protocol/#setthicknessgaugeparametersreq","text":"Request to set parameters for ultrasonic thickness gauge. The sound velocity is used to calculate the thickness of the material being measured. Field Type Label Description sound_velocity uint32 Sound velocity in m/s","title":"SetThicknessGaugeParametersReq"},{"location":"docs/protobuf-protocol/#synctimerep","text":"Response after setting the system time on the drone. Field Type Label Description success bool If the time was set successfully.","title":"SyncTimeRep"},{"location":"docs/protobuf-protocol/#synctimereq","text":"Request to set the system time on the drone. Field Type Label Description time SystemTime The time to set on the drone. Top","title":"SyncTimeReq"},{"location":"docs/protobuf-protocol/#telemetryproto","text":"Telemetry These messages define telemetry messages from the Blueye drone.","title":"telemetry.proto"},{"location":"docs/protobuf-protocol/#altitudetel","text":"Receive the current altitude of the drone. Field Type Label Description altitude Altitude The altitude of the drone.","title":"AltitudeTel"},{"location":"docs/protobuf-protocol/#attitudetel","text":"Receive the current attitude of the drone. Field Type Label Description attitude Attitude The attitude of the drone.","title":"AttitudeTel"},{"location":"docs/protobuf-protocol/#batterybq40z50tel","text":"Receive detailed information about a battery using the BQ40Z50 battery management system. Field Type Label Description battery BatteryBQ40Z50 Detailed battery information.","title":"BatteryBQ40Z50Tel"},{"location":"docs/protobuf-protocol/#batterytel","text":"Receive essential information about the battery status. Field Type Label Description battery Battery Essential battery information.","title":"BatteryTel"},{"location":"docs/protobuf-protocol/#cputemperaturetel","text":"Field Type Label Description temperature CPUTemperature","title":"CPUTemperatureTel"},{"location":"docs/protobuf-protocol/#calibratedimutel","text":"Calibrated IMU data Field Type Label Description imu Imu","title":"CalibratedImuTel"},{"location":"docs/protobuf-protocol/#calibrationstatetel","text":"Field Type Label Description calibration_state CalibrationState","title":"CalibrationStateTel"},{"location":"docs/protobuf-protocol/#canisterbottomhumiditytel","text":"Receive humidity information from the bottom canister. Field Type Label Description humidity CanisterHumidity Humidity information","title":"CanisterBottomHumidityTel"},{"location":"docs/protobuf-protocol/#canisterbottomtemperaturetel","text":"Receive temperature information from the bottom canister. Field Type Label Description temperature CanisterTemperature Temperature information.","title":"CanisterBottomTemperatureTel"},{"location":"docs/protobuf-protocol/#canistertophumiditytel","text":"Receive humidity information from the top canister. Field Type Label Description humidity CanisterHumidity Humidity information","title":"CanisterTopHumidityTel"},{"location":"docs/protobuf-protocol/#canistertoptemperaturetel","text":"Receive temperature information from the top canister. Field Type Label Description temperature CanisterTemperature Temperature information.","title":"CanisterTopTemperatureTel"},{"location":"docs/protobuf-protocol/#connectedclientstel","text":"List of connected clients telemetry message. Field Type Label Description client_id_in_control uint32 The client id of the client in control. connected_clients ConnectedClient repeated List of connected clients.","title":"ConnectedClientsTel"},{"location":"docs/protobuf-protocol/#controlforcetel","text":"Field Type Label Description control_force ControlForce","title":"ControlForceTel"},{"location":"docs/protobuf-protocol/#controlmodetel","text":"Receive the current state of the control system. Field Type Label Description state ControlMode State of the control system.","title":"ControlModeTel"},{"location":"docs/protobuf-protocol/#controllerhealthtel","text":"Field Type Label Description controller_health ControllerHealth","title":"ControllerHealthTel"},{"location":"docs/protobuf-protocol/#cpprobetel","text":"Cathodic Protection Potential probe telemetry message Field Type Label Description cp_probe CpProbe Reading from cp probe.","title":"CpProbeTel"},{"location":"docs/protobuf-protocol/#datastoragespacetel","text":"Field Type Label Description storage_space StorageSpace","title":"DataStorageSpaceTel"},{"location":"docs/protobuf-protocol/#depthtel","text":"Field Type Label Description depth Depth","title":"DepthTel"},{"location":"docs/protobuf-protocol/#divetimetel","text":"Receive the dive time of the drone. Field Type Label Description dive_time DiveTime The current dive time of the drone.","title":"DiveTimeTel"},{"location":"docs/protobuf-protocol/#droneinfotel","text":"Receive metadata and information about the connected drone. Field Type Label Description drone_info DroneInfo Various metadata such as software versions and serial number.","title":"DroneInfoTel"},{"location":"docs/protobuf-protocol/#dronetimetel","text":"Receive time information from the drone. Field Type Label Description real_time_clock SystemTime The real-time clock of the drone. monotonic_clock SystemTime The monotonic clock of the drone (time since power on).","title":"DroneTimeTel"},{"location":"docs/protobuf-protocol/#errorflagstel","text":"Receive currently set error flags. Field Type Label Description error_flags ErrorFlags Currently set error flags on the drone.","title":"ErrorFlagsTel"},{"location":"docs/protobuf-protocol/#forwarddistancetel","text":"Field Type Label Description forward_distance ForwardDistance","title":"ForwardDistanceTel"},{"location":"docs/protobuf-protocol/#genericservotel","text":"State of a generic servo Field Type Label Description servo GenericServo Servo state","title":"GenericServoTel"},{"location":"docs/protobuf-protocol/#guestportcurrenttel","text":"GuestPort current readings Field Type Label Description current GuestPortCurrent","title":"GuestPortCurrentTel"},{"location":"docs/protobuf-protocol/#guestportlightstel","text":"Receive the status of any guest port lights connected to the drone. Field Type Label Description lights Lights","title":"GuestPortLightsTel"},{"location":"docs/protobuf-protocol/#imu1tel","text":"Raw IMU data from IMU 1 Field Type Label Description imu Imu","title":"Imu1Tel"},{"location":"docs/protobuf-protocol/#imu2tel","text":"Raw IMU data from IMU 2 Field Type Label Description imu Imu","title":"Imu2Tel"},{"location":"docs/protobuf-protocol/#iperftel","text":"Field Type Label Description status IperfStatus","title":"IperfTel"},{"location":"docs/protobuf-protocol/#lasertel","text":"Receive the status of any lasers connected to the drone. Field Type Label Description laser Laser","title":"LaserTel"},{"location":"docs/protobuf-protocol/#lightstel","text":"Receive the status of the main lights of the drone. Field Type Label Description lights Lights","title":"LightsTel"},{"location":"docs/protobuf-protocol/#medusaspectrometerdatatel","text":"Medusa gamma ray sensor spectrometer data Field Type Label Description data MedusaSpectrometerData","title":"MedusaSpectrometerDataTel"},{"location":"docs/protobuf-protocol/#multibeamservotel","text":"State of the servo installed in the multibeam Field Type Label Description servo MultibeamServo Multibeam servo state","title":"MultibeamServoTel"},{"location":"docs/protobuf-protocol/#nstreamerstel","text":"Field Type Label Description n_streamers NStreamers","title":"NStreamersTel"},{"location":"docs/protobuf-protocol/#pilotgpspositiontel","text":"Field Type Label Description position LatLongPosition","title":"PilotGPSPositionTel"},{"location":"docs/protobuf-protocol/#positionestimatetel","text":"Field Type Label Description position_estimate PositionEstimate","title":"PositionEstimateTel"},{"location":"docs/protobuf-protocol/#recordstatetel","text":"Field Type Label Description record_state RecordState","title":"RecordStateTel"},{"location":"docs/protobuf-protocol/#referencetel","text":"Field Type Label Description reference Reference","title":"ReferenceTel"},{"location":"docs/protobuf-protocol/#thicknessgaugetel","text":"Thickness gauge measurement telemetry message. Field Type Label Description thickness_gauge ThicknessGauge Tickness measurement with a cygnus gauge.","title":"ThicknessGaugeTel"},{"location":"docs/protobuf-protocol/#tiltangletel","text":"Field Type Label Description angle TiltAngle","title":"TiltAngleTel"},{"location":"docs/protobuf-protocol/#tiltstabilizationtel","text":"Field Type Label Description state TiltStabilizationState","title":"TiltStabilizationTel"},{"location":"docs/protobuf-protocol/#videostoragespacetel","text":"Field Type Label Description storage_space StorageSpace","title":"VideoStorageSpaceTel"},{"location":"docs/protobuf-protocol/#watertemperaturetel","text":"Field Type Label Description temperature WaterTemperature","title":"WaterTemperatureTel"},{"location":"docs/protobuf-protocol/#scalar-value-types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby double double double float float64 double float Float float float float float float32 float float Float int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required) int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required) uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required) sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required) sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required) fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required) sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum bool bool boolean boolean bool bool boolean TrueClass/FalseClass string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8) bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)","title":"Scalar Value Types"},{"location":"docs/quick_start/","text":"Installation The SDK requires Python 3.8 or higher. Since many operating systems do not package the newest version of Python we recommend using pyenv or something similar for configuring multiple python versions on the same system. Pyenv also has the added benefit of managing your virtual environments for you, though you are of course free to use other tools for that as well. The instructions below show the necessary steps to get started with the SDK on a fresh install: Windows Install Python Install Python 3.8 or higher, you can find the latest python versions here . Remember to check the option \"Add Python to path\" when installing. Install virtualenv for managing Python versions (optional) Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. # Upgrade pip version python -m pip install --upgrade pip pip install virtualenv Next, we create a virtual environment cd . \\D esktop mkdir drone_project cd . \\d rone_project # Replace \"C:\\Program Files\\Python310\\python.exe\" with the path # to the python version you want to use in the line below virtualenv blueye_sdk_env -p \"C:\\Program Files\\Python310\\python.exe\" activate the virtual environment . \\b lueye_sdk_env \\S cripts \\a ctivate.bat if you are not allowed to activate the virtual environment, you might have to allow running unsigned scripts, see this link for instructions. Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Mac OS Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl https://pyenv.run | bash pyenv update If you want pyenv to be loaded each time you open a new terminal you can add this to your .zshrc or the equivalent for your terminal export PATH=\"$HOME/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" The Pyenv wiki recommends installing some additional dependencies before building Python. # optional, but recommended: brew install openssl readline sqlite3 xz zlib When running Mojave or higher (10.14+) you will also need to install the additional SDK headers: sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target / Then build Python with pyenv pyenv install 3.10.1 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.10.1 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as. pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Linux These instructions are directed at Ubuntu, but the process should be similar for other distributions. Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash pyenv update Install the needed dependencies for building python 3.10.1 apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\ xz-utils tk-dev libffi-dev liblzma-dev python-openssl Then build python with pyenv pyenv install 3.10.1 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.10.1 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Connect to the drone To use the SDK your computer must be connected to the drone via the surface unit WiFi. For a how-to on turning on the drone and surface unit you can watch the quick start video . Control the drone Most of the functionality is controlled using Python properties and we will illustrate the use of properties by showing how to control the lights: import time from blueye.sdk import Drone # When the Drone object is instantiatied a connection to the drone is established myDrone = Drone () # Setting the lights property to 0.1 (10 %) myDrone . lights = 0.1 time . sleep ( 2 ) # We can also get the current brightness of the lights through the lights property print ( f \"Current light intensity: { myDrone . lights } \" ) myDrone . lights = 0 # Properties can also be used for reading telemetry data from the drone print ( f \"Current depth in meters: { myDrone . depth } \" ) For an overview of the properties that are available for controlling and reading data from the drone, go to the Reference section of the documentation. The valid input ranges and descriptions of the different properties can also be found there. Tip You can explore the properties of the drone interactively using an interactive python interpreter like iPython , install it with: pip install ipython By instantiating a Drone object and using the completion key (normally the tab-key \u21b9 ) you can get a interactive list of the available properties on the drone, it is then easy to try setting and getting the different properties. Watching the video stream The easiest way to open the RTSP video stream is using VLC media player . Once VLC is downloaded you can start the stream like this, the RTSP URL is: rtsp://192.168.1.101:8554/test For lower latency streaming (on a PC) you can see the instructions on using Gstreamer , or if you just want to watch a low latency stream you can download the Blueye Observer app. ( iOS / Android ) The normal Blueye app can not be used to spectate when controlling the drone from the SDK because it will interfere with the commands sent from the SDK. The Observer app, however, is only a spectator and can be used together with the SDK. Explore the examples For further examples on how to use the SDK to control the drone have a look at the motion examples . Remember to install the example dependencies before running the examples. pip install \"blueye.sdk[examples]\" Local documentation Since the drone surface unit (usually) does not have internet access it can be a bit tricky to reference this documentation while developing on the drone. Luckily when you install the SDK from PyPI it includes a pre-built, local copy of this documentation. This documentation can be viewed by executing the following Python snippet: import blueye.sdk blueye . sdk . open_local_documentation ()","title":"Quick Start"},{"location":"docs/quick_start/#installation","text":"The SDK requires Python 3.8 or higher. Since many operating systems do not package the newest version of Python we recommend using pyenv or something similar for configuring multiple python versions on the same system. Pyenv also has the added benefit of managing your virtual environments for you, though you are of course free to use other tools for that as well. The instructions below show the necessary steps to get started with the SDK on a fresh install: Windows Install Python Install Python 3.8 or higher, you can find the latest python versions here . Remember to check the option \"Add Python to path\" when installing. Install virtualenv for managing Python versions (optional) Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. # Upgrade pip version python -m pip install --upgrade pip pip install virtualenv Next, we create a virtual environment cd . \\D esktop mkdir drone_project cd . \\d rone_project # Replace \"C:\\Program Files\\Python310\\python.exe\" with the path # to the python version you want to use in the line below virtualenv blueye_sdk_env -p \"C:\\Program Files\\Python310\\python.exe\" activate the virtual environment . \\b lueye_sdk_env \\S cripts \\a ctivate.bat if you are not allowed to activate the virtual environment, you might have to allow running unsigned scripts, see this link for instructions. Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Mac OS Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl https://pyenv.run | bash pyenv update If you want pyenv to be loaded each time you open a new terminal you can add this to your .zshrc or the equivalent for your terminal export PATH=\"$HOME/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" The Pyenv wiki recommends installing some additional dependencies before building Python. # optional, but recommended: brew install openssl readline sqlite3 xz zlib When running Mojave or higher (10.14+) you will also need to install the additional SDK headers: sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target / Then build Python with pyenv pyenv install 3.10.1 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.10.1 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as. pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Linux These instructions are directed at Ubuntu, but the process should be similar for other distributions. Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash pyenv update Install the needed dependencies for building python 3.10.1 apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\ xz-utils tk-dev libffi-dev liblzma-dev python-openssl Then build python with pyenv pyenv install 3.10.1 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.10.1 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\"","title":"Installation"},{"location":"docs/quick_start/#connect-to-the-drone","text":"To use the SDK your computer must be connected to the drone via the surface unit WiFi. For a how-to on turning on the drone and surface unit you can watch the quick start video .","title":"Connect to the drone"},{"location":"docs/quick_start/#control-the-drone","text":"Most of the functionality is controlled using Python properties and we will illustrate the use of properties by showing how to control the lights: import time from blueye.sdk import Drone # When the Drone object is instantiatied a connection to the drone is established myDrone = Drone () # Setting the lights property to 0.1 (10 %) myDrone . lights = 0.1 time . sleep ( 2 ) # We can also get the current brightness of the lights through the lights property print ( f \"Current light intensity: { myDrone . lights } \" ) myDrone . lights = 0 # Properties can also be used for reading telemetry data from the drone print ( f \"Current depth in meters: { myDrone . depth } \" ) For an overview of the properties that are available for controlling and reading data from the drone, go to the Reference section of the documentation. The valid input ranges and descriptions of the different properties can also be found there. Tip You can explore the properties of the drone interactively using an interactive python interpreter like iPython , install it with: pip install ipython By instantiating a Drone object and using the completion key (normally the tab-key \u21b9 ) you can get a interactive list of the available properties on the drone, it is then easy to try setting and getting the different properties.","title":"Control the drone"},{"location":"docs/quick_start/#watching-the-video-stream","text":"The easiest way to open the RTSP video stream is using VLC media player . Once VLC is downloaded you can start the stream like this, the RTSP URL is: rtsp://192.168.1.101:8554/test For lower latency streaming (on a PC) you can see the instructions on using Gstreamer , or if you just want to watch a low latency stream you can download the Blueye Observer app. ( iOS / Android ) The normal Blueye app can not be used to spectate when controlling the drone from the SDK because it will interfere with the commands sent from the SDK. The Observer app, however, is only a spectator and can be used together with the SDK.","title":"Watching the video stream"},{"location":"docs/quick_start/#explore-the-examples","text":"For further examples on how to use the SDK to control the drone have a look at the motion examples . Remember to install the example dependencies before running the examples. pip install \"blueye.sdk[examples]\"","title":"Explore the examples"},{"location":"docs/quick_start/#local-documentation","text":"Since the drone surface unit (usually) does not have internet access it can be a bit tricky to reference this documentation while developing on the drone. Luckily when you install the SDK from PyPI it includes a pre-built, local copy of this documentation. This documentation can be viewed by executing the following Python snippet: import blueye.sdk blueye . sdk . open_local_documentation ()","title":"Local documentation"},{"location":"docs/telemetry-callback/","text":"Subscribing to a telemetry message The drone publishes all of its telemetry data as protobuf encoded messages transmitted via a ZeroMQ socket. You can find the protobuf message definitions in the Protocol Definitions repository, and the generated python definitions are located in the blueye.protocol repository. Adding a callback To add a callback we need to use the add_msg_callback function, and provide it with a list of telemetry messages types we want it to trigger on, as well as a function handle to call. All available telemetry messages can be found in telemetry.proto Removing a callback A callback is removed with remove_msg_callback using the ID returned when creating the callback. Adjusting the publishing frequency of a telemetry message By using the set_msg_publish_frequency function we can alter how often the drone should publish the specified telemetry message. The valid frequency range is 0 to 100 Hz. Example The following example illustrates how can use a callback to print the depth reported by the drone. \"\"\"print_depth.py This example program demonstrates how one can add a callback function to a telemetry message, as well as how to adjust the frequency of that telemetry message, and how to remove the callback. \"\"\" import time import blueye.protocol as bp from blueye.sdk import Drone def callback_depth ( msg_type : str , msg : bp . DepthTel ): \"\"\"Callback for the depth telemetry message This function is called once for every DepthTel message received by the telemetry watcher \"\"\" print ( f \"Got a { msg_type } message with depth: { msg . depth . value : .3f } \" ) if __name__ == \"__main__\" : # Instantiate a drone object my_drone = Drone () # Add a callback for the DepthTel message, storing the ID for later use callback_id = my_drone . telemetry . add_msg_callback ([ bp . DepthTel ], callback_depth ) # Adjust the publishing frequency to 5 Hz my_drone . telemetry . set_msg_publish_frequency ( bp . DepthTel , 5 ) # Callback is triggered by a separate thread while we sleep here time . sleep ( 5 ) # Remove the callback using the ID we stored when it was created (not really necessary here # since the my_drone object goes out of scope immediately afterwards) my_drone . telemetry . remove_msg_callback ( callback_id )","title":"Subscribing to a telemetry message"},{"location":"docs/telemetry-callback/#subscribing-to-a-telemetry-message","text":"The drone publishes all of its telemetry data as protobuf encoded messages transmitted via a ZeroMQ socket. You can find the protobuf message definitions in the Protocol Definitions repository, and the generated python definitions are located in the blueye.protocol repository.","title":"Subscribing to a telemetry message"},{"location":"docs/telemetry-callback/#adding-a-callback","text":"To add a callback we need to use the add_msg_callback function, and provide it with a list of telemetry messages types we want it to trigger on, as well as a function handle to call. All available telemetry messages can be found in telemetry.proto","title":"Adding a callback"},{"location":"docs/telemetry-callback/#removing-a-callback","text":"A callback is removed with remove_msg_callback using the ID returned when creating the callback.","title":"Removing a callback"},{"location":"docs/telemetry-callback/#adjusting-the-publishing-frequency-of-a-telemetry-message","text":"By using the set_msg_publish_frequency function we can alter how often the drone should publish the specified telemetry message. The valid frequency range is 0 to 100 Hz.","title":"Adjusting the publishing frequency of a telemetry message"},{"location":"docs/telemetry-callback/#example","text":"The following example illustrates how can use a callback to print the depth reported by the drone. \"\"\"print_depth.py This example program demonstrates how one can add a callback function to a telemetry message, as well as how to adjust the frequency of that telemetry message, and how to remove the callback. \"\"\" import time import blueye.protocol as bp from blueye.sdk import Drone def callback_depth ( msg_type : str , msg : bp . DepthTel ): \"\"\"Callback for the depth telemetry message This function is called once for every DepthTel message received by the telemetry watcher \"\"\" print ( f \"Got a { msg_type } message with depth: { msg . depth . value : .3f } \" ) if __name__ == \"__main__\" : # Instantiate a drone object my_drone = Drone () # Add a callback for the DepthTel message, storing the ID for later use callback_id = my_drone . telemetry . add_msg_callback ([ bp . DepthTel ], callback_depth ) # Adjust the publishing frequency to 5 Hz my_drone . telemetry . set_msg_publish_frequency ( bp . DepthTel , 5 ) # Callback is triggered by a separate thread while we sleep here time . sleep ( 5 ) # Remove the callback using the ID we stored when it was created (not really necessary here # since the my_drone object goes out of scope immediately afterwards) my_drone . telemetry . remove_msg_callback ( callback_id )","title":"Example"},{"location":"docs/logs/listing-and-downloading/","text":"Logs from the drone When the drone is powered on a new comma-separated-value file, where it stores telemetry data such as depth, temperature, and more, is created. The drone will log data as long as it is powered on. These files can be downloaded to your local system where you can plot them or use them however you see fit. Listing the log files If your drone has completed 5 dives and you do from blueye.sdk import Drone myDrone = Drone () print ( myDrone . logs ) you should see something like the following lines be printed Name Time Max depth Size ea9add4d40f69d4-00000.csv 24. Oct 2018 09:40 21.05 m 6.3 MiB ea9add4d40f69d4-00001.csv 25. Oct 2018 10:29 21.06 m 879.2 KiB ea9add4d40f69d4-00002.csv 31. Oct 2018 10:05 60.69 m 8.5 MiB ea9add4d40f69d4-00003.csv 31. Oct 2018 12:13 41.68 m 8.4 MiB ea9add4d40f69d4-00004.csv 02. Nov 2018 08:59 52.52 m 7.8 MiB The first part of the filename (the part before the -) is the unique ID of your drone and second part is the dive number. In addition we see the start time of the dive, the maximum depth reached, as well as the size of the log file. You might notice that there can be more log files listed then the amount of dives you have done. This is due to the fact that the drone creates a new log file whenever it is turned on, regardless of whether you actually took the drone for a dive. To easier separate out the log files that result from actual dives you can filter out all the dives with a max depth below some threshold. The Blueye app does this, filtering out all log files with a max depth below 20 cm. Downloading a log file to your computer When you want to download a log file all you have to do is to call the download() method on the desired log and the file will be downloaded to your current folder. The download() method takes two optional parameters, output_path and output_name . These specify, respectively, which folder the log is downloaded to and what name it's stored with. Example: Downloading multiple log files Downloading multiple log files is solved by a simple Python for-loop. The example below shows how one can download the last 3 logs to the current folder: from blueye.sdk import Drone myDrone = Drone () for log in myDrone . logs [: - 3 ]: log . download () Example: Adding a prefix to log names The example code below shows how one can add a simple prefix to all log files when downloading: from blueye.sdk import Drone myDrone = Drone () prefix = \"pre_\" for log in myDrone . logs : log . download ( output_name = prefix + log . name )","title":"Listing and downloading log files"},{"location":"docs/logs/listing-and-downloading/#logs-from-the-drone","text":"When the drone is powered on a new comma-separated-value file, where it stores telemetry data such as depth, temperature, and more, is created. The drone will log data as long as it is powered on. These files can be downloaded to your local system where you can plot them or use them however you see fit.","title":"Logs from the drone"},{"location":"docs/logs/listing-and-downloading/#listing-the-log-files","text":"If your drone has completed 5 dives and you do from blueye.sdk import Drone myDrone = Drone () print ( myDrone . logs ) you should see something like the following lines be printed Name Time Max depth Size ea9add4d40f69d4-00000.csv 24. Oct 2018 09:40 21.05 m 6.3 MiB ea9add4d40f69d4-00001.csv 25. Oct 2018 10:29 21.06 m 879.2 KiB ea9add4d40f69d4-00002.csv 31. Oct 2018 10:05 60.69 m 8.5 MiB ea9add4d40f69d4-00003.csv 31. Oct 2018 12:13 41.68 m 8.4 MiB ea9add4d40f69d4-00004.csv 02. Nov 2018 08:59 52.52 m 7.8 MiB The first part of the filename (the part before the -) is the unique ID of your drone and second part is the dive number. In addition we see the start time of the dive, the maximum depth reached, as well as the size of the log file. You might notice that there can be more log files listed then the amount of dives you have done. This is due to the fact that the drone creates a new log file whenever it is turned on, regardless of whether you actually took the drone for a dive. To easier separate out the log files that result from actual dives you can filter out all the dives with a max depth below some threshold. The Blueye app does this, filtering out all log files with a max depth below 20 cm.","title":"Listing the log files"},{"location":"docs/logs/listing-and-downloading/#downloading-a-log-file-to-your-computer","text":"When you want to download a log file all you have to do is to call the download() method on the desired log and the file will be downloaded to your current folder. The download() method takes two optional parameters, output_path and output_name . These specify, respectively, which folder the log is downloaded to and what name it's stored with.","title":"Downloading a log file to your computer"},{"location":"docs/logs/listing-and-downloading/#example-downloading-multiple-log-files","text":"Downloading multiple log files is solved by a simple Python for-loop. The example below shows how one can download the last 3 logs to the current folder: from blueye.sdk import Drone myDrone = Drone () for log in myDrone . logs [: - 3 ]: log . download ()","title":"Example: Downloading multiple log files"},{"location":"docs/logs/listing-and-downloading/#example-adding-a-prefix-to-log-names","text":"The example code below shows how one can add a simple prefix to all log files when downloading: from blueye.sdk import Drone myDrone = Drone () prefix = \"pre_\" for log in myDrone . logs : log . download ( output_name = prefix + log . name )","title":"Example: Adding a prefix to log names"},{"location":"docs/logs/log-file-format/","text":"Log file format The log files from the Blueye drones are in essence a recording of the data that is published over UDP stored as a comma-separated-value (CSV) file. The rest of this page documents the most useful fields of the log files. The column indices listed are zero-based. If you feel that some fields need more documentation, feel free to open an issue on Github , and we'll happily supply the requested information. Time Column Type Unit Description 2 Integer Milliseconds The elapsed time since the start of the log 3 Float Unix timestamp Global time Position The position is based on the user's phone's GPS at the start of the dive. Column Type Unit Description 6 Float Degrees Latitude 7 Float Degrees Longitude File storage Column Type Unit Description 8 Integer Bytes Total file storage on the drone 9 Integer Bytes Available free space Temperature Note: All temperatures are in \"deci-degrees Celsius\", ie. to get \u00b0C you need to divide the value by 10. Column Type Unit Description 11 Integer Deci-Celsius Bottom canister temperature 12 Integer Deci-Celsius Water temperature 13 Integer Deci-Celsius Top canister temperature 14 Integer Deci-Celsius CPU temperature Internal humidity Note: The unit is in deci-percent (ie. divide by 10 to get percent). Column Type Unit Description 15 Integer Deci-percent Humidity in the top canister. 16 Integer Deci-percent Humidity in the bottom canister. Lights Column Type Unit Description 17 Integer - State of the on-board light. Range is 0 to 255. Depth Column Type Unit Description 22 Integer Milli-meters Depth below water surface. Positive values are below the surface, negative are above. Control force Control force is the force exerted on the drone by the control system. Column Type Unit Description 29 Float Newton Force in the surge direction. 30 Float Newton Force in the sway direction. 31 Float Newton Force in the heave direction. 32 Float Newton-meters Moment in the yaw direction. Orientation (pose) Column Type Unit Description 32 Float Degrees Roll angle. Range from -180\u00b0 - 180\u00b0 33 Float Degrees Pitch angle. Range from -180\u00b0 - 180\u00b0 34 Float Degrees Yaw angle. Range from -180\u00b0 - 180\u00b0 Battery Column Type Unit Description 38 Integer Milli-volts Battery voltage 39 Integer Milli-amperes Battery current. Negative values are drained from the battery, positive are charged. 41 Integer Percent Relative state of charge. Range from 0 - 100 %","title":"Log file format"},{"location":"docs/logs/log-file-format/#log-file-format","text":"The log files from the Blueye drones are in essence a recording of the data that is published over UDP stored as a comma-separated-value (CSV) file. The rest of this page documents the most useful fields of the log files. The column indices listed are zero-based. If you feel that some fields need more documentation, feel free to open an issue on Github , and we'll happily supply the requested information.","title":"Log file format"},{"location":"docs/logs/log-file-format/#time","text":"Column Type Unit Description 2 Integer Milliseconds The elapsed time since the start of the log 3 Float Unix timestamp Global time","title":"Time"},{"location":"docs/logs/log-file-format/#position","text":"The position is based on the user's phone's GPS at the start of the dive. Column Type Unit Description 6 Float Degrees Latitude 7 Float Degrees Longitude","title":"Position"},{"location":"docs/logs/log-file-format/#file-storage","text":"Column Type Unit Description 8 Integer Bytes Total file storage on the drone 9 Integer Bytes Available free space","title":"File storage"},{"location":"docs/logs/log-file-format/#temperature","text":"Note: All temperatures are in \"deci-degrees Celsius\", ie. to get \u00b0C you need to divide the value by 10. Column Type Unit Description 11 Integer Deci-Celsius Bottom canister temperature 12 Integer Deci-Celsius Water temperature 13 Integer Deci-Celsius Top canister temperature 14 Integer Deci-Celsius CPU temperature","title":"Temperature"},{"location":"docs/logs/log-file-format/#internal-humidity","text":"Note: The unit is in deci-percent (ie. divide by 10 to get percent). Column Type Unit Description 15 Integer Deci-percent Humidity in the top canister. 16 Integer Deci-percent Humidity in the bottom canister.","title":"Internal humidity"},{"location":"docs/logs/log-file-format/#lights","text":"Column Type Unit Description 17 Integer - State of the on-board light. Range is 0 to 255.","title":"Lights"},{"location":"docs/logs/log-file-format/#depth","text":"Column Type Unit Description 22 Integer Milli-meters Depth below water surface. Positive values are below the surface, negative are above.","title":"Depth"},{"location":"docs/logs/log-file-format/#control-force","text":"Control force is the force exerted on the drone by the control system. Column Type Unit Description 29 Float Newton Force in the surge direction. 30 Float Newton Force in the sway direction. 31 Float Newton Force in the heave direction. 32 Float Newton-meters Moment in the yaw direction.","title":"Control force"},{"location":"docs/logs/log-file-format/#orientation-pose","text":"Column Type Unit Description 32 Float Degrees Roll angle. Range from -180\u00b0 - 180\u00b0 33 Float Degrees Pitch angle. Range from -180\u00b0 - 180\u00b0 34 Float Degrees Yaw angle. Range from -180\u00b0 - 180\u00b0","title":"Orientation (pose)"},{"location":"docs/logs/log-file-format/#battery","text":"Column Type Unit Description 38 Integer Milli-volts Battery voltage 39 Integer Milli-amperes Battery current. Negative values are drained from the battery, positive are charged. 41 Integer Percent Relative state of charge. Range from 0 - 100 %","title":"Battery"},{"location":"docs/logs/plotting/","text":"Plotting This example shows how one can pull a log file from the drone and use pandas and matplotlib to plot it. We'll start by downloading a log file from the drone from blueye.sdk import Drone myDrone = Drone () myDrone . logs [ 0 ] . download ( output_name = \"log0.csv\" ) We can now read the csv-file into a pandas object for easy manipulation import pandas divelog = pandas . read_csv ( \"log0.csv\" ) and then we'll convert the unix timestamp in rt_clock into a more readable format: divelog [ \"rt_clock\" ] = pandas . to_datetime ( divelog [ \"rt_clock\" ], unit = \"s\" ) Next we will plot depth vs time with matplotlib: import matplotlib.pyplot as plt # Instantiate our figure and axes to plot on figure , axes = plt . subplots () x = divelog [ \"rt_clock\" ] y = divelog [ \"depth\" ] / 1000 # Dividing by 1000 to get depth in meters # Plot the depth values against time axes . plot ( x , y , label = \"depth\" ) # Set title, labels, and legend plt . title ( \"Depth chart\" ) plt . xlabel ( \"Time\" ) plt . ylabel ( \"Depth [m]\" ) plt . legend () # Save the figure figure . savefig ( \"depth_plot.svg\" ) This should yield us a plot that looks something like this: See the matplotlib documentation for more ways to plot your data.","title":"Plotting log files"},{"location":"docs/logs/plotting/#plotting","text":"This example shows how one can pull a log file from the drone and use pandas and matplotlib to plot it. We'll start by downloading a log file from the drone from blueye.sdk import Drone myDrone = Drone () myDrone . logs [ 0 ] . download ( output_name = \"log0.csv\" ) We can now read the csv-file into a pandas object for easy manipulation import pandas divelog = pandas . read_csv ( \"log0.csv\" ) and then we'll convert the unix timestamp in rt_clock into a more readable format: divelog [ \"rt_clock\" ] = pandas . to_datetime ( divelog [ \"rt_clock\" ], unit = \"s\" ) Next we will plot depth vs time with matplotlib: import matplotlib.pyplot as plt # Instantiate our figure and axes to plot on figure , axes = plt . subplots () x = divelog [ \"rt_clock\" ] y = divelog [ \"depth\" ] / 1000 # Dividing by 1000 to get depth in meters # Plot the depth values against time axes . plot ( x , y , label = \"depth\" ) # Set title, labels, and legend plt . title ( \"Depth chart\" ) plt . xlabel ( \"Time\" ) plt . ylabel ( \"Depth [m]\" ) plt . legend () # Save the figure figure . savefig ( \"depth_plot.svg\" ) This should yield us a plot that looks something like this: See the matplotlib documentation for more ways to plot your data.","title":"Plotting"},{"location":"docs/logs/runtime-logs/","text":"Log statements from the blueye.sdk The blueye.sdk package uses the standard Python logging module to log information about the SDK's operation. The log statements are useful for debugging and troubleshooting, and can be used to get a better understanding of what is happening inside the SDK. Note : These logs must not be confused with the divelogs that are generated and stored on the drone. See Listing and downloading logfiles for instructions on how to get the divelogs. Events with severity WARNING or greater are printed to sys.stderr by default, but can be configured to be written to a file or sent to a remote server. See the Python logging documentation for more information about how to configure the logging module. Enabling logging with lower severity By default, the events with severity lower than WARNING are muted. To enable them, you need to configure the logger to capture the logs. Here's an example of how to enable debug logs: import logging import blueye.sdk def enable_debug_logs (): # Set the logger configuration logger = logging . getLogger ( blueye . sdk . __name__ ) logger . setLevel ( logging . DEBUG ) # Define the log handler handler = logging . StreamHandler () handler . setLevel ( logging . DEBUG ) # Define the log format formatter = logging . Formatter ( ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' ) handler . setFormatter ( formatter ) # Add the log handler to the logger logger . addHandler ( handler ) In the example above, we import the necessary modules and create a function enable_runtime_logs() to enable the runtime logs. We configure the logger to capture logs with the logging.getLogger(blueye.sdk.__name__) statement and set the log level to DEBUG to capture all logs. We also define a log handler to determine where the logs should be outputted. In this example, we use a logging.StreamHandler() to print the logs to the console. You can customize the log handler based on your requirements, such as writing logs to a file or sending them to a remote server. Finally, we set the log format using logging.Formatter() and add the log handler to the logger using logger.addHandler(handler) . Disabling Logging If you want to completely disable logging and prevent any logs from being captured, you can use a NullHandler . Here's an example: import logging import blueye.sdk def disable_logging (): # Disable all logging logger = logging . getLogger ( blueye . sdk . __name__ ) logger . addHandler ( logging . NullHandler ()) In the example above, we define a function disable_logging() that sets a NullHandler to the logger. The NullHandler is a special handler that essentially discards all log records, effectively disabling logging.","title":"Runtime logs"},{"location":"docs/logs/runtime-logs/#log-statements-from-the-blueyesdk","text":"The blueye.sdk package uses the standard Python logging module to log information about the SDK's operation. The log statements are useful for debugging and troubleshooting, and can be used to get a better understanding of what is happening inside the SDK. Note : These logs must not be confused with the divelogs that are generated and stored on the drone. See Listing and downloading logfiles for instructions on how to get the divelogs. Events with severity WARNING or greater are printed to sys.stderr by default, but can be configured to be written to a file or sent to a remote server. See the Python logging documentation for more information about how to configure the logging module.","title":"Log statements from the blueye.sdk"},{"location":"docs/logs/runtime-logs/#enabling-logging-with-lower-severity","text":"By default, the events with severity lower than WARNING are muted. To enable them, you need to configure the logger to capture the logs. Here's an example of how to enable debug logs: import logging import blueye.sdk def enable_debug_logs (): # Set the logger configuration logger = logging . getLogger ( blueye . sdk . __name__ ) logger . setLevel ( logging . DEBUG ) # Define the log handler handler = logging . StreamHandler () handler . setLevel ( logging . DEBUG ) # Define the log format formatter = logging . Formatter ( ' %(asctime)s - %(name)s - %(levelname)s - %(message)s ' ) handler . setFormatter ( formatter ) # Add the log handler to the logger logger . addHandler ( handler ) In the example above, we import the necessary modules and create a function enable_runtime_logs() to enable the runtime logs. We configure the logger to capture logs with the logging.getLogger(blueye.sdk.__name__) statement and set the log level to DEBUG to capture all logs. We also define a log handler to determine where the logs should be outputted. In this example, we use a logging.StreamHandler() to print the logs to the console. You can customize the log handler based on your requirements, such as writing logs to a file or sending them to a remote server. Finally, we set the log format using logging.Formatter() and add the log handler to the logger using logger.addHandler(handler) .","title":"Enabling logging with lower severity"},{"location":"docs/logs/runtime-logs/#disabling-logging","text":"If you want to completely disable logging and prevent any logs from being captured, you can use a NullHandler . Here's an example: import logging import blueye.sdk def disable_logging (): # Disable all logging logger = logging . getLogger ( blueye . sdk . __name__ ) logger . addHandler ( logging . NullHandler ()) In the example above, we define a function disable_logging() that sets a NullHandler to the logger. The NullHandler is a special handler that essentially discards all log records, effectively disabling logging.","title":"Disabling Logging"},{"location":"docs/movement/from-the-CLI/","text":"Controlling from the Command Line Interface This is a super simple example showing how you make the drone move from the command line interface: import time from blueye.sdk import Drone myDrone = Drone () myDrone . motion . surge = 0.4 time . sleep ( 1 ) myDrone . motion . surge = 0","title":"Control from the CLI"},{"location":"docs/movement/from-the-CLI/#controlling-from-the-command-line-interface","text":"This is a super simple example showing how you make the drone move from the command line interface: import time from blueye.sdk import Drone myDrone = Drone () myDrone . motion . surge = 0.4 time . sleep ( 1 ) myDrone . motion . surge = 0","title":"Controlling from the Command Line Interface"},{"location":"docs/movement/with-a-gamepad/","text":"Controlling the drone from a gamepad To run the example remember to first install the optional dependencies needed for running the examples pip install \"blueye.sdk[examples]\" The example below illustrates how one could use an Xbox controller and the SDK to control the drone. The inputs library supports many other gamepads, so using a different controller should be as simple as looking up the event codes for the buttons/axes and mapping them to the functions you want. import inputs from blueye.sdk import Drone class JoystickHandler : \"\"\"Maps drone functions to joystick events\"\"\" def __init__ ( self , drone ): self . drone = drone self . event_to_function_map = { \"BTN_NORTH\" : self . handle_x_button , \"BTN_WEST\" : self . handle_y_button , \"BTN_EAST\" : self . handle_b_button , \"BTN_SOUTH\" : self . handle_a_button , \"ABS_X\" : self . handle_left_x_axis , \"ABS_Y\" : self . handle_left_y_axis , \"ABS_Z\" : self . handle_left_trigger , \"ABS_RX\" : self . handle_right_x_axis , \"ABS_RY\" : self . handle_right_y_axis , \"ABS_RZ\" : self . handle_right_trigger , } def handle_x_button ( self , value ): \"\"\"Starts/stops the video recording\"\"\" self . drone . camera . is_recording = value def handle_y_button ( self , value ): \"\"\"Turns lights on or off\"\"\" if value : if self . drone . lights > 0 : self . drone . lights = 0 else : self . drone . lights = 0.1 def handle_b_button ( self , value ): \"\"\"Toggles autoheading\"\"\" if value : self . drone . motion . auto_heading_active = not self . drone . motion . auto_heading_active def handle_a_button ( self , value ): \"\"\"Toggles autodepth\"\"\" if value : self . drone . motion . auto_depth_active = not self . drone . motion . auto_depth_active def filter_and_normalize ( self , value , lower = 5000 , upper = 32768 ): \"\"\"Normalizing the joystick axis range from (default) -32768<->32678 to -1<->1 The sticks also tend to not stop at 0 when you let them go but rather some low value, so we'll filter those out as well. \"\"\" if - lower < value < lower : return 0 elif lower <= value <= upper : return ( value - lower ) / ( upper - lower ) elif - upper <= value <= - lower : return ( value + lower ) / ( upper - lower ) else : return 0 def handle_left_x_axis ( self , value ): self . drone . motion . yaw = self . filter_and_normalize ( value ) def handle_left_y_axis ( self , value ): self . drone . motion . heave = self . filter_and_normalize ( value ) def handle_right_x_axis ( self , value ): self . drone . motion . sway = self . filter_and_normalize ( value ) def handle_right_y_axis ( self , value ): self . drone . motion . surge = - self . filter_and_normalize ( value ) def handle_left_trigger ( self , value ): self . drone . motion . slow = self . filter_and_normalize ( value , lower = 0 , upper = 255 ) def handle_right_trigger ( self , value ): self . drone . motion . boost = self . filter_and_normalize ( value , lower = 0 , upper = 255 ) if __name__ == \"__main__\" : try : myDrone = Drone () handler = JoystickHandler ( myDrone ) while True : events = inputs . get_gamepad () for event in events : if event . code in handler . event_to_function_map : handler . event_to_function_map [ event . code ]( event . state ) except KeyboardInterrupt : pass","title":"Control with a gamepad"},{"location":"docs/movement/with-a-gamepad/#controlling-the-drone-from-a-gamepad","text":"To run the example remember to first install the optional dependencies needed for running the examples pip install \"blueye.sdk[examples]\" The example below illustrates how one could use an Xbox controller and the SDK to control the drone. The inputs library supports many other gamepads, so using a different controller should be as simple as looking up the event codes for the buttons/axes and mapping them to the functions you want. import inputs from blueye.sdk import Drone class JoystickHandler : \"\"\"Maps drone functions to joystick events\"\"\" def __init__ ( self , drone ): self . drone = drone self . event_to_function_map = { \"BTN_NORTH\" : self . handle_x_button , \"BTN_WEST\" : self . handle_y_button , \"BTN_EAST\" : self . handle_b_button , \"BTN_SOUTH\" : self . handle_a_button , \"ABS_X\" : self . handle_left_x_axis , \"ABS_Y\" : self . handle_left_y_axis , \"ABS_Z\" : self . handle_left_trigger , \"ABS_RX\" : self . handle_right_x_axis , \"ABS_RY\" : self . handle_right_y_axis , \"ABS_RZ\" : self . handle_right_trigger , } def handle_x_button ( self , value ): \"\"\"Starts/stops the video recording\"\"\" self . drone . camera . is_recording = value def handle_y_button ( self , value ): \"\"\"Turns lights on or off\"\"\" if value : if self . drone . lights > 0 : self . drone . lights = 0 else : self . drone . lights = 0.1 def handle_b_button ( self , value ): \"\"\"Toggles autoheading\"\"\" if value : self . drone . motion . auto_heading_active = not self . drone . motion . auto_heading_active def handle_a_button ( self , value ): \"\"\"Toggles autodepth\"\"\" if value : self . drone . motion . auto_depth_active = not self . drone . motion . auto_depth_active def filter_and_normalize ( self , value , lower = 5000 , upper = 32768 ): \"\"\"Normalizing the joystick axis range from (default) -32768<->32678 to -1<->1 The sticks also tend to not stop at 0 when you let them go but rather some low value, so we'll filter those out as well. \"\"\" if - lower < value < lower : return 0 elif lower <= value <= upper : return ( value - lower ) / ( upper - lower ) elif - upper <= value <= - lower : return ( value + lower ) / ( upper - lower ) else : return 0 def handle_left_x_axis ( self , value ): self . drone . motion . yaw = self . filter_and_normalize ( value ) def handle_left_y_axis ( self , value ): self . drone . motion . heave = self . filter_and_normalize ( value ) def handle_right_x_axis ( self , value ): self . drone . motion . sway = self . filter_and_normalize ( value ) def handle_right_y_axis ( self , value ): self . drone . motion . surge = - self . filter_and_normalize ( value ) def handle_left_trigger ( self , value ): self . drone . motion . slow = self . filter_and_normalize ( value , lower = 0 , upper = 255 ) def handle_right_trigger ( self , value ): self . drone . motion . boost = self . filter_and_normalize ( value , lower = 0 , upper = 255 ) if __name__ == \"__main__\" : try : myDrone = Drone () handler = JoystickHandler ( myDrone ) while True : events = inputs . get_gamepad () for event in events : if event . code in handler . event_to_function_map : handler . event_to_function_map [ event . code ]( event . state ) except KeyboardInterrupt : pass","title":"Controlling the drone from a gamepad"},{"location":"docs/video/downloading/","text":"Downloading videos and images Videos and images can easiest be downloaded through the mobile app, or by using the Blueye file transfer desktop application for Windows, Mac OS and Linux. If one wants a more control over the download process, all files are listable through any client that supports WebDAV . The server is available on the drone (default ip: 192.168.1.101 ) and port 5050 . For example using a Python WebDAV client we could do the following to list the files on drone: import webdav3.client as wc # Define the options for connecting options = { 'webdav_hostname' : \"http://192.168.1.101:5050\" } # Instantiate the connection client = wc . Client ( options ) # List the avaiable files client . list () Understanding the file name formats An example output from listing available files could be: 'video_BYEDP000105_2019-08-13_103035.jpg' 'video_BYEDP000105_2019-08-13_103035.mp4' 'picture_BYEDP000105_2019-09-27_074152.431.jpg' , The format of the file names are described below. Video files For each video recorded on the drone two files will be created, a .mp4 file with the actual video, and a .jpg file with a thumbnail image from the video file. Other than the file extension the file names will be identical. An example of a video + thumbnail pair could be: 'video_BYEDP000105_2019-08-13_103035.jpg' 'video_BYEDP000105_2019-08-13_103035.mp4' The file names break down to: File Type Prefix Drone Serial Number Timestamp (yyyy-MM-dd_hhmmss) File Extension video BYEDP000105 2019-08-13_103035 .mp4 video BYEDP000105 2019-08-13_103035 .jpg Image files Image files are images captured with the still image function. The file name for image files follow the same format as the video files, but the time stamp is extended with milliseconds to differentiate still images captured within the same second. An example still image file could be: 'picture_BYEDP000105_2019-09-27_074152.431.jpg' , The file name breaks down to: File Type Prefix Drone Serial Number Timestamp (yyyy-MM-dd_hhmmss.SSS) File Extension picture BYEDP000105 2019-09-27_074152.431 .jpg","title":"Downloading videos and images"},{"location":"docs/video/downloading/#downloading-videos-and-images","text":"Videos and images can easiest be downloaded through the mobile app, or by using the Blueye file transfer desktop application for Windows, Mac OS and Linux. If one wants a more control over the download process, all files are listable through any client that supports WebDAV . The server is available on the drone (default ip: 192.168.1.101 ) and port 5050 . For example using a Python WebDAV client we could do the following to list the files on drone: import webdav3.client as wc # Define the options for connecting options = { 'webdav_hostname' : \"http://192.168.1.101:5050\" } # Instantiate the connection client = wc . Client ( options ) # List the avaiable files client . list ()","title":"Downloading videos and images"},{"location":"docs/video/downloading/#understanding-the-file-name-formats","text":"An example output from listing available files could be: 'video_BYEDP000105_2019-08-13_103035.jpg' 'video_BYEDP000105_2019-08-13_103035.mp4' 'picture_BYEDP000105_2019-09-27_074152.431.jpg' , The format of the file names are described below.","title":"Understanding the file name formats"},{"location":"docs/video/downloading/#video-files","text":"For each video recorded on the drone two files will be created, a .mp4 file with the actual video, and a .jpg file with a thumbnail image from the video file. Other than the file extension the file names will be identical. An example of a video + thumbnail pair could be: 'video_BYEDP000105_2019-08-13_103035.jpg' 'video_BYEDP000105_2019-08-13_103035.mp4' The file names break down to: File Type Prefix Drone Serial Number Timestamp (yyyy-MM-dd_hhmmss) File Extension video BYEDP000105 2019-08-13_103035 .mp4 video BYEDP000105 2019-08-13_103035 .jpg","title":"Video files"},{"location":"docs/video/downloading/#image-files","text":"Image files are images captured with the still image function. The file name for image files follow the same format as the video files, but the time stamp is extended with milliseconds to differentiate still images captured within the same second. An example still image file could be: 'picture_BYEDP000105_2019-09-27_074152.431.jpg' , The file name breaks down to: File Type Prefix Drone Serial Number Timestamp (yyyy-MM-dd_hhmmss.SSS) File Extension picture BYEDP000105 2019-09-27_074152.431 .jpg","title":"Image files"},{"location":"docs/video/gstreamer-for-video-streaming/","text":"GStreamer is the lowest latency alternative for streaming video from the drone to your laptop. Installing GStreamer To run the streaming pipeline in the next section you will need a runtime installation of GStreamer. The instructions below show the basic steps for installing GStreamer on the most common operating systems. You can find more in depth instruction for your specific operating system in the GStreamer docs . Windows On Windows the basic installation steps are: Download the relevant installer for your computer from https://gstreamer.freedesktop.org/download . Using the latest stable relase should be fine, at the time of writing that is 1.16.1 runtime installer Run the installer. When asked to choose a setup type choose to do a complete installation. This is because some plugins that are needed for the basic pipeline later are not included if you choose to install the typical setup To run GStreamer commands form the terminal, GStreamer must be added to the PATH environment variable. This can be done from the advanced system settings. Add %GSTREAMER_1_0_ROOT_X86_64%\\bin to path. Alternatively you can choose to run gst-launch-1.0.exe from the folder it is installed in, typically C:\\gstreamer\\1.0\\x86_64\\bin Mac OS On Mac OS GStreamer and its plugins can be installed using brew brew install gstreamer gst-plugins-base gst-plugins-good gst-plugins-bad gst-plugins-ugly gst-libav Linux On Ubuntu and Debian GStreamer and its plugins can be installed using apt. apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc \\ gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa You can test the installation by trying the basic pipeline from the next section when connected to a drone. Or with gst-launch-1.0 videotestsrc ! autovideosink Basic streaming pipeline After installing you can run this pipeline in your terminal: Windows gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 ! rtph264depay ! avdec_h264 ! videoconvert ! fpsdisplaysink sync = false Linux and macOS gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 \\ ! rtph264depay \\ ! avdec_h264 \\ ! videoconvert \\ ! fpsdisplaysink sync = false Running the pipeline will open a window with the camera stream and information about packet loss and camera frame rate. External camera streaming pipeline If you have a X3 drone with an external camera connected you can use the following pipeline: Windows gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8555/guestport_cam latency = 0 ! rtph264depay ! avdec_h264 ! videoconvert ! autovideosink sync = false Linux and macOS gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8555/guestport_cam latency = 0 \\ ! rtph264depay \\ ! avdec_h264 \\ ! videoconvert \\ ! autovideosink sync = false Running the pipeline will open a window with the external camera stream.","title":"GStreamer for video streaming"},{"location":"docs/video/gstreamer-for-video-streaming/#installing-gstreamer","text":"To run the streaming pipeline in the next section you will need a runtime installation of GStreamer. The instructions below show the basic steps for installing GStreamer on the most common operating systems. You can find more in depth instruction for your specific operating system in the GStreamer docs . Windows On Windows the basic installation steps are: Download the relevant installer for your computer from https://gstreamer.freedesktop.org/download . Using the latest stable relase should be fine, at the time of writing that is 1.16.1 runtime installer Run the installer. When asked to choose a setup type choose to do a complete installation. This is because some plugins that are needed for the basic pipeline later are not included if you choose to install the typical setup To run GStreamer commands form the terminal, GStreamer must be added to the PATH environment variable. This can be done from the advanced system settings. Add %GSTREAMER_1_0_ROOT_X86_64%\\bin to path. Alternatively you can choose to run gst-launch-1.0.exe from the folder it is installed in, typically C:\\gstreamer\\1.0\\x86_64\\bin Mac OS On Mac OS GStreamer and its plugins can be installed using brew brew install gstreamer gst-plugins-base gst-plugins-good gst-plugins-bad gst-plugins-ugly gst-libav Linux On Ubuntu and Debian GStreamer and its plugins can be installed using apt. apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc \\ gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa You can test the installation by trying the basic pipeline from the next section when connected to a drone. Or with gst-launch-1.0 videotestsrc ! autovideosink","title":"Installing GStreamer"},{"location":"docs/video/gstreamer-for-video-streaming/#basic-streaming-pipeline","text":"After installing you can run this pipeline in your terminal: Windows gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 ! rtph264depay ! avdec_h264 ! videoconvert ! fpsdisplaysink sync = false Linux and macOS gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 \\ ! rtph264depay \\ ! avdec_h264 \\ ! videoconvert \\ ! fpsdisplaysink sync = false Running the pipeline will open a window with the camera stream and information about packet loss and camera frame rate.","title":"Basic streaming pipeline"},{"location":"docs/video/gstreamer-for-video-streaming/#external-camera-streaming-pipeline","text":"If you have a X3 drone with an external camera connected you can use the following pipeline: Windows gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8555/guestport_cam latency = 0 ! rtph264depay ! avdec_h264 ! videoconvert ! autovideosink sync = false Linux and macOS gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8555/guestport_cam latency = 0 \\ ! rtph264depay \\ ! avdec_h264 \\ ! videoconvert \\ ! autovideosink sync = false Running the pipeline will open a window with the external camera stream.","title":"External camera streaming pipeline"},{"location":"reference/blueye/sdk/","text":"Module blueye.sdk View Source from .constants import WaterDensities from .drone import Drone from .utils import open_local_documentation Sub-modules blueye.sdk.battery blueye.sdk.camera blueye.sdk.connection blueye.sdk.constants blueye.sdk.drone blueye.sdk.logs blueye.sdk.motion blueye.sdk.utils","title":"Index"},{"location":"reference/blueye/sdk/#module-blueyesdk","text":"View Source from .constants import WaterDensities from .drone import Drone from .utils import open_local_documentation","title":"Module blueye.sdk"},{"location":"reference/blueye/sdk/#sub-modules","text":"blueye.sdk.battery blueye.sdk.camera blueye.sdk.connection blueye.sdk.constants blueye.sdk.drone blueye.sdk.logs blueye.sdk.motion blueye.sdk.utils","title":"Sub-modules"},{"location":"reference/blueye/sdk/battery/","text":"Module blueye.sdk.battery View Source from __future__ import annotations from typing import TYPE_CHECKING, Optional import blueye.protocol # Necessary to avoid cyclic imports if TYPE_CHECKING: from .drone import Drone class Battery: def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone @property def state_of_charge(self) -> Optional[float]: \"\"\"Get the battery state of charge *Returns*: * Current state of charge of the drone battery (0..1) \"\"\" battery_tel = self._parent_drone.telemetry.get(blueye.protocol.BatteryTel) if battery_tel is not None: return battery_tel.battery.level else: return None Variables TYPE_CHECKING Classes Battery class Battery ( parent_drone : 'Drone' ) View Source class Battery: def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone @property def state_of_charge(self) -> Optional[float]: \"\"\"Get the battery state of charge *Returns*: * Current state of charge of the drone battery (0..1) \"\"\" battery_tel = self._parent_drone.telemetry.get(blueye.protocol.BatteryTel) if battery_tel is not None: return battery_tel.battery.level else: return None Instance variables state_of_charge Get the battery state of charge Returns : Current state of charge of the drone battery (0..1)","title":"Battery"},{"location":"reference/blueye/sdk/battery/#module-blueyesdkbattery","text":"View Source from __future__ import annotations from typing import TYPE_CHECKING, Optional import blueye.protocol # Necessary to avoid cyclic imports if TYPE_CHECKING: from .drone import Drone class Battery: def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone @property def state_of_charge(self) -> Optional[float]: \"\"\"Get the battery state of charge *Returns*: * Current state of charge of the drone battery (0..1) \"\"\" battery_tel = self._parent_drone.telemetry.get(blueye.protocol.BatteryTel) if battery_tel is not None: return battery_tel.battery.level else: return None","title":"Module blueye.sdk.battery"},{"location":"reference/blueye/sdk/battery/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/blueye/sdk/battery/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/battery/#battery","text":"class Battery ( parent_drone : 'Drone' ) View Source class Battery: def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone @property def state_of_charge(self) -> Optional[float]: \"\"\"Get the battery state of charge *Returns*: * Current state of charge of the drone battery (0..1) \"\"\" battery_tel = self._parent_drone.telemetry.get(blueye.protocol.BatteryTel) if battery_tel is not None: return battery_tel.battery.level else: return None","title":"Battery"},{"location":"reference/blueye/sdk/battery/#instance-variables","text":"state_of_charge Get the battery state of charge Returns : Current state of charge of the drone battery (0..1)","title":"Instance variables"},{"location":"reference/blueye/sdk/camera/","text":"Module blueye.sdk.camera View Source from __future__ import annotations import logging import re import warnings from typing import TYPE_CHECKING, Optional import blueye.protocol import requests # Necessary to avoid cyclic imports if TYPE_CHECKING: from .drone import Drone logger = logging.getLogger(__name__) class Tilt: def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def _verify_tilt_in_features(self): \"\"\"Checks that the connected drone has the tilt feature Raises a RuntimeError if it does not. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") def set_velocity(self, velocity: float): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Raises a RuntimeError if the connected drone does not have the tilt option \"\"\" self._verify_tilt_in_features() self._parent_drone._ctrl_client.set_tilt_velocity(velocity) @property def angle(self) -> Optional[float]: \"\"\"Return the current angle of the camera tilt Raises a RuntimeError if the connected drone does not have the tilt option \"\"\" self._verify_tilt_in_features() tilt_angle_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltAngleTel) if tilt_angle_tel is not None: return tilt_angle_tel.angle.value else: return None @property def stabilization_enabled(self) -> Optional[bool]: \"\"\"Get or set the state of active camera stabilization *Arguments*: * enabled (bool): True to turn stabilization on, False to turn it off *Returns*: * enabled (bool): Current state of active camera stabilization \"\"\" self._verify_tilt_in_features() tilt_stab_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltStabilizationTel) if tilt_stab_tel is not None: return tilt_stab_tel.state.enabled else: return None @stabilization_enabled.setter def stabilization_enabled(self, enabled: bool): self._verify_tilt_in_features() self._parent_drone._ctrl_client.set_tilt_stabilization(enabled) class Overlay: \"\"\"Control the overlay on videos and pictures\"\"\" def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone self._overlay_parametres = None def _update_overlay_parameters(self): self._overlay_parametres = self._parent_drone._req_rep_client.get_overlay_parameters() @property def temperature_enabled(self) -> bool: \"\"\"Get or set the state of the temperature overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.temperature_enabled @temperature_enabled.setter def temperature_enabled(self, enable_temperature: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.temperature_enabled = enable_temperature self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def depth_enabled(self) -> bool: \"\"\"Get or set the state of the depth overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.depth_enabled @depth_enabled.setter def depth_enabled(self, enable_depth: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.depth_enabled = enable_depth self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def heading_enabled(self) -> bool: \"\"\"Get or set the state of the heading overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.heading_enabled @heading_enabled.setter def heading_enabled(self, enable_heading: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.heading_enabled = enable_heading self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def tilt_enabled(self) -> bool: \"\"\"Get or set the state of the tilt overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.tilt_enabled @tilt_enabled.setter def tilt_enabled(self, enable_tilt: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.tilt_enabled = enable_tilt self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def date_enabled(self) -> bool: \"\"\"Get or set the state of the date overlay\"\"\" if self._overlay_parametres is None: self._update_overlay_parameters() return self._overlay_parametres.date_enabled @date_enabled.setter def date_enabled(self, enable_date: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.date_enabled = enable_date self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def logo(self) -> blueye.protcol.LogoType: \"\"\"Get or set logo overlay selection Needs to be set to an instance of the `blueye.protocol.LogoType` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.logo_type @logo.setter def logo(self, logo_type: blueye.protocol.LogoType): if not isinstance(logo_type, blueye.protocol.LogoType): warnings.warn(\"Invalid logo type, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.logo_type = logo_type self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def depth_unit(self) -> blueye.protocol.DepthUnit: \"\"\"Get or set the depth unit for the overlay Needs to be set to an instance of the `blueye.protocol.DepthUnit` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.depth_unit @depth_unit.setter def depth_unit(self, unit: blueye.protocol.DepthUnit): if not isinstance(unit, blueye.protocol.DepthUnit): warnings.warn(\"Invalid depth unit, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.depth_unit = unit self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def temperature_unit(self) -> blueye.protocol.TemperatureUnit: \"\"\"Get or set the temperature unit for the overlay Needs to be set to an instance of the `blueye.protocol.TemperatureUnit` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.temperature_unit @temperature_unit.setter def temperature_unit(self, unit: blueye.protocol.TemperatureUnit): if not isinstance(unit, blueye.protocol.TemperatureUnit): warnings.warn(\"Invalid temperature unit, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.temperature_unit = unit self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def timezone_offset(self) -> int: \"\"\"Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.timezone_offset @timezone_offset.setter def timezone_offset(self, offset: int): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.timezone_offset = offset self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def margin_width(self) -> int: \"\"\"Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.margin_width @margin_width.setter def margin_width(self, width: int): if width < 0: warnings.warn(\"Invalid margin width, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.margin_width = width self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def margin_height(self) -> int: \"\"\"Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.margin_height @margin_height.setter def margin_height(self, height: int): if height < 0: warnings.warn(\"Invalid margin height, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.margin_height = height self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def font_size(self) -> blueye.protocol.FontSize: \"\"\"Get or set the font size for the overlay Needs to be an instance of the `blueye.protocol.Fontsize` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.font_size @font_size.setter def font_size(self, size: blueye.protocol.FontSize): if not isinstance(size, blueye.protocol.FontSize): warnings.warn(\"Invalid font size, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.font_size = size self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def title(self) -> str: \"\"\"Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.title @title.setter def title(self, input_title: str): new_title = input_title if len(input_title) > 63: warnings.warn(\"Too long title, truncating to 63 characters\", RuntimeWarning) new_title = new_title[:63] try: bytes(new_title, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Title can only contain ASCII characters, ignoring\", RuntimeWarning) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.title = new_title self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def subtitle(self) -> str: \"\"\"Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.subtitle @subtitle.setter def subtitle(self, input_subtitle: str): new_subtitle = input_subtitle if len(input_subtitle) > 63: warnings.warn(\"Too long subtitle, truncating to 63 characters\", RuntimeWarning) new_subtitle = new_subtitle[:63] try: bytes(new_subtitle, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Subtitle can only contain ASCII characters, ignoring\", RuntimeWarning) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.subtitle = new_subtitle self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def date_format(self) -> str: \"\"\"Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.date_format @date_format.setter def date_format(self, input_format_str: str): format_str = input_format_str if len(format_str) > 63: warnings.warn( \"Too long date format string, truncating to 63 characters\", RuntimeWarning ) format_str = format_str[:63] try: bytes(format_str, \"ascii\") except UnicodeEncodeError: warnings.warn( \"Date format string can only contain ASCII characters, ignoring\", RuntimeWarning ) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.date_format = format_str self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) def upload_logo(self, path_to_logo: str, timeout: float = 1.0): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `blueye.protocol.LogoType.LOG_TYPE_CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=timeout) response.raise_for_status() def download_logo(self, output_directory=\".\", timeout: float = 1.0): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content) def delete_logo(self, timeout: float = 1.0): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status() class Camera: def __init__(self, parent_drone: Drone, is_guestport_camera: bool = False): self._parent_drone = parent_drone self._is_guestport_camera = is_guestport_camera self._camera_type = ( blueye.protocol.Camera.CAMERA_GUESTPORT if is_guestport_camera else blueye.protocol.Camera.CAMERA_MAIN ) if not self._is_guestport_camera: self.tilt = Tilt(parent_drone) self.overlay = Overlay(parent_drone) self._camera_parameters = None def _get_record_state(self) -> Optional[blueye.protocol.RecordState]: record_state_tel = self._parent_drone.telemetry.get(blueye.protocol.RecordStateTel) if record_state_tel is not None: return record_state_tel.record_state else: return None def _update_camera_parameters(self): self._camera_parameters = self._parent_drone._req_rep_client.get_camera_parameters( camera=self._camera_type ) @property def is_recording(self) -> Optional[bool]: \"\"\"Get or set the camera recording state *Arguments*: * start_recording (bool): Set to True to start a recording, set to False to stop the current recording. *Returns*: * Recording state (bool): True if the camera is currently recording, False if not \"\"\" record_state = self._get_record_state() if record_state is None: return None if self._is_guestport_camera: return record_state.guestport_is_recording else: return record_state.main_is_recording @is_recording.setter def is_recording(self, start_recording: bool): record_state = self._get_record_state() if record_state is None: logger.warning(\"Unable to set recording state, no record state telemetry received\") return if self._is_guestport_camera: self._parent_drone._ctrl_client.set_recording_state( record_state.main_is_recording, start_recording ) else: self._parent_drone._ctrl_client.set_recording_state( start_recording, record_state.guestport_is_recording ) @property def bitrate(self) -> int: \"\"\"Set or get the video stream bitrate *Arguments*: * bitrate (int): Set the video stream bitrate in bits, valid values are in range (1 000 000..16 000 000) *Returns*: * bitrate (int): The H264 video stream bitrate \"\"\" self._update_camera_parameters() return self._camera_parameters.h264_bitrate @bitrate.setter def bitrate(self, bitrate: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.h264_bitrate = bitrate self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def bitrate_still_picture(self) -> int: \"\"\"Set or get the bitrate for the still picture stream *Arguments*: * bitrate (int): Set the still picture stream bitrate in bits, valid values are in range (1 000 000 .. 300 000 000). Default value is 100 000 000. *Returns*: * bitrate (int): The still picture stream bitrate \"\"\" self._update_camera_parameters() return self._camera_parameters.mjpg_bitrate @bitrate_still_picture.setter def bitrate_still_picture(self, bitrate: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.mjpg_bitrate = bitrate self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def exposure(self) -> int: \"\"\"Set or get the camera exposure *Arguments*: * exposure (int): Set the camera exposure time. Unit is thousandths of a second, ie. 5 = 5s/1000. Valid values are in the range (1 .. 5000) or -1 for auto exposure *Returns*: * exposure (int): Get the camera exposure \"\"\" self._update_camera_parameters() return self._camera_parameters.exposure @exposure.setter def exposure(self, exposure: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.exposure = exposure self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def whitebalance(self) -> int: \"\"\"Set or get the camera white balance *Arguments*: * white_balance (int): Set the camera white balance. Valid values are in the range (2800..9300) or -1 for auto white balance *Returns*: * white_balance (int): Get the camera white balance \"\"\" self._update_camera_parameters() return self._camera_parameters.white_balance @whitebalance.setter def whitebalance(self, white_balance: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.white_balance = white_balance self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def hue(self) -> int: \"\"\"Set or get the camera hue *Arguments*: * hue (int): Set the camera hue. Valid values are in the range (-40..40) *Returns*: * hue (int): Get the camera hue \"\"\" self._update_camera_parameters() return self._camera_parameters.hue @hue.setter def hue(self, hue: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.hue = hue self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def resolution(self) -> int: \"\"\"Set or get the camera resolution *Arguments*: * resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 *Returns*: * resolution (int): Get the camera resolution \"\"\" self._update_camera_parameters() if self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_HD_720P: return 720 elif ( self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P ): return 1080 @resolution.setter def resolution(self, resolution: int): if resolution not in (720, 1080): raise ValueError( f\"{resolution} is not a valid resolution. Valid values are 720 or 1080\" ) if self._camera_parameters is None: self._update_camera_parameters() if resolution == 720: self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_HD_720P elif resolution == 1080: self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def framerate(self) -> int: \"\"\"Set or get the camera frame rate *Arguments*: * framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 *Returns*: * framerate (int): Get the camera frame rate \"\"\" self._update_camera_parameters() if self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_25: return 25 elif self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_30: return 30 @framerate.setter def framerate(self, framerate: int): if framerate not in (25, 30): raise ValueError(f\"{framerate} is not a valid framerate. Valid values are 25 or 30\") if self._camera_parameters is None: self._update_camera_parameters() if framerate == 25: self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_25 elif framerate == 30: self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_30 self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def record_time(self) -> Optional[int]: \"\"\"Set or get the duration of the current camera recording *Returns*: * record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording \"\"\" record_state = self._get_record_state() if record_state is None: return None if self._is_guestport_camera: return record_state.guestport_seconds else: return record_state.main_seconds def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. \"\"\" self._parent_drone._ctrl_client.take_still_picture() Variables TYPE_CHECKING logger Classes Camera class Camera ( parent_drone : 'Drone' , is_guestport_camera : 'bool' = False ) View Source class Camera: def __init__(self, parent_drone: Drone, is_guestport_camera: bool = False): self._parent_drone = parent_drone self._is_guestport_camera = is_guestport_camera self._camera_type = ( blueye.protocol.Camera.CAMERA_GUESTPORT if is_guestport_camera else blueye.protocol.Camera.CAMERA_MAIN ) if not self._is_guestport_camera: self.tilt = Tilt(parent_drone) self.overlay = Overlay(parent_drone) self._camera_parameters = None def _get_record_state(self) -> Optional[blueye.protocol.RecordState]: record_state_tel = self._parent_drone.telemetry.get(blueye.protocol.RecordStateTel) if record_state_tel is not None: return record_state_tel.record_state else: return None def _update_camera_parameters(self): self._camera_parameters = self._parent_drone._req_rep_client.get_camera_parameters( camera=self._camera_type ) @property def is_recording(self) -> Optional[bool]: \"\"\"Get or set the camera recording state *Arguments*: * start_recording (bool): Set to True to start a recording, set to False to stop the current recording. *Returns*: * Recording state (bool): True if the camera is currently recording, False if not \"\"\" record_state = self._get_record_state() if record_state is None: return None if self._is_guestport_camera: return record_state.guestport_is_recording else: return record_state.main_is_recording @is_recording.setter def is_recording(self, start_recording: bool): record_state = self._get_record_state() if record_state is None: logger.warning(\"Unable to set recording state, no record state telemetry received\") return if self._is_guestport_camera: self._parent_drone._ctrl_client.set_recording_state( record_state.main_is_recording, start_recording ) else: self._parent_drone._ctrl_client.set_recording_state( start_recording, record_state.guestport_is_recording ) @property def bitrate(self) -> int: \"\"\"Set or get the video stream bitrate *Arguments*: * bitrate (int): Set the video stream bitrate in bits, valid values are in range (1 000 000..16 000 000) *Returns*: * bitrate (int): The H264 video stream bitrate \"\"\" self._update_camera_parameters() return self._camera_parameters.h264_bitrate @bitrate.setter def bitrate(self, bitrate: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.h264_bitrate = bitrate self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def bitrate_still_picture(self) -> int: \"\"\"Set or get the bitrate for the still picture stream *Arguments*: * bitrate (int): Set the still picture stream bitrate in bits, valid values are in range (1 000 000 .. 300 000 000). Default value is 100 000 000. *Returns*: * bitrate (int): The still picture stream bitrate \"\"\" self._update_camera_parameters() return self._camera_parameters.mjpg_bitrate @bitrate_still_picture.setter def bitrate_still_picture(self, bitrate: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.mjpg_bitrate = bitrate self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def exposure(self) -> int: \"\"\"Set or get the camera exposure *Arguments*: * exposure (int): Set the camera exposure time. Unit is thousandths of a second, ie. 5 = 5s/1000. Valid values are in the range (1 .. 5000) or -1 for auto exposure *Returns*: * exposure (int): Get the camera exposure \"\"\" self._update_camera_parameters() return self._camera_parameters.exposure @exposure.setter def exposure(self, exposure: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.exposure = exposure self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def whitebalance(self) -> int: \"\"\"Set or get the camera white balance *Arguments*: * white_balance (int): Set the camera white balance. Valid values are in the range (2800..9300) or -1 for auto white balance *Returns*: * white_balance (int): Get the camera white balance \"\"\" self._update_camera_parameters() return self._camera_parameters.white_balance @whitebalance.setter def whitebalance(self, white_balance: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.white_balance = white_balance self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def hue(self) -> int: \"\"\"Set or get the camera hue *Arguments*: * hue (int): Set the camera hue. Valid values are in the range (-40..40) *Returns*: * hue (int): Get the camera hue \"\"\" self._update_camera_parameters() return self._camera_parameters.hue @hue.setter def hue(self, hue: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.hue = hue self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def resolution(self) -> int: \"\"\"Set or get the camera resolution *Arguments*: * resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 *Returns*: * resolution (int): Get the camera resolution \"\"\" self._update_camera_parameters() if self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_HD_720P: return 720 elif ( self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P ): return 1080 @resolution.setter def resolution(self, resolution: int): if resolution not in (720, 1080): raise ValueError( f\"{resolution} is not a valid resolution. Valid values are 720 or 1080\" ) if self._camera_parameters is None: self._update_camera_parameters() if resolution == 720: self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_HD_720P elif resolution == 1080: self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def framerate(self) -> int: \"\"\"Set or get the camera frame rate *Arguments*: * framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 *Returns*: * framerate (int): Get the camera frame rate \"\"\" self._update_camera_parameters() if self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_25: return 25 elif self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_30: return 30 @framerate.setter def framerate(self, framerate: int): if framerate not in (25, 30): raise ValueError(f\"{framerate} is not a valid framerate. Valid values are 25 or 30\") if self._camera_parameters is None: self._update_camera_parameters() if framerate == 25: self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_25 elif framerate == 30: self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_30 self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def record_time(self) -> Optional[int]: \"\"\"Set or get the duration of the current camera recording *Returns*: * record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording \"\"\" record_state = self._get_record_state() if record_state is None: return None if self._is_guestport_camera: return record_state.guestport_seconds else: return record_state.main_seconds def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. \"\"\" self._parent_drone._ctrl_client.take_still_picture() Instance variables bitrate Set or get the video stream bitrate Arguments : bitrate (int): Set the video stream bitrate in bits, valid values are in range (1 000 000..16 000 000) Returns : bitrate (int): The H264 video stream bitrate bitrate_still_picture Set or get the bitrate for the still picture stream Arguments : bitrate (int): Set the still picture stream bitrate in bits, valid values are in range (1 000 000 .. 300 000 000). Default value is 100 000 000. Returns : bitrate (int): The still picture stream bitrate exposure Set or get the camera exposure Arguments : exposure (int): Set the camera exposure time. Unit is thousandths of a second, ie. 5 = 5s/1000. Valid values are in the range (1 .. 5000) or -1 for auto exposure Returns : exposure (int): Get the camera exposure framerate Set or get the camera frame rate Arguments : framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 Returns : framerate (int): Get the camera frame rate hue Set or get the camera hue Arguments : hue (int): Set the camera hue. Valid values are in the range (-40..40) Returns : hue (int): Get the camera hue is_recording Get or set the camera recording state Arguments : start_recording (bool): Set to True to start a recording, set to False to stop the current recording. Returns : Recording state (bool): True if the camera is currently recording, False if not record_time Set or get the duration of the current camera recording Returns : record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording resolution Set or get the camera resolution Arguments : resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 Returns : resolution (int): Get the camera resolution whitebalance Set or get the camera white balance Arguments : white_balance (int): Set the camera white balance. Valid values are in the range (2800..9300) or -1 for auto white balance Returns : white_balance (int): Get the camera white balance Methods take_picture def take_picture ( self ) Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. View Source def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. \"\"\" self._parent_drone._ctrl_client.take_still_picture() Overlay class Overlay ( parent_drone : 'Drone' ) Control the overlay on videos and pictures View Source class Overlay: \"\"\"Control the overlay on videos and pictures\"\"\" def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone self._overlay_parametres = None def _update_overlay_parameters(self): self._overlay_parametres = self._parent_drone._req_rep_client.get_overlay_parameters() @property def temperature_enabled(self) -> bool: \"\"\"Get or set the state of the temperature overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.temperature_enabled @temperature_enabled.setter def temperature_enabled(self, enable_temperature: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.temperature_enabled = enable_temperature self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def depth_enabled(self) -> bool: \"\"\"Get or set the state of the depth overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.depth_enabled @depth_enabled.setter def depth_enabled(self, enable_depth: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.depth_enabled = enable_depth self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def heading_enabled(self) -> bool: \"\"\"Get or set the state of the heading overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.heading_enabled @heading_enabled.setter def heading_enabled(self, enable_heading: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.heading_enabled = enable_heading self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def tilt_enabled(self) -> bool: \"\"\"Get or set the state of the tilt overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.tilt_enabled @tilt_enabled.setter def tilt_enabled(self, enable_tilt: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.tilt_enabled = enable_tilt self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def date_enabled(self) -> bool: \"\"\"Get or set the state of the date overlay\"\"\" if self._overlay_parametres is None: self._update_overlay_parameters() return self._overlay_parametres.date_enabled @date_enabled.setter def date_enabled(self, enable_date: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.date_enabled = enable_date self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def logo(self) -> blueye.protcol.LogoType: \"\"\"Get or set logo overlay selection Needs to be set to an instance of the `blueye.protocol.LogoType` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.logo_type @logo.setter def logo(self, logo_type: blueye.protocol.LogoType): if not isinstance(logo_type, blueye.protocol.LogoType): warnings.warn(\"Invalid logo type, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.logo_type = logo_type self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def depth_unit(self) -> blueye.protocol.DepthUnit: \"\"\"Get or set the depth unit for the overlay Needs to be set to an instance of the `blueye.protocol.DepthUnit` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.depth_unit @depth_unit.setter def depth_unit(self, unit: blueye.protocol.DepthUnit): if not isinstance(unit, blueye.protocol.DepthUnit): warnings.warn(\"Invalid depth unit, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.depth_unit = unit self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def temperature_unit(self) -> blueye.protocol.TemperatureUnit: \"\"\"Get or set the temperature unit for the overlay Needs to be set to an instance of the `blueye.protocol.TemperatureUnit` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.temperature_unit @temperature_unit.setter def temperature_unit(self, unit: blueye.protocol.TemperatureUnit): if not isinstance(unit, blueye.protocol.TemperatureUnit): warnings.warn(\"Invalid temperature unit, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.temperature_unit = unit self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def timezone_offset(self) -> int: \"\"\"Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.timezone_offset @timezone_offset.setter def timezone_offset(self, offset: int): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.timezone_offset = offset self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def margin_width(self) -> int: \"\"\"Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.margin_width @margin_width.setter def margin_width(self, width: int): if width < 0: warnings.warn(\"Invalid margin width, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.margin_width = width self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def margin_height(self) -> int: \"\"\"Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.margin_height @margin_height.setter def margin_height(self, height: int): if height < 0: warnings.warn(\"Invalid margin height, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.margin_height = height self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def font_size(self) -> blueye.protocol.FontSize: \"\"\"Get or set the font size for the overlay Needs to be an instance of the `blueye.protocol.Fontsize` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.font_size @font_size.setter def font_size(self, size: blueye.protocol.FontSize): if not isinstance(size, blueye.protocol.FontSize): warnings.warn(\"Invalid font size, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.font_size = size self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def title(self) -> str: \"\"\"Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.title @title.setter def title(self, input_title: str): new_title = input_title if len(input_title) > 63: warnings.warn(\"Too long title, truncating to 63 characters\", RuntimeWarning) new_title = new_title[:63] try: bytes(new_title, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Title can only contain ASCII characters, ignoring\", RuntimeWarning) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.title = new_title self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def subtitle(self) -> str: \"\"\"Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.subtitle @subtitle.setter def subtitle(self, input_subtitle: str): new_subtitle = input_subtitle if len(input_subtitle) > 63: warnings.warn(\"Too long subtitle, truncating to 63 characters\", RuntimeWarning) new_subtitle = new_subtitle[:63] try: bytes(new_subtitle, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Subtitle can only contain ASCII characters, ignoring\", RuntimeWarning) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.subtitle = new_subtitle self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def date_format(self) -> str: \"\"\"Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.date_format @date_format.setter def date_format(self, input_format_str: str): format_str = input_format_str if len(format_str) > 63: warnings.warn( \"Too long date format string, truncating to 63 characters\", RuntimeWarning ) format_str = format_str[:63] try: bytes(format_str, \"ascii\") except UnicodeEncodeError: warnings.warn( \"Date format string can only contain ASCII characters, ignoring\", RuntimeWarning ) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.date_format = format_str self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) def upload_logo(self, path_to_logo: str, timeout: float = 1.0): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `blueye.protocol.LogoType.LOG_TYPE_CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=timeout) response.raise_for_status() def download_logo(self, output_directory=\".\", timeout: float = 1.0): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content) def delete_logo(self, timeout: float = 1.0): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status() Instance variables date_enabled Get or set the state of the date overlay date_format Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. depth_enabled Get or set the state of the depth overlay depth_unit Get or set the depth unit for the overlay Needs to be set to an instance of the blueye.protocol.DepthUnit enum, if not a RuntimeWarning is raised. font_size Get or set the font size for the overlay Needs to be an instance of the blueye.protocol.Fontsize enum, if not a RuntimeWarning is raised. heading_enabled Get or set the state of the heading overlay logo Get or set logo overlay selection Needs to be set to an instance of the blueye.protocol.LogoType enum, if not a RuntimeWarning is raised. margin_height Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. margin_width Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. subtitle Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. temperature_enabled Get or set the state of the temperature overlay temperature_unit Get or set the temperature unit for the overlay Needs to be set to an instance of the blueye.protocol.TemperatureUnit enum, if not a RuntimeWarning is raised. tilt_enabled Get or set the state of the tilt overlay timezone_offset Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. title Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. Methods delete_logo def delete_logo ( self , timeout : 'float' = 1.0 ) Delete the user uploaded logo from the drone Exceptions : requests.exceptions.HTTPError : If an error occurs during deletion requests.exceptions.ConnectTimeout : If unable to create a connection within specified timeout (default 1s) View Source def delete_logo(self, timeout: float = 1.0): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status() download_logo def download_logo ( self , output_directory = '.' , timeout : 'float' = 1.0 ) Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. Exceptions : requests.exceptions.HTTPError : If no custom logo is uploaded. requests.exceptions.ConnectTimeout : If unable to create a connection within specified timeout (default 1s) View Source def download_logo(self, output_directory=\".\", timeout: float = 1.0): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content) upload_logo def upload_logo ( self , path_to_logo : 'str' , timeout : 'float' = 1.0 ) Upload user selectable logo for watermarking videos and pictures Set the logo-property to blueye.protocol.LogoType.LOG_TYPE_CUSTOM to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. Exceptions : requests.exceptions.HTTPError : Status code 400 for invalid files requests.exceptions.ConnectTimeout : If unable to create a connection within specified timeout (default 1s) View Source def upload_logo(self, path_to_logo: str, timeout: float = 1.0): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `blueye.protocol.LogoType.LOG_TYPE_CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=timeout) response.raise_for_status() Tilt class Tilt ( parent_drone : 'Drone' ) View Source class Tilt: def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def _verify_tilt_in_features(self): \"\"\"Checks that the connected drone has the tilt feature Raises a RuntimeError if it does not. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") def set_velocity(self, velocity: float): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Raises a RuntimeError if the connected drone does not have the tilt option \"\"\" self._verify_tilt_in_features() self._parent_drone._ctrl_client.set_tilt_velocity(velocity) @property def angle(self) -> Optional[float]: \"\"\"Return the current angle of the camera tilt Raises a RuntimeError if the connected drone does not have the tilt option \"\"\" self._verify_tilt_in_features() tilt_angle_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltAngleTel) if tilt_angle_tel is not None: return tilt_angle_tel.angle.value else: return None @property def stabilization_enabled(self) -> Optional[bool]: \"\"\"Get or set the state of active camera stabilization *Arguments*: * enabled (bool): True to turn stabilization on, False to turn it off *Returns*: * enabled (bool): Current state of active camera stabilization \"\"\" self._verify_tilt_in_features() tilt_stab_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltStabilizationTel) if tilt_stab_tel is not None: return tilt_stab_tel.state.enabled else: return None @stabilization_enabled.setter def stabilization_enabled(self, enabled: bool): self._verify_tilt_in_features() self._parent_drone._ctrl_client.set_tilt_stabilization(enabled) Instance variables angle Return the current angle of the camera tilt Raises a RuntimeError if the connected drone does not have the tilt option stabilization_enabled Get or set the state of active camera stabilization Arguments : enabled (bool): True to turn stabilization on, False to turn it off Returns : enabled (bool): Current state of active camera stabilization Methods set_velocity def set_velocity ( self , velocity : 'float' ) Set the speed and direction of the camera tilt Arguments : velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Raises a RuntimeError if the connected drone does not have the tilt option View Source def set_velocity(self, velocity: float): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Raises a RuntimeError if the connected drone does not have the tilt option \"\"\" self._verify_tilt_in_features() self._parent_drone._ctrl_client.set_tilt_velocity(velocity)","title":"Camera"},{"location":"reference/blueye/sdk/camera/#module-blueyesdkcamera","text":"View Source from __future__ import annotations import logging import re import warnings from typing import TYPE_CHECKING, Optional import blueye.protocol import requests # Necessary to avoid cyclic imports if TYPE_CHECKING: from .drone import Drone logger = logging.getLogger(__name__) class Tilt: def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def _verify_tilt_in_features(self): \"\"\"Checks that the connected drone has the tilt feature Raises a RuntimeError if it does not. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") def set_velocity(self, velocity: float): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Raises a RuntimeError if the connected drone does not have the tilt option \"\"\" self._verify_tilt_in_features() self._parent_drone._ctrl_client.set_tilt_velocity(velocity) @property def angle(self) -> Optional[float]: \"\"\"Return the current angle of the camera tilt Raises a RuntimeError if the connected drone does not have the tilt option \"\"\" self._verify_tilt_in_features() tilt_angle_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltAngleTel) if tilt_angle_tel is not None: return tilt_angle_tel.angle.value else: return None @property def stabilization_enabled(self) -> Optional[bool]: \"\"\"Get or set the state of active camera stabilization *Arguments*: * enabled (bool): True to turn stabilization on, False to turn it off *Returns*: * enabled (bool): Current state of active camera stabilization \"\"\" self._verify_tilt_in_features() tilt_stab_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltStabilizationTel) if tilt_stab_tel is not None: return tilt_stab_tel.state.enabled else: return None @stabilization_enabled.setter def stabilization_enabled(self, enabled: bool): self._verify_tilt_in_features() self._parent_drone._ctrl_client.set_tilt_stabilization(enabled) class Overlay: \"\"\"Control the overlay on videos and pictures\"\"\" def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone self._overlay_parametres = None def _update_overlay_parameters(self): self._overlay_parametres = self._parent_drone._req_rep_client.get_overlay_parameters() @property def temperature_enabled(self) -> bool: \"\"\"Get or set the state of the temperature overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.temperature_enabled @temperature_enabled.setter def temperature_enabled(self, enable_temperature: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.temperature_enabled = enable_temperature self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def depth_enabled(self) -> bool: \"\"\"Get or set the state of the depth overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.depth_enabled @depth_enabled.setter def depth_enabled(self, enable_depth: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.depth_enabled = enable_depth self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def heading_enabled(self) -> bool: \"\"\"Get or set the state of the heading overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.heading_enabled @heading_enabled.setter def heading_enabled(self, enable_heading: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.heading_enabled = enable_heading self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def tilt_enabled(self) -> bool: \"\"\"Get or set the state of the tilt overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.tilt_enabled @tilt_enabled.setter def tilt_enabled(self, enable_tilt: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.tilt_enabled = enable_tilt self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def date_enabled(self) -> bool: \"\"\"Get or set the state of the date overlay\"\"\" if self._overlay_parametres is None: self._update_overlay_parameters() return self._overlay_parametres.date_enabled @date_enabled.setter def date_enabled(self, enable_date: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.date_enabled = enable_date self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def logo(self) -> blueye.protcol.LogoType: \"\"\"Get or set logo overlay selection Needs to be set to an instance of the `blueye.protocol.LogoType` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.logo_type @logo.setter def logo(self, logo_type: blueye.protocol.LogoType): if not isinstance(logo_type, blueye.protocol.LogoType): warnings.warn(\"Invalid logo type, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.logo_type = logo_type self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def depth_unit(self) -> blueye.protocol.DepthUnit: \"\"\"Get or set the depth unit for the overlay Needs to be set to an instance of the `blueye.protocol.DepthUnit` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.depth_unit @depth_unit.setter def depth_unit(self, unit: blueye.protocol.DepthUnit): if not isinstance(unit, blueye.protocol.DepthUnit): warnings.warn(\"Invalid depth unit, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.depth_unit = unit self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def temperature_unit(self) -> blueye.protocol.TemperatureUnit: \"\"\"Get or set the temperature unit for the overlay Needs to be set to an instance of the `blueye.protocol.TemperatureUnit` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.temperature_unit @temperature_unit.setter def temperature_unit(self, unit: blueye.protocol.TemperatureUnit): if not isinstance(unit, blueye.protocol.TemperatureUnit): warnings.warn(\"Invalid temperature unit, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.temperature_unit = unit self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def timezone_offset(self) -> int: \"\"\"Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.timezone_offset @timezone_offset.setter def timezone_offset(self, offset: int): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.timezone_offset = offset self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def margin_width(self) -> int: \"\"\"Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.margin_width @margin_width.setter def margin_width(self, width: int): if width < 0: warnings.warn(\"Invalid margin width, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.margin_width = width self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def margin_height(self) -> int: \"\"\"Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.margin_height @margin_height.setter def margin_height(self, height: int): if height < 0: warnings.warn(\"Invalid margin height, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.margin_height = height self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def font_size(self) -> blueye.protocol.FontSize: \"\"\"Get or set the font size for the overlay Needs to be an instance of the `blueye.protocol.Fontsize` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.font_size @font_size.setter def font_size(self, size: blueye.protocol.FontSize): if not isinstance(size, blueye.protocol.FontSize): warnings.warn(\"Invalid font size, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.font_size = size self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def title(self) -> str: \"\"\"Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.title @title.setter def title(self, input_title: str): new_title = input_title if len(input_title) > 63: warnings.warn(\"Too long title, truncating to 63 characters\", RuntimeWarning) new_title = new_title[:63] try: bytes(new_title, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Title can only contain ASCII characters, ignoring\", RuntimeWarning) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.title = new_title self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def subtitle(self) -> str: \"\"\"Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.subtitle @subtitle.setter def subtitle(self, input_subtitle: str): new_subtitle = input_subtitle if len(input_subtitle) > 63: warnings.warn(\"Too long subtitle, truncating to 63 characters\", RuntimeWarning) new_subtitle = new_subtitle[:63] try: bytes(new_subtitle, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Subtitle can only contain ASCII characters, ignoring\", RuntimeWarning) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.subtitle = new_subtitle self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def date_format(self) -> str: \"\"\"Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.date_format @date_format.setter def date_format(self, input_format_str: str): format_str = input_format_str if len(format_str) > 63: warnings.warn( \"Too long date format string, truncating to 63 characters\", RuntimeWarning ) format_str = format_str[:63] try: bytes(format_str, \"ascii\") except UnicodeEncodeError: warnings.warn( \"Date format string can only contain ASCII characters, ignoring\", RuntimeWarning ) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.date_format = format_str self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) def upload_logo(self, path_to_logo: str, timeout: float = 1.0): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `blueye.protocol.LogoType.LOG_TYPE_CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=timeout) response.raise_for_status() def download_logo(self, output_directory=\".\", timeout: float = 1.0): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content) def delete_logo(self, timeout: float = 1.0): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status() class Camera: def __init__(self, parent_drone: Drone, is_guestport_camera: bool = False): self._parent_drone = parent_drone self._is_guestport_camera = is_guestport_camera self._camera_type = ( blueye.protocol.Camera.CAMERA_GUESTPORT if is_guestport_camera else blueye.protocol.Camera.CAMERA_MAIN ) if not self._is_guestport_camera: self.tilt = Tilt(parent_drone) self.overlay = Overlay(parent_drone) self._camera_parameters = None def _get_record_state(self) -> Optional[blueye.protocol.RecordState]: record_state_tel = self._parent_drone.telemetry.get(blueye.protocol.RecordStateTel) if record_state_tel is not None: return record_state_tel.record_state else: return None def _update_camera_parameters(self): self._camera_parameters = self._parent_drone._req_rep_client.get_camera_parameters( camera=self._camera_type ) @property def is_recording(self) -> Optional[bool]: \"\"\"Get or set the camera recording state *Arguments*: * start_recording (bool): Set to True to start a recording, set to False to stop the current recording. *Returns*: * Recording state (bool): True if the camera is currently recording, False if not \"\"\" record_state = self._get_record_state() if record_state is None: return None if self._is_guestport_camera: return record_state.guestport_is_recording else: return record_state.main_is_recording @is_recording.setter def is_recording(self, start_recording: bool): record_state = self._get_record_state() if record_state is None: logger.warning(\"Unable to set recording state, no record state telemetry received\") return if self._is_guestport_camera: self._parent_drone._ctrl_client.set_recording_state( record_state.main_is_recording, start_recording ) else: self._parent_drone._ctrl_client.set_recording_state( start_recording, record_state.guestport_is_recording ) @property def bitrate(self) -> int: \"\"\"Set or get the video stream bitrate *Arguments*: * bitrate (int): Set the video stream bitrate in bits, valid values are in range (1 000 000..16 000 000) *Returns*: * bitrate (int): The H264 video stream bitrate \"\"\" self._update_camera_parameters() return self._camera_parameters.h264_bitrate @bitrate.setter def bitrate(self, bitrate: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.h264_bitrate = bitrate self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def bitrate_still_picture(self) -> int: \"\"\"Set or get the bitrate for the still picture stream *Arguments*: * bitrate (int): Set the still picture stream bitrate in bits, valid values are in range (1 000 000 .. 300 000 000). Default value is 100 000 000. *Returns*: * bitrate (int): The still picture stream bitrate \"\"\" self._update_camera_parameters() return self._camera_parameters.mjpg_bitrate @bitrate_still_picture.setter def bitrate_still_picture(self, bitrate: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.mjpg_bitrate = bitrate self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def exposure(self) -> int: \"\"\"Set or get the camera exposure *Arguments*: * exposure (int): Set the camera exposure time. Unit is thousandths of a second, ie. 5 = 5s/1000. Valid values are in the range (1 .. 5000) or -1 for auto exposure *Returns*: * exposure (int): Get the camera exposure \"\"\" self._update_camera_parameters() return self._camera_parameters.exposure @exposure.setter def exposure(self, exposure: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.exposure = exposure self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def whitebalance(self) -> int: \"\"\"Set or get the camera white balance *Arguments*: * white_balance (int): Set the camera white balance. Valid values are in the range (2800..9300) or -1 for auto white balance *Returns*: * white_balance (int): Get the camera white balance \"\"\" self._update_camera_parameters() return self._camera_parameters.white_balance @whitebalance.setter def whitebalance(self, white_balance: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.white_balance = white_balance self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def hue(self) -> int: \"\"\"Set or get the camera hue *Arguments*: * hue (int): Set the camera hue. Valid values are in the range (-40..40) *Returns*: * hue (int): Get the camera hue \"\"\" self._update_camera_parameters() return self._camera_parameters.hue @hue.setter def hue(self, hue: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.hue = hue self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def resolution(self) -> int: \"\"\"Set or get the camera resolution *Arguments*: * resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 *Returns*: * resolution (int): Get the camera resolution \"\"\" self._update_camera_parameters() if self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_HD_720P: return 720 elif ( self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P ): return 1080 @resolution.setter def resolution(self, resolution: int): if resolution not in (720, 1080): raise ValueError( f\"{resolution} is not a valid resolution. Valid values are 720 or 1080\" ) if self._camera_parameters is None: self._update_camera_parameters() if resolution == 720: self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_HD_720P elif resolution == 1080: self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def framerate(self) -> int: \"\"\"Set or get the camera frame rate *Arguments*: * framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 *Returns*: * framerate (int): Get the camera frame rate \"\"\" self._update_camera_parameters() if self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_25: return 25 elif self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_30: return 30 @framerate.setter def framerate(self, framerate: int): if framerate not in (25, 30): raise ValueError(f\"{framerate} is not a valid framerate. Valid values are 25 or 30\") if self._camera_parameters is None: self._update_camera_parameters() if framerate == 25: self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_25 elif framerate == 30: self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_30 self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def record_time(self) -> Optional[int]: \"\"\"Set or get the duration of the current camera recording *Returns*: * record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording \"\"\" record_state = self._get_record_state() if record_state is None: return None if self._is_guestport_camera: return record_state.guestport_seconds else: return record_state.main_seconds def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. \"\"\" self._parent_drone._ctrl_client.take_still_picture()","title":"Module blueye.sdk.camera"},{"location":"reference/blueye/sdk/camera/#variables","text":"TYPE_CHECKING logger","title":"Variables"},{"location":"reference/blueye/sdk/camera/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/camera/#camera","text":"class Camera ( parent_drone : 'Drone' , is_guestport_camera : 'bool' = False ) View Source class Camera: def __init__(self, parent_drone: Drone, is_guestport_camera: bool = False): self._parent_drone = parent_drone self._is_guestport_camera = is_guestport_camera self._camera_type = ( blueye.protocol.Camera.CAMERA_GUESTPORT if is_guestport_camera else blueye.protocol.Camera.CAMERA_MAIN ) if not self._is_guestport_camera: self.tilt = Tilt(parent_drone) self.overlay = Overlay(parent_drone) self._camera_parameters = None def _get_record_state(self) -> Optional[blueye.protocol.RecordState]: record_state_tel = self._parent_drone.telemetry.get(blueye.protocol.RecordStateTel) if record_state_tel is not None: return record_state_tel.record_state else: return None def _update_camera_parameters(self): self._camera_parameters = self._parent_drone._req_rep_client.get_camera_parameters( camera=self._camera_type ) @property def is_recording(self) -> Optional[bool]: \"\"\"Get or set the camera recording state *Arguments*: * start_recording (bool): Set to True to start a recording, set to False to stop the current recording. *Returns*: * Recording state (bool): True if the camera is currently recording, False if not \"\"\" record_state = self._get_record_state() if record_state is None: return None if self._is_guestport_camera: return record_state.guestport_is_recording else: return record_state.main_is_recording @is_recording.setter def is_recording(self, start_recording: bool): record_state = self._get_record_state() if record_state is None: logger.warning(\"Unable to set recording state, no record state telemetry received\") return if self._is_guestport_camera: self._parent_drone._ctrl_client.set_recording_state( record_state.main_is_recording, start_recording ) else: self._parent_drone._ctrl_client.set_recording_state( start_recording, record_state.guestport_is_recording ) @property def bitrate(self) -> int: \"\"\"Set or get the video stream bitrate *Arguments*: * bitrate (int): Set the video stream bitrate in bits, valid values are in range (1 000 000..16 000 000) *Returns*: * bitrate (int): The H264 video stream bitrate \"\"\" self._update_camera_parameters() return self._camera_parameters.h264_bitrate @bitrate.setter def bitrate(self, bitrate: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.h264_bitrate = bitrate self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def bitrate_still_picture(self) -> int: \"\"\"Set or get the bitrate for the still picture stream *Arguments*: * bitrate (int): Set the still picture stream bitrate in bits, valid values are in range (1 000 000 .. 300 000 000). Default value is 100 000 000. *Returns*: * bitrate (int): The still picture stream bitrate \"\"\" self._update_camera_parameters() return self._camera_parameters.mjpg_bitrate @bitrate_still_picture.setter def bitrate_still_picture(self, bitrate: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.mjpg_bitrate = bitrate self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def exposure(self) -> int: \"\"\"Set or get the camera exposure *Arguments*: * exposure (int): Set the camera exposure time. Unit is thousandths of a second, ie. 5 = 5s/1000. Valid values are in the range (1 .. 5000) or -1 for auto exposure *Returns*: * exposure (int): Get the camera exposure \"\"\" self._update_camera_parameters() return self._camera_parameters.exposure @exposure.setter def exposure(self, exposure: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.exposure = exposure self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def whitebalance(self) -> int: \"\"\"Set or get the camera white balance *Arguments*: * white_balance (int): Set the camera white balance. Valid values are in the range (2800..9300) or -1 for auto white balance *Returns*: * white_balance (int): Get the camera white balance \"\"\" self._update_camera_parameters() return self._camera_parameters.white_balance @whitebalance.setter def whitebalance(self, white_balance: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.white_balance = white_balance self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def hue(self) -> int: \"\"\"Set or get the camera hue *Arguments*: * hue (int): Set the camera hue. Valid values are in the range (-40..40) *Returns*: * hue (int): Get the camera hue \"\"\" self._update_camera_parameters() return self._camera_parameters.hue @hue.setter def hue(self, hue: int): if self._camera_parameters is None: self._update_camera_parameters() self._camera_parameters.hue = hue self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def resolution(self) -> int: \"\"\"Set or get the camera resolution *Arguments*: * resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 *Returns*: * resolution (int): Get the camera resolution \"\"\" self._update_camera_parameters() if self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_HD_720P: return 720 elif ( self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P ): return 1080 @resolution.setter def resolution(self, resolution: int): if resolution not in (720, 1080): raise ValueError( f\"{resolution} is not a valid resolution. Valid values are 720 or 1080\" ) if self._camera_parameters is None: self._update_camera_parameters() if resolution == 720: self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_HD_720P elif resolution == 1080: self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def framerate(self) -> int: \"\"\"Set or get the camera frame rate *Arguments*: * framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 *Returns*: * framerate (int): Get the camera frame rate \"\"\" self._update_camera_parameters() if self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_25: return 25 elif self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_30: return 30 @framerate.setter def framerate(self, framerate: int): if framerate not in (25, 30): raise ValueError(f\"{framerate} is not a valid framerate. Valid values are 25 or 30\") if self._camera_parameters is None: self._update_camera_parameters() if framerate == 25: self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_25 elif framerate == 30: self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_30 self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters) @property def record_time(self) -> Optional[int]: \"\"\"Set or get the duration of the current camera recording *Returns*: * record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording \"\"\" record_state = self._get_record_state() if record_state is None: return None if self._is_guestport_camera: return record_state.guestport_seconds else: return record_state.main_seconds def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. \"\"\" self._parent_drone._ctrl_client.take_still_picture()","title":"Camera"},{"location":"reference/blueye/sdk/camera/#instance-variables","text":"bitrate Set or get the video stream bitrate Arguments : bitrate (int): Set the video stream bitrate in bits, valid values are in range (1 000 000..16 000 000) Returns : bitrate (int): The H264 video stream bitrate bitrate_still_picture Set or get the bitrate for the still picture stream Arguments : bitrate (int): Set the still picture stream bitrate in bits, valid values are in range (1 000 000 .. 300 000 000). Default value is 100 000 000. Returns : bitrate (int): The still picture stream bitrate exposure Set or get the camera exposure Arguments : exposure (int): Set the camera exposure time. Unit is thousandths of a second, ie. 5 = 5s/1000. Valid values are in the range (1 .. 5000) or -1 for auto exposure Returns : exposure (int): Get the camera exposure framerate Set or get the camera frame rate Arguments : framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 Returns : framerate (int): Get the camera frame rate hue Set or get the camera hue Arguments : hue (int): Set the camera hue. Valid values are in the range (-40..40) Returns : hue (int): Get the camera hue is_recording Get or set the camera recording state Arguments : start_recording (bool): Set to True to start a recording, set to False to stop the current recording. Returns : Recording state (bool): True if the camera is currently recording, False if not record_time Set or get the duration of the current camera recording Returns : record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording resolution Set or get the camera resolution Arguments : resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 Returns : resolution (int): Get the camera resolution whitebalance Set or get the camera white balance Arguments : white_balance (int): Set the camera white balance. Valid values are in the range (2800..9300) or -1 for auto white balance Returns : white_balance (int): Get the camera white balance","title":"Instance variables"},{"location":"reference/blueye/sdk/camera/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/camera/#take_picture","text":"def take_picture ( self ) Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. View Source def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. \"\"\" self._parent_drone._ctrl_client.take_still_picture()","title":"take_picture"},{"location":"reference/blueye/sdk/camera/#overlay","text":"class Overlay ( parent_drone : 'Drone' ) Control the overlay on videos and pictures View Source class Overlay: \"\"\"Control the overlay on videos and pictures\"\"\" def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone self._overlay_parametres = None def _update_overlay_parameters(self): self._overlay_parametres = self._parent_drone._req_rep_client.get_overlay_parameters() @property def temperature_enabled(self) -> bool: \"\"\"Get or set the state of the temperature overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.temperature_enabled @temperature_enabled.setter def temperature_enabled(self, enable_temperature: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.temperature_enabled = enable_temperature self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def depth_enabled(self) -> bool: \"\"\"Get or set the state of the depth overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.depth_enabled @depth_enabled.setter def depth_enabled(self, enable_depth: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.depth_enabled = enable_depth self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def heading_enabled(self) -> bool: \"\"\"Get or set the state of the heading overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.heading_enabled @heading_enabled.setter def heading_enabled(self, enable_heading: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.heading_enabled = enable_heading self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def tilt_enabled(self) -> bool: \"\"\"Get or set the state of the tilt overlay\"\"\" self._update_overlay_parameters() return self._overlay_parametres.tilt_enabled @tilt_enabled.setter def tilt_enabled(self, enable_tilt: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.tilt_enabled = enable_tilt self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def date_enabled(self) -> bool: \"\"\"Get or set the state of the date overlay\"\"\" if self._overlay_parametres is None: self._update_overlay_parameters() return self._overlay_parametres.date_enabled @date_enabled.setter def date_enabled(self, enable_date: bool): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.date_enabled = enable_date self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def logo(self) -> blueye.protcol.LogoType: \"\"\"Get or set logo overlay selection Needs to be set to an instance of the `blueye.protocol.LogoType` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.logo_type @logo.setter def logo(self, logo_type: blueye.protocol.LogoType): if not isinstance(logo_type, blueye.protocol.LogoType): warnings.warn(\"Invalid logo type, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.logo_type = logo_type self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def depth_unit(self) -> blueye.protocol.DepthUnit: \"\"\"Get or set the depth unit for the overlay Needs to be set to an instance of the `blueye.protocol.DepthUnit` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.depth_unit @depth_unit.setter def depth_unit(self, unit: blueye.protocol.DepthUnit): if not isinstance(unit, blueye.protocol.DepthUnit): warnings.warn(\"Invalid depth unit, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.depth_unit = unit self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def temperature_unit(self) -> blueye.protocol.TemperatureUnit: \"\"\"Get or set the temperature unit for the overlay Needs to be set to an instance of the `blueye.protocol.TemperatureUnit` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.temperature_unit @temperature_unit.setter def temperature_unit(self, unit: blueye.protocol.TemperatureUnit): if not isinstance(unit, blueye.protocol.TemperatureUnit): warnings.warn(\"Invalid temperature unit, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.temperature_unit = unit self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def timezone_offset(self) -> int: \"\"\"Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.timezone_offset @timezone_offset.setter def timezone_offset(self, offset: int): if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.timezone_offset = offset self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def margin_width(self) -> int: \"\"\"Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.margin_width @margin_width.setter def margin_width(self, width: int): if width < 0: warnings.warn(\"Invalid margin width, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.margin_width = width self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def margin_height(self) -> int: \"\"\"Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.margin_height @margin_height.setter def margin_height(self, height: int): if height < 0: warnings.warn(\"Invalid margin height, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.margin_height = height self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def font_size(self) -> blueye.protocol.FontSize: \"\"\"Get or set the font size for the overlay Needs to be an instance of the `blueye.protocol.Fontsize` enum, if not a RuntimeWarning is raised. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.font_size @font_size.setter def font_size(self, size: blueye.protocol.FontSize): if not isinstance(size, blueye.protocol.FontSize): warnings.warn(\"Invalid font size, ignoring\", RuntimeWarning) else: if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.font_size = size self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def title(self) -> str: \"\"\"Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.title @title.setter def title(self, input_title: str): new_title = input_title if len(input_title) > 63: warnings.warn(\"Too long title, truncating to 63 characters\", RuntimeWarning) new_title = new_title[:63] try: bytes(new_title, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Title can only contain ASCII characters, ignoring\", RuntimeWarning) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.title = new_title self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def subtitle(self) -> str: \"\"\"Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.subtitle @subtitle.setter def subtitle(self, input_subtitle: str): new_subtitle = input_subtitle if len(input_subtitle) > 63: warnings.warn(\"Too long subtitle, truncating to 63 characters\", RuntimeWarning) new_subtitle = new_subtitle[:63] try: bytes(new_subtitle, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Subtitle can only contain ASCII characters, ignoring\", RuntimeWarning) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.subtitle = new_subtitle self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) @property def date_format(self) -> str: \"\"\"Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. \"\"\" self._update_overlay_parameters() return self._overlay_parametres.date_format @date_format.setter def date_format(self, input_format_str: str): format_str = input_format_str if len(format_str) > 63: warnings.warn( \"Too long date format string, truncating to 63 characters\", RuntimeWarning ) format_str = format_str[:63] try: bytes(format_str, \"ascii\") except UnicodeEncodeError: warnings.warn( \"Date format string can only contain ASCII characters, ignoring\", RuntimeWarning ) return if self._overlay_parametres is None: self._update_overlay_parameters() self._overlay_parametres.date_format = format_str self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres) def upload_logo(self, path_to_logo: str, timeout: float = 1.0): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `blueye.protocol.LogoType.LOG_TYPE_CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=timeout) response.raise_for_status() def download_logo(self, output_directory=\".\", timeout: float = 1.0): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content) def delete_logo(self, timeout: float = 1.0): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status()","title":"Overlay"},{"location":"reference/blueye/sdk/camera/#instance-variables_1","text":"date_enabled Get or set the state of the date overlay date_format Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. depth_enabled Get or set the state of the depth overlay depth_unit Get or set the depth unit for the overlay Needs to be set to an instance of the blueye.protocol.DepthUnit enum, if not a RuntimeWarning is raised. font_size Get or set the font size for the overlay Needs to be an instance of the blueye.protocol.Fontsize enum, if not a RuntimeWarning is raised. heading_enabled Get or set the state of the heading overlay logo Get or set logo overlay selection Needs to be set to an instance of the blueye.protocol.LogoType enum, if not a RuntimeWarning is raised. margin_height Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. margin_width Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. subtitle Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. temperature_enabled Get or set the state of the temperature overlay temperature_unit Get or set the temperature unit for the overlay Needs to be set to an instance of the blueye.protocol.TemperatureUnit enum, if not a RuntimeWarning is raised. tilt_enabled Get or set the state of the tilt overlay timezone_offset Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. title Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title.","title":"Instance variables"},{"location":"reference/blueye/sdk/camera/#methods_1","text":"","title":"Methods"},{"location":"reference/blueye/sdk/camera/#delete_logo","text":"def delete_logo ( self , timeout : 'float' = 1.0 ) Delete the user uploaded logo from the drone Exceptions : requests.exceptions.HTTPError : If an error occurs during deletion requests.exceptions.ConnectTimeout : If unable to create a connection within specified timeout (default 1s) View Source def delete_logo(self, timeout: float = 1.0): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status()","title":"delete_logo"},{"location":"reference/blueye/sdk/camera/#download_logo","text":"def download_logo ( self , output_directory = '.' , timeout : 'float' = 1.0 ) Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. Exceptions : requests.exceptions.HTTPError : If no custom logo is uploaded. requests.exceptions.ConnectTimeout : If unable to create a connection within specified timeout (default 1s) View Source def download_logo(self, output_directory=\".\", timeout: float = 1.0): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content)","title":"download_logo"},{"location":"reference/blueye/sdk/camera/#upload_logo","text":"def upload_logo ( self , path_to_logo : 'str' , timeout : 'float' = 1.0 ) Upload user selectable logo for watermarking videos and pictures Set the logo-property to blueye.protocol.LogoType.LOG_TYPE_CUSTOM to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. Exceptions : requests.exceptions.HTTPError : Status code 400 for invalid files requests.exceptions.ConnectTimeout : If unable to create a connection within specified timeout (default 1s) View Source def upload_logo(self, path_to_logo: str, timeout: float = 1.0): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `blueye.protocol.LogoType.LOG_TYPE_CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified timeout (default 1s) \"\"\" with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=timeout) response.raise_for_status()","title":"upload_logo"},{"location":"reference/blueye/sdk/camera/#tilt","text":"class Tilt ( parent_drone : 'Drone' ) View Source class Tilt: def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def _verify_tilt_in_features(self): \"\"\"Checks that the connected drone has the tilt feature Raises a RuntimeError if it does not. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") def set_velocity(self, velocity: float): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Raises a RuntimeError if the connected drone does not have the tilt option \"\"\" self._verify_tilt_in_features() self._parent_drone._ctrl_client.set_tilt_velocity(velocity) @property def angle(self) -> Optional[float]: \"\"\"Return the current angle of the camera tilt Raises a RuntimeError if the connected drone does not have the tilt option \"\"\" self._verify_tilt_in_features() tilt_angle_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltAngleTel) if tilt_angle_tel is not None: return tilt_angle_tel.angle.value else: return None @property def stabilization_enabled(self) -> Optional[bool]: \"\"\"Get or set the state of active camera stabilization *Arguments*: * enabled (bool): True to turn stabilization on, False to turn it off *Returns*: * enabled (bool): Current state of active camera stabilization \"\"\" self._verify_tilt_in_features() tilt_stab_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltStabilizationTel) if tilt_stab_tel is not None: return tilt_stab_tel.state.enabled else: return None @stabilization_enabled.setter def stabilization_enabled(self, enabled: bool): self._verify_tilt_in_features() self._parent_drone._ctrl_client.set_tilt_stabilization(enabled)","title":"Tilt"},{"location":"reference/blueye/sdk/camera/#instance-variables_2","text":"angle Return the current angle of the camera tilt Raises a RuntimeError if the connected drone does not have the tilt option stabilization_enabled Get or set the state of active camera stabilization Arguments : enabled (bool): True to turn stabilization on, False to turn it off Returns : enabled (bool): Current state of active camera stabilization","title":"Instance variables"},{"location":"reference/blueye/sdk/camera/#methods_2","text":"","title":"Methods"},{"location":"reference/blueye/sdk/camera/#set_velocity","text":"def set_velocity ( self , velocity : 'float' ) Set the speed and direction of the camera tilt Arguments : velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Raises a RuntimeError if the connected drone does not have the tilt option View Source def set_velocity(self, velocity: float): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Raises a RuntimeError if the connected drone does not have the tilt option \"\"\" self._verify_tilt_in_features() self._parent_drone._ctrl_client.set_tilt_velocity(velocity)","title":"set_velocity"},{"location":"reference/blueye/sdk/connection/","text":"Module blueye.sdk.connection View Source from __future__ import annotations import importlib.metadata import logging import platform import queue import threading import uuid from typing import Callable, Dict, List, NamedTuple, Tuple import blueye.protocol import proto import zmq logger = logging.getLogger(__name__) class WatchdogPublisher(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._parent_drone = parent_drone self._context = context or zmq.Context().instance() self._socket = self._context.socket(zmq.PUB) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5557\") self._exit_flag = threading.Event() def run(self): duration = 0 WATCHDOG_DELAY = 1 while not self._exit_flag.wait(WATCHDOG_DELAY): self.pet_watchdog(duration) duration += 1 def pet_watchdog(self, duration): msg = blueye.protocol.WatchdogCtrl( connection_duration={\"value\": duration}, client_id=self._parent_drone.client_id ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), blueye.protocol.WatchdogCtrl.serialize(msg), ] ) def stop(self): \"\"\"Stop the watchdog thread started by run()\"\"\" self._exit_flag.set() class Callback(NamedTuple): \"\"\"Specifications for callback for telemetry messages\"\"\" message_filter: List[proto.messages.Message] function: Callable[[str, proto.message.Message], None] pass_raw_data: bool uuid_hex: str class TelemetryClient(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._parent_drone = parent_drone self._context = context or zmq.Context().instance() self._socket = self._context.socket(zmq.SUB) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5555\") self._socket.setsockopt_string(zmq.SUBSCRIBE, \"\") self._exit_flag = threading.Event() self._state_lock = threading.Lock() self._callbacks: List[Callback] = [] self._state: Dict[proto.message.Message, bytes] = {} \"\"\"`_state` is dictionary of the latest received messages, where the key is the protobuf message class, eg. blueye.protocol.DepthTel and the value is the serialized protobuf message\"\"\" def _handle_message(self, msg: Tuple[bytes, bytes]): msg_type_name = msg[0].decode(\"utf-8\").replace(\"blueye.protocol.\", \"\") try: msg_type = blueye.protocol.__getattribute__(msg_type_name) except AttributeError: # If a new telemetry message is introduced before the SDK is updated this can # be a common occurence, so choosing to log with info instead of warning logger.info(f\"Ignoring unknown message type: {msg_type_name}\") return msg_payload = msg[1] with self._state_lock: self._state[msg_type] = msg_payload for callback in self._callbacks: if msg_type in callback.message_filter or callback.message_filter == []: if callback.pass_raw_data: callback.function(msg_type_name, msg_payload) else: msg_deserialized = msg_type.deserialize(msg_payload) callback.function(msg_type_name, msg_deserialized) def run(self): poller = zmq.Poller() poller.register(self._socket, zmq.POLLIN) while not self._exit_flag.is_set(): events_to_be_processed = poller.poll(10) if len(events_to_be_processed) > 0: msg = self._socket.recv_multipart() self._handle_message(msg) def add_callback( self, msg_filter: List[proto.message.Message], callback_function: Callable[[str, proto.message.Message], None], raw: bool, ): uuid_hex = uuid.uuid1().hex self._callbacks.append(Callback(msg_filter, callback_function, raw, uuid_hex)) return uuid_hex def remove_callback(self, callback_id): try: self._callbacks.pop([cb.uuid_hex for cb in self._callbacks].index(callback_id)) except ValueError: logger.warning(f\"Callback with id {callback_id} not found, ignoring\") def get(self, key: proto.message.Message): with self._state_lock: return self._state[key] def stop(self): self._exit_flag.set() class CtrlClient(threading.Thread): def __init__( self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None, ): super().__init__(daemon=True) self._context = context or zmq.Context().instance() self._parent_drone = parent_drone self._drone_pub_socket = self._context.socket(zmq.PUB) self._drone_pub_socket.connect(f\"tcp://{self._parent_drone._ip}:5557\") self._messages_to_send = queue.Queue() self._exit_flag = threading.Event() def run(self): while not self._exit_flag.is_set(): try: msg = self._messages_to_send.get(timeout=0.1) self._drone_pub_socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No messages to send, so we can continue def stop(self): self._exit_flag.set() def set_lights(self, value: float): msg = blueye.protocol.LightsCtrl(lights={\"value\": value}) self._messages_to_send.put(msg) def set_water_density(self, value: float): msg = blueye.protocol.WaterDensityCtrl(density={\"value\": value}) self._messages_to_send.put(msg) def set_tilt_velocity(self, value: float): msg = blueye.protocol.TiltVelocityCtrl(velocity={\"value\": value}) self._messages_to_send.put(msg) def set_tilt_stabilization(self, enabled: bool): msg = blueye.protocol.TiltStabilizationCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_motion_input( self, surge: float, sway: float, heave: float, yaw: float, slow: float, boost: float ): msg = blueye.protocol.MotionInputCtrl( motion_input={ \"surge\": surge, \"sway\": sway, \"heave\": heave, \"yaw\": yaw, \"slow\": slow, \"boost\": boost, } ) self._messages_to_send.put(msg) def set_auto_depth_state(self, enabled: bool): msg = blueye.protocol.AutoDepthCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_auto_heading_state(self, enabled: bool): msg = blueye.protocol.AutoHeadingCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_recording_state(self, main_enabled: bool, guestport_enabled: bool): msg = blueye.protocol.RecordCtrl( record_on={\"main\": main_enabled, \"guestport\": guestport_enabled} ) self._messages_to_send.put(msg) def take_still_picture(self): msg = blueye.protocol.TakePictureCtrl() self._messages_to_send.put(msg) class ReqRepClient(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._context = context or zmq.Context().instance() self._parent_drone = parent_drone self._socket = self._context.socket(zmq.REQ) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5556\") self._requests_to_send = queue.Queue() self._exit_flag = threading.Event() @staticmethod def _get_client_info() -> blueye.protocol.ClientInfo: client_info = blueye.protocol.ClientInfo( type=\"SDK\", version=f\"{importlib.metadata.version('blueye.sdk')}\", device_type=\"Computer\", platform=f\"{platform.system()}\", platform_version=f\"{platform.release()}\", name=f\"{platform.node()}\", ) return client_info def run(self): while not self._exit_flag.is_set(): try: msg, response_type, response_callback_queue = self._requests_to_send.get( timeout=0.1 ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No requests to send, so we can continue # TODO: Deal with timeout resp = self._socket.recv_multipart() resp_deserialized = response_type.deserialize(resp[1]) response_callback_queue.put(resp_deserialized) def stop(self): self._exit_flag.set() def _send_request_get_response( self, request: proto.message.Message, expected_response: proto.message.Message, timeout: float, ): response_queue = queue.Queue(maxsize=1) self._requests_to_send.put((request, expected_response, response_queue)) try: return response_queue.get(timeout=timeout) except queue.Empty: raise blueye.protocol.exceptions.ResponseTimeout( \"No response received from drone before timeout\" ) def ping(self, timeout: float) -> blueye.protocol.PingRep: request = blueye.protocol.PingReq() return self._send_request_get_response(request, blueye.protocol.PingRep, timeout) def get_camera_parameters( self, camera: blueye.protocol.Camera, timeout: float = 0.05 ) -> blueye.protocol.CameraParameters: request = blueye.protocol.GetCameraParametersReq(camera=camera) response = self._send_request_get_response( request, blueye.protocol.GetCameraParametersRep, timeout ) return response.camera_parameters def set_camera_parameters( self, parameters: blueye.protocol.CameraParameters, timeout: float = 0.05, ): request = blueye.protocol.SetCameraParametersReq(camera_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetCameraParametersRep, timeout ) def get_overlay_parameters(self, timeout: float = 0.05) -> blueye.protocol.OverlayParameters: request = blueye.protocol.GetOverlayParametersReq() response = self._send_request_get_response( request, blueye.protocol.GetOverlayParametersRep, timeout ) return response.overlay_parameters def set_overlay_parameters( self, parameters: blueye.protocol.OverlayParameters, timeout: float = 0.05 ): request = blueye.protocol.SetOverlayParametersReq(overlay_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetOverlayParametersRep, timeout ) def sync_time(self, time: int, timeout: float = 0.05): request = blueye.protocol.SyncTimeReq( time={\"unix_timestamp\": {\"seconds\": time, \"nanos\": 0}} ) return self._send_request_get_response(request, blueye.protocol.SyncTimeRep, timeout) def connect_client( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 0.05 ) -> blueye.protocol.ConnectClientRep: client = client_info or self._get_client_info() request = blueye.protocol.ConnectClientReq(client_info=client) return self._send_request_get_response(request, blueye.protocol.ConnectClientRep, timeout) def disconnect_client( self, client_id: int, timeout: float = 0.05 ) -> blueye.protocol.DisconnectClientRep: request = blueye.protocol.DisconnectClientReq(client_id=client_id) return self._send_request_get_response( request, blueye.protocol.DisconnectClientRep, timeout ) def set_telemetry_msg_publish_frequency( self, msg: proto.message.Message | str, frequency: float, timeout: float = 0.05 ) -> blueye.protocol.SetPubFrequencyRep: message_type = ( msg.meta.full_name.replace(\"blueye.protocol.\", \"\") if type(msg) in [proto.message.Message, proto.message.MessageMeta] else msg.replace(\"blueye.protocol.\", \"\") ) request = blueye.protocol.SetPubFrequencyReq( message_type=message_type, frequency=frequency, ) return self._send_request_get_response(request, blueye.protocol.SetPubFrequencyRep, timeout) Variables logger Classes Callback class Callback ( / , * args , ** kwargs ) Specifications for callback for telemetry messages View Source class Callback(NamedTuple): \"\"\"Specifications for callback for telemetry messages\"\"\" message_filter: List[proto.messages.Message] function: Callable[[str, proto.message.Message], None] pass_raw_data: bool uuid_hex: str Ancestors (in MRO) builtins.tuple Class variables function message_filter pass_raw_data uuid_hex Methods count def count ( self , value , / ) Return number of occurrences of value. index def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present. CtrlClient class CtrlClient ( parent_drone : \"'blueye.sdk.Drone'\" , context : 'zmq.Context' = None ) A class that represents a thread of control. This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass. View Source class CtrlClient(threading.Thread): def __init__( self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None, ): super().__init__(daemon=True) self._context = context or zmq.Context().instance() self._parent_drone = parent_drone self._drone_pub_socket = self._context.socket(zmq.PUB) self._drone_pub_socket.connect(f\"tcp://{self._parent_drone._ip}:5557\") self._messages_to_send = queue.Queue() self._exit_flag = threading.Event() def run(self): while not self._exit_flag.is_set(): try: msg = self._messages_to_send.get(timeout=0.1) self._drone_pub_socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No messages to send, so we can continue def stop(self): self._exit_flag.set() def set_lights(self, value: float): msg = blueye.protocol.LightsCtrl(lights={\"value\": value}) self._messages_to_send.put(msg) def set_water_density(self, value: float): msg = blueye.protocol.WaterDensityCtrl(density={\"value\": value}) self._messages_to_send.put(msg) def set_tilt_velocity(self, value: float): msg = blueye.protocol.TiltVelocityCtrl(velocity={\"value\": value}) self._messages_to_send.put(msg) def set_tilt_stabilization(self, enabled: bool): msg = blueye.protocol.TiltStabilizationCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_motion_input( self, surge: float, sway: float, heave: float, yaw: float, slow: float, boost: float ): msg = blueye.protocol.MotionInputCtrl( motion_input={ \"surge\": surge, \"sway\": sway, \"heave\": heave, \"yaw\": yaw, \"slow\": slow, \"boost\": boost, } ) self._messages_to_send.put(msg) def set_auto_depth_state(self, enabled: bool): msg = blueye.protocol.AutoDepthCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_auto_heading_state(self, enabled: bool): msg = blueye.protocol.AutoHeadingCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_recording_state(self, main_enabled: bool, guestport_enabled: bool): msg = blueye.protocol.RecordCtrl( record_on={\"main\": main_enabled, \"guestport\": guestport_enabled} ) self._messages_to_send.put(msg) def take_still_picture(self): msg = blueye.protocol.TakePictureCtrl() self._messages_to_send.put(msg) Ancestors (in MRO) threading.Thread Instance variables daemon A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. ident Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. name A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. native_id Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Methods getName def getName ( self ) Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. View Source def getName(self): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('getName() is deprecated, get the name attribute instead', DeprecationWarning, stacklevel=2) return self.name isDaemon def isDaemon ( self ) Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. View Source def isDaemon(self): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings.warn('isDaemon() is deprecated, get the daemon attribute instead', DeprecationWarning, stacklevel=2) return self.daemon is_alive def is_alive ( self ) Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). View Source def is_alive(self): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self._initialized, \"Thread.__init__() not called\" if self._is_stopped or not self._started.is_set(): return False self._wait_for_tstate_lock(False) return not self._is_stopped join def join ( self , timeout = None ) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. View Source def join(self, timeout=None): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self._initialized: raise RuntimeError(\"Thread.__init__() not called\") if not self._started.is_set(): raise RuntimeError(\"cannot join thread before it is started\") if self is current_thread(): raise RuntimeError(\"cannot join current thread\") if timeout is None: self._wait_for_tstate_lock() else: # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self._wait_for_tstate_lock(timeout=max(timeout, 0)) run def run ( self ) Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. View Source def run(self): while not self._exit_flag.is_set(): try: msg = self._messages_to_send.get(timeout=0.1) self._drone_pub_socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No messages to send, so we can continue setDaemon def setDaemon ( self , daemonic ) Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. View Source def setDaemon(self, daemonic): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings.warn('setDaemon() is deprecated, set the daemon attribute instead', DeprecationWarning, stacklevel=2) self.daemon = daemonic setName def setName ( self , name ) Set the name string for this thread. This method is deprecated, use the name attribute instead. View Source def setName(self, name): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('setName() is deprecated, set the name attribute instead', DeprecationWarning, stacklevel=2) self.name = name set_auto_depth_state def set_auto_depth_state ( self , enabled : 'bool' ) View Source def set_auto_depth_state(self, enabled: bool): msg = blueye.protocol.AutoDepthCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) set_auto_heading_state def set_auto_heading_state ( self , enabled : 'bool' ) View Source def set_auto_heading_state(self, enabled: bool): msg = blueye.protocol.AutoHeadingCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) set_lights def set_lights ( self , value : 'float' ) View Source def set_lights(self, value: float): msg = blueye.protocol.LightsCtrl(lights={\"value\": value}) self._messages_to_send.put(msg) set_motion_input def set_motion_input ( self , surge : 'float' , sway : 'float' , heave : 'float' , yaw : 'float' , slow : 'float' , boost : 'float' ) View Source def set_motion_input( self, surge: float, sway: float, heave: float, yaw: float, slow: float, boost: float ): msg = blueye.protocol.MotionInputCtrl( motion_input={ \"surge\": surge, \"sway\": sway, \"heave\": heave, \"yaw\": yaw, \"slow\": slow, \"boost\": boost, } ) self._messages_to_send.put(msg) set_recording_state def set_recording_state ( self , main_enabled : 'bool' , guestport_enabled : 'bool' ) View Source def set_recording_state(self, main_enabled: bool, guestport_enabled: bool): msg = blueye.protocol.RecordCtrl( record_on={\"main\": main_enabled, \"guestport\": guestport_enabled} ) self._messages_to_send.put(msg) set_tilt_stabilization def set_tilt_stabilization ( self , enabled : 'bool' ) View Source def set_tilt_stabilization(self, enabled: bool): msg = blueye.protocol.TiltStabilizationCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) set_tilt_velocity def set_tilt_velocity ( self , value : 'float' ) View Source def set_tilt_velocity(self, value: float): msg = blueye.protocol.TiltVelocityCtrl(velocity={\"value\": value}) self._messages_to_send.put(msg) set_water_density def set_water_density ( self , value : 'float' ) View Source def set_water_density(self, value: float): msg = blueye.protocol.WaterDensityCtrl(density={\"value\": value}) self._messages_to_send.put(msg) start def start ( self ) Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. View Source def start(self): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait() stop def stop ( self ) View Source def stop(self): self._exit_flag.set() take_still_picture def take_still_picture ( self ) View Source def take_still_picture(self): msg = blueye.protocol.TakePictureCtrl() self._messages_to_send.put(msg) ReqRepClient class ReqRepClient ( parent_drone : \"'blueye.sdk.Drone'\" , context : 'zmq.Context' = None ) A class that represents a thread of control. This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass. View Source class ReqRepClient(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._context = context or zmq.Context().instance() self._parent_drone = parent_drone self._socket = self._context.socket(zmq.REQ) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5556\") self._requests_to_send = queue.Queue() self._exit_flag = threading.Event() @staticmethod def _get_client_info() -> blueye.protocol.ClientInfo: client_info = blueye.protocol.ClientInfo( type=\"SDK\", version=f\"{importlib.metadata.version('blueye.sdk')}\", device_type=\"Computer\", platform=f\"{platform.system()}\", platform_version=f\"{platform.release()}\", name=f\"{platform.node()}\", ) return client_info def run(self): while not self._exit_flag.is_set(): try: msg, response_type, response_callback_queue = self._requests_to_send.get( timeout=0.1 ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No requests to send, so we can continue # TODO: Deal with timeout resp = self._socket.recv_multipart() resp_deserialized = response_type.deserialize(resp[1]) response_callback_queue.put(resp_deserialized) def stop(self): self._exit_flag.set() def _send_request_get_response( self, request: proto.message.Message, expected_response: proto.message.Message, timeout: float, ): response_queue = queue.Queue(maxsize=1) self._requests_to_send.put((request, expected_response, response_queue)) try: return response_queue.get(timeout=timeout) except queue.Empty: raise blueye.protocol.exceptions.ResponseTimeout( \"No response received from drone before timeout\" ) def ping(self, timeout: float) -> blueye.protocol.PingRep: request = blueye.protocol.PingReq() return self._send_request_get_response(request, blueye.protocol.PingRep, timeout) def get_camera_parameters( self, camera: blueye.protocol.Camera, timeout: float = 0.05 ) -> blueye.protocol.CameraParameters: request = blueye.protocol.GetCameraParametersReq(camera=camera) response = self._send_request_get_response( request, blueye.protocol.GetCameraParametersRep, timeout ) return response.camera_parameters def set_camera_parameters( self, parameters: blueye.protocol.CameraParameters, timeout: float = 0.05, ): request = blueye.protocol.SetCameraParametersReq(camera_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetCameraParametersRep, timeout ) def get_overlay_parameters(self, timeout: float = 0.05) -> blueye.protocol.OverlayParameters: request = blueye.protocol.GetOverlayParametersReq() response = self._send_request_get_response( request, blueye.protocol.GetOverlayParametersRep, timeout ) return response.overlay_parameters def set_overlay_parameters( self, parameters: blueye.protocol.OverlayParameters, timeout: float = 0.05 ): request = blueye.protocol.SetOverlayParametersReq(overlay_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetOverlayParametersRep, timeout ) def sync_time(self, time: int, timeout: float = 0.05): request = blueye.protocol.SyncTimeReq( time={\"unix_timestamp\": {\"seconds\": time, \"nanos\": 0}} ) return self._send_request_get_response(request, blueye.protocol.SyncTimeRep, timeout) def connect_client( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 0.05 ) -> blueye.protocol.ConnectClientRep: client = client_info or self._get_client_info() request = blueye.protocol.ConnectClientReq(client_info=client) return self._send_request_get_response(request, blueye.protocol.ConnectClientRep, timeout) def disconnect_client( self, client_id: int, timeout: float = 0.05 ) -> blueye.protocol.DisconnectClientRep: request = blueye.protocol.DisconnectClientReq(client_id=client_id) return self._send_request_get_response( request, blueye.protocol.DisconnectClientRep, timeout ) def set_telemetry_msg_publish_frequency( self, msg: proto.message.Message | str, frequency: float, timeout: float = 0.05 ) -> blueye.protocol.SetPubFrequencyRep: message_type = ( msg.meta.full_name.replace(\"blueye.protocol.\", \"\") if type(msg) in [proto.message.Message, proto.message.MessageMeta] else msg.replace(\"blueye.protocol.\", \"\") ) request = blueye.protocol.SetPubFrequencyReq( message_type=message_type, frequency=frequency, ) return self._send_request_get_response(request, blueye.protocol.SetPubFrequencyRep, timeout) Ancestors (in MRO) threading.Thread Instance variables daemon A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. ident Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. name A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. native_id Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Methods connect_client def connect_client ( self , client_info : 'blueye.protocol.ClientInfo' = None , timeout : 'float' = 0.05 ) -> 'blueye.protocol.ConnectClientRep' View Source def connect_client( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 0.05 ) -> blueye.protocol.ConnectClientRep: client = client_info or self._get_client_info() request = blueye.protocol.ConnectClientReq(client_info=client) return self._send_request_get_response(request, blueye.protocol.ConnectClientRep, timeout) disconnect_client def disconnect_client ( self , client_id : 'int' , timeout : 'float' = 0.05 ) -> 'blueye.protocol.DisconnectClientRep' View Source def disconnect_client( self, client_id: int, timeout: float = 0.05 ) -> blueye.protocol.DisconnectClientRep: request = blueye.protocol.DisconnectClientReq(client_id=client_id) return self._send_request_get_response( request, blueye.protocol.DisconnectClientRep, timeout ) getName def getName ( self ) Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. View Source def getName(self): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('getName() is deprecated, get the name attribute instead', DeprecationWarning, stacklevel=2) return self.name get_camera_parameters def get_camera_parameters ( self , camera : 'blueye.protocol.Camera' , timeout : 'float' = 0.05 ) -> 'blueye.protocol.CameraParameters' View Source def get_camera_parameters( self, camera: blueye.protocol.Camera, timeout: float = 0.05 ) -> blueye.protocol.CameraParameters: request = blueye.protocol.GetCameraParametersReq(camera=camera) response = self._send_request_get_response( request, blueye.protocol.GetCameraParametersRep, timeout ) return response.camera_parameters get_overlay_parameters def get_overlay_parameters ( self , timeout : 'float' = 0.05 ) -> 'blueye.protocol.OverlayParameters' View Source def get_overlay_parameters(self, timeout: float = 0.05) -> blueye.protocol.OverlayParameters: request = blueye.protocol.GetOverlayParametersReq() response = self._send_request_get_response( request, blueye.protocol.GetOverlayParametersRep, timeout ) return response.overlay_parameters isDaemon def isDaemon ( self ) Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. View Source def isDaemon(self): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings.warn('isDaemon() is deprecated, get the daemon attribute instead', DeprecationWarning, stacklevel=2) return self.daemon is_alive def is_alive ( self ) Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). View Source def is_alive(self): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self._initialized, \"Thread.__init__() not called\" if self._is_stopped or not self._started.is_set(): return False self._wait_for_tstate_lock(False) return not self._is_stopped join def join ( self , timeout = None ) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. View Source def join(self, timeout=None): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self._initialized: raise RuntimeError(\"Thread.__init__() not called\") if not self._started.is_set(): raise RuntimeError(\"cannot join thread before it is started\") if self is current_thread(): raise RuntimeError(\"cannot join current thread\") if timeout is None: self._wait_for_tstate_lock() else: # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self._wait_for_tstate_lock(timeout=max(timeout, 0)) ping def ping ( self , timeout : 'float' ) -> 'blueye.protocol.PingRep' View Source def ping(self, timeout: float) -> blueye.protocol.PingRep: request = blueye.protocol.PingReq() return self._send_request_get_response(request, blueye.protocol.PingRep, timeout) run def run ( self ) Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. View Source def run(self): while not self._exit_flag.is_set(): try: msg, response_type, response_callback_queue = self._requests_to_send.get( timeout=0.1 ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No requests to send, so we can continue # TODO: Deal with timeout resp = self._socket.recv_multipart() resp_deserialized = response_type.deserialize(resp[1]) response_callback_queue.put(resp_deserialized) setDaemon def setDaemon ( self , daemonic ) Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. View Source def setDaemon(self, daemonic): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings.warn('setDaemon() is deprecated, set the daemon attribute instead', DeprecationWarning, stacklevel=2) self.daemon = daemonic setName def setName ( self , name ) Set the name string for this thread. This method is deprecated, use the name attribute instead. View Source def setName(self, name): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('setName() is deprecated, set the name attribute instead', DeprecationWarning, stacklevel=2) self.name = name set_camera_parameters def set_camera_parameters ( self , parameters : 'blueye.protocol.CameraParameters' , timeout : 'float' = 0.05 ) View Source def set_camera_parameters( self, parameters: blueye.protocol.CameraParameters, timeout: float = 0.05, ): request = blueye.protocol.SetCameraParametersReq(camera_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetCameraParametersRep, timeout ) set_overlay_parameters def set_overlay_parameters ( self , parameters : 'blueye.protocol.OverlayParameters' , timeout : 'float' = 0.05 ) View Source def set_overlay_parameters( self, parameters: blueye.protocol.OverlayParameters, timeout: float = 0.05 ): request = blueye.protocol.SetOverlayParametersReq(overlay_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetOverlayParametersRep, timeout ) set_telemetry_msg_publish_frequency def set_telemetry_msg_publish_frequency ( self , msg : 'proto.message.Message | str' , frequency : 'float' , timeout : 'float' = 0.05 ) -> 'blueye.protocol.SetPubFrequencyRep' View Source def set_telemetry_msg_publish_frequency( self, msg: proto.message.Message | str, frequency: float, timeout: float = 0.05 ) -> blueye.protocol.SetPubFrequencyRep: message_type = ( msg.meta.full_name.replace(\"blueye.protocol.\", \"\") if type(msg) in [proto.message.Message, proto.message.MessageMeta] else msg.replace(\"blueye.protocol.\", \"\") ) request = blueye.protocol.SetPubFrequencyReq( message_type=message_type, frequency=frequency, ) return self._send_request_get_response(request, blueye.protocol.SetPubFrequencyRep, timeout) start def start ( self ) Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. View Source def start(self): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait() stop def stop ( self ) View Source def stop(self): self._exit_flag.set() sync_time def sync_time ( self , time : 'int' , timeout : 'float' = 0.05 ) View Source def sync_time(self, time: int, timeout: float = 0.05): request = blueye.protocol.SyncTimeReq( time={\"unix_timestamp\": {\"seconds\": time, \"nanos\": 0}} ) return self._send_request_get_response(request, blueye.protocol.SyncTimeRep, timeout) TelemetryClient class TelemetryClient ( parent_drone : \"'blueye.sdk.Drone'\" , context : 'zmq.Context' = None ) A class that represents a thread of control. This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass. View Source class TelemetryClient(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._parent_drone = parent_drone self._context = context or zmq.Context().instance() self._socket = self._context.socket(zmq.SUB) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5555\") self._socket.setsockopt_string(zmq.SUBSCRIBE, \"\") self._exit_flag = threading.Event() self._state_lock = threading.Lock() self._callbacks: List[Callback] = [] self._state: Dict[proto.message.Message, bytes] = {} \"\"\"`_state` is dictionary of the latest received messages, where the key is the protobuf message class, eg. blueye.protocol.DepthTel and the value is the serialized protobuf message\"\"\" def _handle_message(self, msg: Tuple[bytes, bytes]): msg_type_name = msg[0].decode(\"utf-8\").replace(\"blueye.protocol.\", \"\") try: msg_type = blueye.protocol.__getattribute__(msg_type_name) except AttributeError: # If a new telemetry message is introduced before the SDK is updated this can # be a common occurence, so choosing to log with info instead of warning logger.info(f\"Ignoring unknown message type: {msg_type_name}\") return msg_payload = msg[1] with self._state_lock: self._state[msg_type] = msg_payload for callback in self._callbacks: if msg_type in callback.message_filter or callback.message_filter == []: if callback.pass_raw_data: callback.function(msg_type_name, msg_payload) else: msg_deserialized = msg_type.deserialize(msg_payload) callback.function(msg_type_name, msg_deserialized) def run(self): poller = zmq.Poller() poller.register(self._socket, zmq.POLLIN) while not self._exit_flag.is_set(): events_to_be_processed = poller.poll(10) if len(events_to_be_processed) > 0: msg = self._socket.recv_multipart() self._handle_message(msg) def add_callback( self, msg_filter: List[proto.message.Message], callback_function: Callable[[str, proto.message.Message], None], raw: bool, ): uuid_hex = uuid.uuid1().hex self._callbacks.append(Callback(msg_filter, callback_function, raw, uuid_hex)) return uuid_hex def remove_callback(self, callback_id): try: self._callbacks.pop([cb.uuid_hex for cb in self._callbacks].index(callback_id)) except ValueError: logger.warning(f\"Callback with id {callback_id} not found, ignoring\") def get(self, key: proto.message.Message): with self._state_lock: return self._state[key] def stop(self): self._exit_flag.set() Ancestors (in MRO) threading.Thread Instance variables daemon A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. ident Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. name A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. native_id Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Methods add_callback def add_callback ( self , msg_filter : 'List[proto.message.Message]' , callback_function : 'Callable[[str, proto.message.Message], None]' , raw : 'bool' ) View Source def add_callback( self, msg_filter: List[proto.message.Message], callback_function: Callable[[str, proto.message.Message], None], raw: bool, ): uuid_hex = uuid.uuid1().hex self._callbacks.append(Callback(msg_filter, callback_function, raw, uuid_hex)) return uuid_hex get def get ( self , key : 'proto.message.Message' ) View Source def get(self, key: proto.message.Message): with self._state_lock: return self._state[key] getName def getName ( self ) Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. View Source def getName(self): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('getName() is deprecated, get the name attribute instead', DeprecationWarning, stacklevel=2) return self.name isDaemon def isDaemon ( self ) Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. View Source def isDaemon(self): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings.warn('isDaemon() is deprecated, get the daemon attribute instead', DeprecationWarning, stacklevel=2) return self.daemon is_alive def is_alive ( self ) Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). View Source def is_alive(self): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self._initialized, \"Thread.__init__() not called\" if self._is_stopped or not self._started.is_set(): return False self._wait_for_tstate_lock(False) return not self._is_stopped join def join ( self , timeout = None ) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. View Source def join(self, timeout=None): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self._initialized: raise RuntimeError(\"Thread.__init__() not called\") if not self._started.is_set(): raise RuntimeError(\"cannot join thread before it is started\") if self is current_thread(): raise RuntimeError(\"cannot join current thread\") if timeout is None: self._wait_for_tstate_lock() else: # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self._wait_for_tstate_lock(timeout=max(timeout, 0)) remove_callback def remove_callback ( self , callback_id ) View Source def remove_callback(self, callback_id): try: self._callbacks.pop([cb.uuid_hex for cb in self._callbacks].index(callback_id)) except ValueError: logger.warning(f\"Callback with id {callback_id} not found, ignoring\") run def run ( self ) Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. View Source def run(self): poller = zmq.Poller() poller.register(self._socket, zmq.POLLIN) while not self._exit_flag.is_set(): events_to_be_processed = poller.poll(10) if len(events_to_be_processed) > 0: msg = self._socket.recv_multipart() self._handle_message(msg) setDaemon def setDaemon ( self , daemonic ) Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. View Source def setDaemon(self, daemonic): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings.warn('setDaemon() is deprecated, set the daemon attribute instead', DeprecationWarning, stacklevel=2) self.daemon = daemonic setName def setName ( self , name ) Set the name string for this thread. This method is deprecated, use the name attribute instead. View Source def setName(self, name): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('setName() is deprecated, set the name attribute instead', DeprecationWarning, stacklevel=2) self.name = name start def start ( self ) Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. View Source def start(self): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait() stop def stop ( self ) View Source def stop(self): self._exit_flag.set() WatchdogPublisher class WatchdogPublisher ( parent_drone : \"'blueye.sdk.Drone'\" , context : 'zmq.Context' = None ) A class that represents a thread of control. This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass. View Source class WatchdogPublisher(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._parent_drone = parent_drone self._context = context or zmq.Context().instance() self._socket = self._context.socket(zmq.PUB) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5557\") self._exit_flag = threading.Event() def run(self): duration = 0 WATCHDOG_DELAY = 1 while not self._exit_flag.wait(WATCHDOG_DELAY): self.pet_watchdog(duration) duration += 1 def pet_watchdog(self, duration): msg = blueye.protocol.WatchdogCtrl( connection_duration={\"value\": duration}, client_id=self._parent_drone.client_id ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), blueye.protocol.WatchdogCtrl.serialize(msg), ] ) def stop(self): \"\"\"Stop the watchdog thread started by run()\"\"\" self._exit_flag.set() Ancestors (in MRO) threading.Thread Instance variables daemon A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. ident Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. name A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. native_id Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel. Methods getName def getName ( self ) Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. View Source def getName(self): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('getName() is deprecated, get the name attribute instead', DeprecationWarning, stacklevel=2) return self.name isDaemon def isDaemon ( self ) Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. View Source def isDaemon(self): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings.warn('isDaemon() is deprecated, get the daemon attribute instead', DeprecationWarning, stacklevel=2) return self.daemon is_alive def is_alive ( self ) Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). View Source def is_alive(self): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self._initialized, \"Thread.__init__() not called\" if self._is_stopped or not self._started.is_set(): return False self._wait_for_tstate_lock(False) return not self._is_stopped join def join ( self , timeout = None ) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. View Source def join(self, timeout=None): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self._initialized: raise RuntimeError(\"Thread.__init__() not called\") if not self._started.is_set(): raise RuntimeError(\"cannot join thread before it is started\") if self is current_thread(): raise RuntimeError(\"cannot join current thread\") if timeout is None: self._wait_for_tstate_lock() else: # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self._wait_for_tstate_lock(timeout=max(timeout, 0)) pet_watchdog def pet_watchdog ( self , duration ) View Source def pet_watchdog(self, duration): msg = blueye.protocol.WatchdogCtrl( connection_duration={\"value\": duration}, client_id=self._parent_drone.client_id ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), blueye.protocol.WatchdogCtrl.serialize(msg), ] ) run def run ( self ) Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. View Source def run(self): duration = 0 WATCHDOG_DELAY = 1 while not self._exit_flag.wait(WATCHDOG_DELAY): self.pet_watchdog(duration) duration += 1 setDaemon def setDaemon ( self , daemonic ) Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. View Source def setDaemon(self, daemonic): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings.warn('setDaemon() is deprecated, set the daemon attribute instead', DeprecationWarning, stacklevel=2) self.daemon = daemonic setName def setName ( self , name ) Set the name string for this thread. This method is deprecated, use the name attribute instead. View Source def setName(self, name): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('setName() is deprecated, set the name attribute instead', DeprecationWarning, stacklevel=2) self.name = name start def start ( self ) Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. View Source def start(self): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait() stop def stop ( self ) Stop the watchdog thread started by run() View Source def stop(self): \"\"\"Stop the watchdog thread started by run()\"\"\" self._exit_flag.set()","title":"Connection"},{"location":"reference/blueye/sdk/connection/#module-blueyesdkconnection","text":"View Source from __future__ import annotations import importlib.metadata import logging import platform import queue import threading import uuid from typing import Callable, Dict, List, NamedTuple, Tuple import blueye.protocol import proto import zmq logger = logging.getLogger(__name__) class WatchdogPublisher(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._parent_drone = parent_drone self._context = context or zmq.Context().instance() self._socket = self._context.socket(zmq.PUB) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5557\") self._exit_flag = threading.Event() def run(self): duration = 0 WATCHDOG_DELAY = 1 while not self._exit_flag.wait(WATCHDOG_DELAY): self.pet_watchdog(duration) duration += 1 def pet_watchdog(self, duration): msg = blueye.protocol.WatchdogCtrl( connection_duration={\"value\": duration}, client_id=self._parent_drone.client_id ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), blueye.protocol.WatchdogCtrl.serialize(msg), ] ) def stop(self): \"\"\"Stop the watchdog thread started by run()\"\"\" self._exit_flag.set() class Callback(NamedTuple): \"\"\"Specifications for callback for telemetry messages\"\"\" message_filter: List[proto.messages.Message] function: Callable[[str, proto.message.Message], None] pass_raw_data: bool uuid_hex: str class TelemetryClient(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._parent_drone = parent_drone self._context = context or zmq.Context().instance() self._socket = self._context.socket(zmq.SUB) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5555\") self._socket.setsockopt_string(zmq.SUBSCRIBE, \"\") self._exit_flag = threading.Event() self._state_lock = threading.Lock() self._callbacks: List[Callback] = [] self._state: Dict[proto.message.Message, bytes] = {} \"\"\"`_state` is dictionary of the latest received messages, where the key is the protobuf message class, eg. blueye.protocol.DepthTel and the value is the serialized protobuf message\"\"\" def _handle_message(self, msg: Tuple[bytes, bytes]): msg_type_name = msg[0].decode(\"utf-8\").replace(\"blueye.protocol.\", \"\") try: msg_type = blueye.protocol.__getattribute__(msg_type_name) except AttributeError: # If a new telemetry message is introduced before the SDK is updated this can # be a common occurence, so choosing to log with info instead of warning logger.info(f\"Ignoring unknown message type: {msg_type_name}\") return msg_payload = msg[1] with self._state_lock: self._state[msg_type] = msg_payload for callback in self._callbacks: if msg_type in callback.message_filter or callback.message_filter == []: if callback.pass_raw_data: callback.function(msg_type_name, msg_payload) else: msg_deserialized = msg_type.deserialize(msg_payload) callback.function(msg_type_name, msg_deserialized) def run(self): poller = zmq.Poller() poller.register(self._socket, zmq.POLLIN) while not self._exit_flag.is_set(): events_to_be_processed = poller.poll(10) if len(events_to_be_processed) > 0: msg = self._socket.recv_multipart() self._handle_message(msg) def add_callback( self, msg_filter: List[proto.message.Message], callback_function: Callable[[str, proto.message.Message], None], raw: bool, ): uuid_hex = uuid.uuid1().hex self._callbacks.append(Callback(msg_filter, callback_function, raw, uuid_hex)) return uuid_hex def remove_callback(self, callback_id): try: self._callbacks.pop([cb.uuid_hex for cb in self._callbacks].index(callback_id)) except ValueError: logger.warning(f\"Callback with id {callback_id} not found, ignoring\") def get(self, key: proto.message.Message): with self._state_lock: return self._state[key] def stop(self): self._exit_flag.set() class CtrlClient(threading.Thread): def __init__( self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None, ): super().__init__(daemon=True) self._context = context or zmq.Context().instance() self._parent_drone = parent_drone self._drone_pub_socket = self._context.socket(zmq.PUB) self._drone_pub_socket.connect(f\"tcp://{self._parent_drone._ip}:5557\") self._messages_to_send = queue.Queue() self._exit_flag = threading.Event() def run(self): while not self._exit_flag.is_set(): try: msg = self._messages_to_send.get(timeout=0.1) self._drone_pub_socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No messages to send, so we can continue def stop(self): self._exit_flag.set() def set_lights(self, value: float): msg = blueye.protocol.LightsCtrl(lights={\"value\": value}) self._messages_to_send.put(msg) def set_water_density(self, value: float): msg = blueye.protocol.WaterDensityCtrl(density={\"value\": value}) self._messages_to_send.put(msg) def set_tilt_velocity(self, value: float): msg = blueye.protocol.TiltVelocityCtrl(velocity={\"value\": value}) self._messages_to_send.put(msg) def set_tilt_stabilization(self, enabled: bool): msg = blueye.protocol.TiltStabilizationCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_motion_input( self, surge: float, sway: float, heave: float, yaw: float, slow: float, boost: float ): msg = blueye.protocol.MotionInputCtrl( motion_input={ \"surge\": surge, \"sway\": sway, \"heave\": heave, \"yaw\": yaw, \"slow\": slow, \"boost\": boost, } ) self._messages_to_send.put(msg) def set_auto_depth_state(self, enabled: bool): msg = blueye.protocol.AutoDepthCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_auto_heading_state(self, enabled: bool): msg = blueye.protocol.AutoHeadingCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_recording_state(self, main_enabled: bool, guestport_enabled: bool): msg = blueye.protocol.RecordCtrl( record_on={\"main\": main_enabled, \"guestport\": guestport_enabled} ) self._messages_to_send.put(msg) def take_still_picture(self): msg = blueye.protocol.TakePictureCtrl() self._messages_to_send.put(msg) class ReqRepClient(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._context = context or zmq.Context().instance() self._parent_drone = parent_drone self._socket = self._context.socket(zmq.REQ) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5556\") self._requests_to_send = queue.Queue() self._exit_flag = threading.Event() @staticmethod def _get_client_info() -> blueye.protocol.ClientInfo: client_info = blueye.protocol.ClientInfo( type=\"SDK\", version=f\"{importlib.metadata.version('blueye.sdk')}\", device_type=\"Computer\", platform=f\"{platform.system()}\", platform_version=f\"{platform.release()}\", name=f\"{platform.node()}\", ) return client_info def run(self): while not self._exit_flag.is_set(): try: msg, response_type, response_callback_queue = self._requests_to_send.get( timeout=0.1 ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No requests to send, so we can continue # TODO: Deal with timeout resp = self._socket.recv_multipart() resp_deserialized = response_type.deserialize(resp[1]) response_callback_queue.put(resp_deserialized) def stop(self): self._exit_flag.set() def _send_request_get_response( self, request: proto.message.Message, expected_response: proto.message.Message, timeout: float, ): response_queue = queue.Queue(maxsize=1) self._requests_to_send.put((request, expected_response, response_queue)) try: return response_queue.get(timeout=timeout) except queue.Empty: raise blueye.protocol.exceptions.ResponseTimeout( \"No response received from drone before timeout\" ) def ping(self, timeout: float) -> blueye.protocol.PingRep: request = blueye.protocol.PingReq() return self._send_request_get_response(request, blueye.protocol.PingRep, timeout) def get_camera_parameters( self, camera: blueye.protocol.Camera, timeout: float = 0.05 ) -> blueye.protocol.CameraParameters: request = blueye.protocol.GetCameraParametersReq(camera=camera) response = self._send_request_get_response( request, blueye.protocol.GetCameraParametersRep, timeout ) return response.camera_parameters def set_camera_parameters( self, parameters: blueye.protocol.CameraParameters, timeout: float = 0.05, ): request = blueye.protocol.SetCameraParametersReq(camera_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetCameraParametersRep, timeout ) def get_overlay_parameters(self, timeout: float = 0.05) -> blueye.protocol.OverlayParameters: request = blueye.protocol.GetOverlayParametersReq() response = self._send_request_get_response( request, blueye.protocol.GetOverlayParametersRep, timeout ) return response.overlay_parameters def set_overlay_parameters( self, parameters: blueye.protocol.OverlayParameters, timeout: float = 0.05 ): request = blueye.protocol.SetOverlayParametersReq(overlay_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetOverlayParametersRep, timeout ) def sync_time(self, time: int, timeout: float = 0.05): request = blueye.protocol.SyncTimeReq( time={\"unix_timestamp\": {\"seconds\": time, \"nanos\": 0}} ) return self._send_request_get_response(request, blueye.protocol.SyncTimeRep, timeout) def connect_client( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 0.05 ) -> blueye.protocol.ConnectClientRep: client = client_info or self._get_client_info() request = blueye.protocol.ConnectClientReq(client_info=client) return self._send_request_get_response(request, blueye.protocol.ConnectClientRep, timeout) def disconnect_client( self, client_id: int, timeout: float = 0.05 ) -> blueye.protocol.DisconnectClientRep: request = blueye.protocol.DisconnectClientReq(client_id=client_id) return self._send_request_get_response( request, blueye.protocol.DisconnectClientRep, timeout ) def set_telemetry_msg_publish_frequency( self, msg: proto.message.Message | str, frequency: float, timeout: float = 0.05 ) -> blueye.protocol.SetPubFrequencyRep: message_type = ( msg.meta.full_name.replace(\"blueye.protocol.\", \"\") if type(msg) in [proto.message.Message, proto.message.MessageMeta] else msg.replace(\"blueye.protocol.\", \"\") ) request = blueye.protocol.SetPubFrequencyReq( message_type=message_type, frequency=frequency, ) return self._send_request_get_response(request, blueye.protocol.SetPubFrequencyRep, timeout)","title":"Module blueye.sdk.connection"},{"location":"reference/blueye/sdk/connection/#variables","text":"logger","title":"Variables"},{"location":"reference/blueye/sdk/connection/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/connection/#callback","text":"class Callback ( / , * args , ** kwargs ) Specifications for callback for telemetry messages View Source class Callback(NamedTuple): \"\"\"Specifications for callback for telemetry messages\"\"\" message_filter: List[proto.messages.Message] function: Callable[[str, proto.message.Message], None] pass_raw_data: bool uuid_hex: str","title":"Callback"},{"location":"reference/blueye/sdk/connection/#ancestors-in-mro","text":"builtins.tuple","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/connection/#class-variables","text":"function message_filter pass_raw_data uuid_hex","title":"Class variables"},{"location":"reference/blueye/sdk/connection/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/connection/#count","text":"def count ( self , value , / ) Return number of occurrences of value.","title":"count"},{"location":"reference/blueye/sdk/connection/#index","text":"def index ( self , value , start = 0 , stop = 9223372036854775807 , / ) Return first index of value. Raises ValueError if the value is not present.","title":"index"},{"location":"reference/blueye/sdk/connection/#ctrlclient","text":"class CtrlClient ( parent_drone : \"'blueye.sdk.Drone'\" , context : 'zmq.Context' = None ) A class that represents a thread of control. This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass. View Source class CtrlClient(threading.Thread): def __init__( self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None, ): super().__init__(daemon=True) self._context = context or zmq.Context().instance() self._parent_drone = parent_drone self._drone_pub_socket = self._context.socket(zmq.PUB) self._drone_pub_socket.connect(f\"tcp://{self._parent_drone._ip}:5557\") self._messages_to_send = queue.Queue() self._exit_flag = threading.Event() def run(self): while not self._exit_flag.is_set(): try: msg = self._messages_to_send.get(timeout=0.1) self._drone_pub_socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No messages to send, so we can continue def stop(self): self._exit_flag.set() def set_lights(self, value: float): msg = blueye.protocol.LightsCtrl(lights={\"value\": value}) self._messages_to_send.put(msg) def set_water_density(self, value: float): msg = blueye.protocol.WaterDensityCtrl(density={\"value\": value}) self._messages_to_send.put(msg) def set_tilt_velocity(self, value: float): msg = blueye.protocol.TiltVelocityCtrl(velocity={\"value\": value}) self._messages_to_send.put(msg) def set_tilt_stabilization(self, enabled: bool): msg = blueye.protocol.TiltStabilizationCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_motion_input( self, surge: float, sway: float, heave: float, yaw: float, slow: float, boost: float ): msg = blueye.protocol.MotionInputCtrl( motion_input={ \"surge\": surge, \"sway\": sway, \"heave\": heave, \"yaw\": yaw, \"slow\": slow, \"boost\": boost, } ) self._messages_to_send.put(msg) def set_auto_depth_state(self, enabled: bool): msg = blueye.protocol.AutoDepthCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_auto_heading_state(self, enabled: bool): msg = blueye.protocol.AutoHeadingCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg) def set_recording_state(self, main_enabled: bool, guestport_enabled: bool): msg = blueye.protocol.RecordCtrl( record_on={\"main\": main_enabled, \"guestport\": guestport_enabled} ) self._messages_to_send.put(msg) def take_still_picture(self): msg = blueye.protocol.TakePictureCtrl() self._messages_to_send.put(msg)","title":"CtrlClient"},{"location":"reference/blueye/sdk/connection/#ancestors-in-mro_1","text":"threading.Thread","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/connection/#instance-variables","text":"daemon A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. ident Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. name A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. native_id Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"Instance variables"},{"location":"reference/blueye/sdk/connection/#methods_1","text":"","title":"Methods"},{"location":"reference/blueye/sdk/connection/#getname","text":"def getName ( self ) Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. View Source def getName(self): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('getName() is deprecated, get the name attribute instead', DeprecationWarning, stacklevel=2) return self.name","title":"getName"},{"location":"reference/blueye/sdk/connection/#isdaemon","text":"def isDaemon ( self ) Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. View Source def isDaemon(self): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings.warn('isDaemon() is deprecated, get the daemon attribute instead', DeprecationWarning, stacklevel=2) return self.daemon","title":"isDaemon"},{"location":"reference/blueye/sdk/connection/#is_alive","text":"def is_alive ( self ) Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). View Source def is_alive(self): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self._initialized, \"Thread.__init__() not called\" if self._is_stopped or not self._started.is_set(): return False self._wait_for_tstate_lock(False) return not self._is_stopped","title":"is_alive"},{"location":"reference/blueye/sdk/connection/#join","text":"def join ( self , timeout = None ) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. View Source def join(self, timeout=None): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self._initialized: raise RuntimeError(\"Thread.__init__() not called\") if not self._started.is_set(): raise RuntimeError(\"cannot join thread before it is started\") if self is current_thread(): raise RuntimeError(\"cannot join current thread\") if timeout is None: self._wait_for_tstate_lock() else: # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self._wait_for_tstate_lock(timeout=max(timeout, 0))","title":"join"},{"location":"reference/blueye/sdk/connection/#run","text":"def run ( self ) Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. View Source def run(self): while not self._exit_flag.is_set(): try: msg = self._messages_to_send.get(timeout=0.1) self._drone_pub_socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No messages to send, so we can continue","title":"run"},{"location":"reference/blueye/sdk/connection/#setdaemon","text":"def setDaemon ( self , daemonic ) Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. View Source def setDaemon(self, daemonic): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings.warn('setDaemon() is deprecated, set the daemon attribute instead', DeprecationWarning, stacklevel=2) self.daemon = daemonic","title":"setDaemon"},{"location":"reference/blueye/sdk/connection/#setname","text":"def setName ( self , name ) Set the name string for this thread. This method is deprecated, use the name attribute instead. View Source def setName(self, name): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('setName() is deprecated, set the name attribute instead', DeprecationWarning, stacklevel=2) self.name = name","title":"setName"},{"location":"reference/blueye/sdk/connection/#set_auto_depth_state","text":"def set_auto_depth_state ( self , enabled : 'bool' ) View Source def set_auto_depth_state(self, enabled: bool): msg = blueye.protocol.AutoDepthCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg)","title":"set_auto_depth_state"},{"location":"reference/blueye/sdk/connection/#set_auto_heading_state","text":"def set_auto_heading_state ( self , enabled : 'bool' ) View Source def set_auto_heading_state(self, enabled: bool): msg = blueye.protocol.AutoHeadingCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg)","title":"set_auto_heading_state"},{"location":"reference/blueye/sdk/connection/#set_lights","text":"def set_lights ( self , value : 'float' ) View Source def set_lights(self, value: float): msg = blueye.protocol.LightsCtrl(lights={\"value\": value}) self._messages_to_send.put(msg)","title":"set_lights"},{"location":"reference/blueye/sdk/connection/#set_motion_input","text":"def set_motion_input ( self , surge : 'float' , sway : 'float' , heave : 'float' , yaw : 'float' , slow : 'float' , boost : 'float' ) View Source def set_motion_input( self, surge: float, sway: float, heave: float, yaw: float, slow: float, boost: float ): msg = blueye.protocol.MotionInputCtrl( motion_input={ \"surge\": surge, \"sway\": sway, \"heave\": heave, \"yaw\": yaw, \"slow\": slow, \"boost\": boost, } ) self._messages_to_send.put(msg)","title":"set_motion_input"},{"location":"reference/blueye/sdk/connection/#set_recording_state","text":"def set_recording_state ( self , main_enabled : 'bool' , guestport_enabled : 'bool' ) View Source def set_recording_state(self, main_enabled: bool, guestport_enabled: bool): msg = blueye.protocol.RecordCtrl( record_on={\"main\": main_enabled, \"guestport\": guestport_enabled} ) self._messages_to_send.put(msg)","title":"set_recording_state"},{"location":"reference/blueye/sdk/connection/#set_tilt_stabilization","text":"def set_tilt_stabilization ( self , enabled : 'bool' ) View Source def set_tilt_stabilization(self, enabled: bool): msg = blueye.protocol.TiltStabilizationCtrl(state={\"enabled\": enabled}) self._messages_to_send.put(msg)","title":"set_tilt_stabilization"},{"location":"reference/blueye/sdk/connection/#set_tilt_velocity","text":"def set_tilt_velocity ( self , value : 'float' ) View Source def set_tilt_velocity(self, value: float): msg = blueye.protocol.TiltVelocityCtrl(velocity={\"value\": value}) self._messages_to_send.put(msg)","title":"set_tilt_velocity"},{"location":"reference/blueye/sdk/connection/#set_water_density","text":"def set_water_density ( self , value : 'float' ) View Source def set_water_density(self, value: float): msg = blueye.protocol.WaterDensityCtrl(density={\"value\": value}) self._messages_to_send.put(msg)","title":"set_water_density"},{"location":"reference/blueye/sdk/connection/#start","text":"def start ( self ) Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. View Source def start(self): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait()","title":"start"},{"location":"reference/blueye/sdk/connection/#stop","text":"def stop ( self ) View Source def stop(self): self._exit_flag.set()","title":"stop"},{"location":"reference/blueye/sdk/connection/#take_still_picture","text":"def take_still_picture ( self ) View Source def take_still_picture(self): msg = blueye.protocol.TakePictureCtrl() self._messages_to_send.put(msg)","title":"take_still_picture"},{"location":"reference/blueye/sdk/connection/#reqrepclient","text":"class ReqRepClient ( parent_drone : \"'blueye.sdk.Drone'\" , context : 'zmq.Context' = None ) A class that represents a thread of control. This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass. View Source class ReqRepClient(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._context = context or zmq.Context().instance() self._parent_drone = parent_drone self._socket = self._context.socket(zmq.REQ) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5556\") self._requests_to_send = queue.Queue() self._exit_flag = threading.Event() @staticmethod def _get_client_info() -> blueye.protocol.ClientInfo: client_info = blueye.protocol.ClientInfo( type=\"SDK\", version=f\"{importlib.metadata.version('blueye.sdk')}\", device_type=\"Computer\", platform=f\"{platform.system()}\", platform_version=f\"{platform.release()}\", name=f\"{platform.node()}\", ) return client_info def run(self): while not self._exit_flag.is_set(): try: msg, response_type, response_callback_queue = self._requests_to_send.get( timeout=0.1 ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No requests to send, so we can continue # TODO: Deal with timeout resp = self._socket.recv_multipart() resp_deserialized = response_type.deserialize(resp[1]) response_callback_queue.put(resp_deserialized) def stop(self): self._exit_flag.set() def _send_request_get_response( self, request: proto.message.Message, expected_response: proto.message.Message, timeout: float, ): response_queue = queue.Queue(maxsize=1) self._requests_to_send.put((request, expected_response, response_queue)) try: return response_queue.get(timeout=timeout) except queue.Empty: raise blueye.protocol.exceptions.ResponseTimeout( \"No response received from drone before timeout\" ) def ping(self, timeout: float) -> blueye.protocol.PingRep: request = blueye.protocol.PingReq() return self._send_request_get_response(request, blueye.protocol.PingRep, timeout) def get_camera_parameters( self, camera: blueye.protocol.Camera, timeout: float = 0.05 ) -> blueye.protocol.CameraParameters: request = blueye.protocol.GetCameraParametersReq(camera=camera) response = self._send_request_get_response( request, blueye.protocol.GetCameraParametersRep, timeout ) return response.camera_parameters def set_camera_parameters( self, parameters: blueye.protocol.CameraParameters, timeout: float = 0.05, ): request = blueye.protocol.SetCameraParametersReq(camera_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetCameraParametersRep, timeout ) def get_overlay_parameters(self, timeout: float = 0.05) -> blueye.protocol.OverlayParameters: request = blueye.protocol.GetOverlayParametersReq() response = self._send_request_get_response( request, blueye.protocol.GetOverlayParametersRep, timeout ) return response.overlay_parameters def set_overlay_parameters( self, parameters: blueye.protocol.OverlayParameters, timeout: float = 0.05 ): request = blueye.protocol.SetOverlayParametersReq(overlay_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetOverlayParametersRep, timeout ) def sync_time(self, time: int, timeout: float = 0.05): request = blueye.protocol.SyncTimeReq( time={\"unix_timestamp\": {\"seconds\": time, \"nanos\": 0}} ) return self._send_request_get_response(request, blueye.protocol.SyncTimeRep, timeout) def connect_client( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 0.05 ) -> blueye.protocol.ConnectClientRep: client = client_info or self._get_client_info() request = blueye.protocol.ConnectClientReq(client_info=client) return self._send_request_get_response(request, blueye.protocol.ConnectClientRep, timeout) def disconnect_client( self, client_id: int, timeout: float = 0.05 ) -> blueye.protocol.DisconnectClientRep: request = blueye.protocol.DisconnectClientReq(client_id=client_id) return self._send_request_get_response( request, blueye.protocol.DisconnectClientRep, timeout ) def set_telemetry_msg_publish_frequency( self, msg: proto.message.Message | str, frequency: float, timeout: float = 0.05 ) -> blueye.protocol.SetPubFrequencyRep: message_type = ( msg.meta.full_name.replace(\"blueye.protocol.\", \"\") if type(msg) in [proto.message.Message, proto.message.MessageMeta] else msg.replace(\"blueye.protocol.\", \"\") ) request = blueye.protocol.SetPubFrequencyReq( message_type=message_type, frequency=frequency, ) return self._send_request_get_response(request, blueye.protocol.SetPubFrequencyRep, timeout)","title":"ReqRepClient"},{"location":"reference/blueye/sdk/connection/#ancestors-in-mro_2","text":"threading.Thread","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/connection/#instance-variables_1","text":"daemon A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. ident Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. name A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. native_id Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"Instance variables"},{"location":"reference/blueye/sdk/connection/#methods_2","text":"","title":"Methods"},{"location":"reference/blueye/sdk/connection/#connect_client","text":"def connect_client ( self , client_info : 'blueye.protocol.ClientInfo' = None , timeout : 'float' = 0.05 ) -> 'blueye.protocol.ConnectClientRep' View Source def connect_client( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 0.05 ) -> blueye.protocol.ConnectClientRep: client = client_info or self._get_client_info() request = blueye.protocol.ConnectClientReq(client_info=client) return self._send_request_get_response(request, blueye.protocol.ConnectClientRep, timeout)","title":"connect_client"},{"location":"reference/blueye/sdk/connection/#disconnect_client","text":"def disconnect_client ( self , client_id : 'int' , timeout : 'float' = 0.05 ) -> 'blueye.protocol.DisconnectClientRep' View Source def disconnect_client( self, client_id: int, timeout: float = 0.05 ) -> blueye.protocol.DisconnectClientRep: request = blueye.protocol.DisconnectClientReq(client_id=client_id) return self._send_request_get_response( request, blueye.protocol.DisconnectClientRep, timeout )","title":"disconnect_client"},{"location":"reference/blueye/sdk/connection/#getname_1","text":"def getName ( self ) Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. View Source def getName(self): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('getName() is deprecated, get the name attribute instead', DeprecationWarning, stacklevel=2) return self.name","title":"getName"},{"location":"reference/blueye/sdk/connection/#get_camera_parameters","text":"def get_camera_parameters ( self , camera : 'blueye.protocol.Camera' , timeout : 'float' = 0.05 ) -> 'blueye.protocol.CameraParameters' View Source def get_camera_parameters( self, camera: blueye.protocol.Camera, timeout: float = 0.05 ) -> blueye.protocol.CameraParameters: request = blueye.protocol.GetCameraParametersReq(camera=camera) response = self._send_request_get_response( request, blueye.protocol.GetCameraParametersRep, timeout ) return response.camera_parameters","title":"get_camera_parameters"},{"location":"reference/blueye/sdk/connection/#get_overlay_parameters","text":"def get_overlay_parameters ( self , timeout : 'float' = 0.05 ) -> 'blueye.protocol.OverlayParameters' View Source def get_overlay_parameters(self, timeout: float = 0.05) -> blueye.protocol.OverlayParameters: request = blueye.protocol.GetOverlayParametersReq() response = self._send_request_get_response( request, blueye.protocol.GetOverlayParametersRep, timeout ) return response.overlay_parameters","title":"get_overlay_parameters"},{"location":"reference/blueye/sdk/connection/#isdaemon_1","text":"def isDaemon ( self ) Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. View Source def isDaemon(self): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings.warn('isDaemon() is deprecated, get the daemon attribute instead', DeprecationWarning, stacklevel=2) return self.daemon","title":"isDaemon"},{"location":"reference/blueye/sdk/connection/#is_alive_1","text":"def is_alive ( self ) Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). View Source def is_alive(self): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self._initialized, \"Thread.__init__() not called\" if self._is_stopped or not self._started.is_set(): return False self._wait_for_tstate_lock(False) return not self._is_stopped","title":"is_alive"},{"location":"reference/blueye/sdk/connection/#join_1","text":"def join ( self , timeout = None ) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. View Source def join(self, timeout=None): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self._initialized: raise RuntimeError(\"Thread.__init__() not called\") if not self._started.is_set(): raise RuntimeError(\"cannot join thread before it is started\") if self is current_thread(): raise RuntimeError(\"cannot join current thread\") if timeout is None: self._wait_for_tstate_lock() else: # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self._wait_for_tstate_lock(timeout=max(timeout, 0))","title":"join"},{"location":"reference/blueye/sdk/connection/#ping","text":"def ping ( self , timeout : 'float' ) -> 'blueye.protocol.PingRep' View Source def ping(self, timeout: float) -> blueye.protocol.PingRep: request = blueye.protocol.PingReq() return self._send_request_get_response(request, blueye.protocol.PingRep, timeout)","title":"ping"},{"location":"reference/blueye/sdk/connection/#run_1","text":"def run ( self ) Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. View Source def run(self): while not self._exit_flag.is_set(): try: msg, response_type, response_callback_queue = self._requests_to_send.get( timeout=0.1 ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), msg.__class__.serialize(msg), ] ) except queue.Empty: # No requests to send, so we can continue # TODO: Deal with timeout resp = self._socket.recv_multipart() resp_deserialized = response_type.deserialize(resp[1]) response_callback_queue.put(resp_deserialized)","title":"run"},{"location":"reference/blueye/sdk/connection/#setdaemon_1","text":"def setDaemon ( self , daemonic ) Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. View Source def setDaemon(self, daemonic): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings.warn('setDaemon() is deprecated, set the daemon attribute instead', DeprecationWarning, stacklevel=2) self.daemon = daemonic","title":"setDaemon"},{"location":"reference/blueye/sdk/connection/#setname_1","text":"def setName ( self , name ) Set the name string for this thread. This method is deprecated, use the name attribute instead. View Source def setName(self, name): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('setName() is deprecated, set the name attribute instead', DeprecationWarning, stacklevel=2) self.name = name","title":"setName"},{"location":"reference/blueye/sdk/connection/#set_camera_parameters","text":"def set_camera_parameters ( self , parameters : 'blueye.protocol.CameraParameters' , timeout : 'float' = 0.05 ) View Source def set_camera_parameters( self, parameters: blueye.protocol.CameraParameters, timeout: float = 0.05, ): request = blueye.protocol.SetCameraParametersReq(camera_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetCameraParametersRep, timeout )","title":"set_camera_parameters"},{"location":"reference/blueye/sdk/connection/#set_overlay_parameters","text":"def set_overlay_parameters ( self , parameters : 'blueye.protocol.OverlayParameters' , timeout : 'float' = 0.05 ) View Source def set_overlay_parameters( self, parameters: blueye.protocol.OverlayParameters, timeout: float = 0.05 ): request = blueye.protocol.SetOverlayParametersReq(overlay_parameters=parameters) return self._send_request_get_response( request, blueye.protocol.SetOverlayParametersRep, timeout )","title":"set_overlay_parameters"},{"location":"reference/blueye/sdk/connection/#set_telemetry_msg_publish_frequency","text":"def set_telemetry_msg_publish_frequency ( self , msg : 'proto.message.Message | str' , frequency : 'float' , timeout : 'float' = 0.05 ) -> 'blueye.protocol.SetPubFrequencyRep' View Source def set_telemetry_msg_publish_frequency( self, msg: proto.message.Message | str, frequency: float, timeout: float = 0.05 ) -> blueye.protocol.SetPubFrequencyRep: message_type = ( msg.meta.full_name.replace(\"blueye.protocol.\", \"\") if type(msg) in [proto.message.Message, proto.message.MessageMeta] else msg.replace(\"blueye.protocol.\", \"\") ) request = blueye.protocol.SetPubFrequencyReq( message_type=message_type, frequency=frequency, ) return self._send_request_get_response(request, blueye.protocol.SetPubFrequencyRep, timeout)","title":"set_telemetry_msg_publish_frequency"},{"location":"reference/blueye/sdk/connection/#start_1","text":"def start ( self ) Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. View Source def start(self): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait()","title":"start"},{"location":"reference/blueye/sdk/connection/#stop_1","text":"def stop ( self ) View Source def stop(self): self._exit_flag.set()","title":"stop"},{"location":"reference/blueye/sdk/connection/#sync_time","text":"def sync_time ( self , time : 'int' , timeout : 'float' = 0.05 ) View Source def sync_time(self, time: int, timeout: float = 0.05): request = blueye.protocol.SyncTimeReq( time={\"unix_timestamp\": {\"seconds\": time, \"nanos\": 0}} ) return self._send_request_get_response(request, blueye.protocol.SyncTimeRep, timeout)","title":"sync_time"},{"location":"reference/blueye/sdk/connection/#telemetryclient","text":"class TelemetryClient ( parent_drone : \"'blueye.sdk.Drone'\" , context : 'zmq.Context' = None ) A class that represents a thread of control. This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass. View Source class TelemetryClient(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._parent_drone = parent_drone self._context = context or zmq.Context().instance() self._socket = self._context.socket(zmq.SUB) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5555\") self._socket.setsockopt_string(zmq.SUBSCRIBE, \"\") self._exit_flag = threading.Event() self._state_lock = threading.Lock() self._callbacks: List[Callback] = [] self._state: Dict[proto.message.Message, bytes] = {} \"\"\"`_state` is dictionary of the latest received messages, where the key is the protobuf message class, eg. blueye.protocol.DepthTel and the value is the serialized protobuf message\"\"\" def _handle_message(self, msg: Tuple[bytes, bytes]): msg_type_name = msg[0].decode(\"utf-8\").replace(\"blueye.protocol.\", \"\") try: msg_type = blueye.protocol.__getattribute__(msg_type_name) except AttributeError: # If a new telemetry message is introduced before the SDK is updated this can # be a common occurence, so choosing to log with info instead of warning logger.info(f\"Ignoring unknown message type: {msg_type_name}\") return msg_payload = msg[1] with self._state_lock: self._state[msg_type] = msg_payload for callback in self._callbacks: if msg_type in callback.message_filter or callback.message_filter == []: if callback.pass_raw_data: callback.function(msg_type_name, msg_payload) else: msg_deserialized = msg_type.deserialize(msg_payload) callback.function(msg_type_name, msg_deserialized) def run(self): poller = zmq.Poller() poller.register(self._socket, zmq.POLLIN) while not self._exit_flag.is_set(): events_to_be_processed = poller.poll(10) if len(events_to_be_processed) > 0: msg = self._socket.recv_multipart() self._handle_message(msg) def add_callback( self, msg_filter: List[proto.message.Message], callback_function: Callable[[str, proto.message.Message], None], raw: bool, ): uuid_hex = uuid.uuid1().hex self._callbacks.append(Callback(msg_filter, callback_function, raw, uuid_hex)) return uuid_hex def remove_callback(self, callback_id): try: self._callbacks.pop([cb.uuid_hex for cb in self._callbacks].index(callback_id)) except ValueError: logger.warning(f\"Callback with id {callback_id} not found, ignoring\") def get(self, key: proto.message.Message): with self._state_lock: return self._state[key] def stop(self): self._exit_flag.set()","title":"TelemetryClient"},{"location":"reference/blueye/sdk/connection/#ancestors-in-mro_3","text":"threading.Thread","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/connection/#instance-variables_2","text":"daemon A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. ident Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. name A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. native_id Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"Instance variables"},{"location":"reference/blueye/sdk/connection/#methods_3","text":"","title":"Methods"},{"location":"reference/blueye/sdk/connection/#add_callback","text":"def add_callback ( self , msg_filter : 'List[proto.message.Message]' , callback_function : 'Callable[[str, proto.message.Message], None]' , raw : 'bool' ) View Source def add_callback( self, msg_filter: List[proto.message.Message], callback_function: Callable[[str, proto.message.Message], None], raw: bool, ): uuid_hex = uuid.uuid1().hex self._callbacks.append(Callback(msg_filter, callback_function, raw, uuid_hex)) return uuid_hex","title":"add_callback"},{"location":"reference/blueye/sdk/connection/#get","text":"def get ( self , key : 'proto.message.Message' ) View Source def get(self, key: proto.message.Message): with self._state_lock: return self._state[key]","title":"get"},{"location":"reference/blueye/sdk/connection/#getname_2","text":"def getName ( self ) Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. View Source def getName(self): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('getName() is deprecated, get the name attribute instead', DeprecationWarning, stacklevel=2) return self.name","title":"getName"},{"location":"reference/blueye/sdk/connection/#isdaemon_2","text":"def isDaemon ( self ) Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. View Source def isDaemon(self): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings.warn('isDaemon() is deprecated, get the daemon attribute instead', DeprecationWarning, stacklevel=2) return self.daemon","title":"isDaemon"},{"location":"reference/blueye/sdk/connection/#is_alive_2","text":"def is_alive ( self ) Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). View Source def is_alive(self): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self._initialized, \"Thread.__init__() not called\" if self._is_stopped or not self._started.is_set(): return False self._wait_for_tstate_lock(False) return not self._is_stopped","title":"is_alive"},{"location":"reference/blueye/sdk/connection/#join_2","text":"def join ( self , timeout = None ) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. View Source def join(self, timeout=None): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self._initialized: raise RuntimeError(\"Thread.__init__() not called\") if not self._started.is_set(): raise RuntimeError(\"cannot join thread before it is started\") if self is current_thread(): raise RuntimeError(\"cannot join current thread\") if timeout is None: self._wait_for_tstate_lock() else: # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self._wait_for_tstate_lock(timeout=max(timeout, 0))","title":"join"},{"location":"reference/blueye/sdk/connection/#remove_callback","text":"def remove_callback ( self , callback_id ) View Source def remove_callback(self, callback_id): try: self._callbacks.pop([cb.uuid_hex for cb in self._callbacks].index(callback_id)) except ValueError: logger.warning(f\"Callback with id {callback_id} not found, ignoring\")","title":"remove_callback"},{"location":"reference/blueye/sdk/connection/#run_2","text":"def run ( self ) Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. View Source def run(self): poller = zmq.Poller() poller.register(self._socket, zmq.POLLIN) while not self._exit_flag.is_set(): events_to_be_processed = poller.poll(10) if len(events_to_be_processed) > 0: msg = self._socket.recv_multipart() self._handle_message(msg)","title":"run"},{"location":"reference/blueye/sdk/connection/#setdaemon_2","text":"def setDaemon ( self , daemonic ) Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. View Source def setDaemon(self, daemonic): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings.warn('setDaemon() is deprecated, set the daemon attribute instead', DeprecationWarning, stacklevel=2) self.daemon = daemonic","title":"setDaemon"},{"location":"reference/blueye/sdk/connection/#setname_2","text":"def setName ( self , name ) Set the name string for this thread. This method is deprecated, use the name attribute instead. View Source def setName(self, name): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('setName() is deprecated, set the name attribute instead', DeprecationWarning, stacklevel=2) self.name = name","title":"setName"},{"location":"reference/blueye/sdk/connection/#start_2","text":"def start ( self ) Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. View Source def start(self): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait()","title":"start"},{"location":"reference/blueye/sdk/connection/#stop_2","text":"def stop ( self ) View Source def stop(self): self._exit_flag.set()","title":"stop"},{"location":"reference/blueye/sdk/connection/#watchdogpublisher","text":"class WatchdogPublisher ( parent_drone : \"'blueye.sdk.Drone'\" , context : 'zmq.Context' = None ) A class that represents a thread of control. This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass. View Source class WatchdogPublisher(threading.Thread): def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None): super().__init__(daemon=True) self._parent_drone = parent_drone self._context = context or zmq.Context().instance() self._socket = self._context.socket(zmq.PUB) self._socket.connect(f\"tcp://{self._parent_drone._ip}:5557\") self._exit_flag = threading.Event() def run(self): duration = 0 WATCHDOG_DELAY = 1 while not self._exit_flag.wait(WATCHDOG_DELAY): self.pet_watchdog(duration) duration += 1 def pet_watchdog(self, duration): msg = blueye.protocol.WatchdogCtrl( connection_duration={\"value\": duration}, client_id=self._parent_drone.client_id ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), blueye.protocol.WatchdogCtrl.serialize(msg), ] ) def stop(self): \"\"\"Stop the watchdog thread started by run()\"\"\" self._exit_flag.set()","title":"WatchdogPublisher"},{"location":"reference/blueye/sdk/connection/#ancestors-in-mro_4","text":"threading.Thread","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/connection/#instance-variables_3","text":"daemon A boolean value indicating whether this thread is a daemon thread. This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False. The entire Python program exits when only daemon threads are left. ident Thread identifier of this thread or None if it has not been started. This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited. name A string used for identification purposes only. It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor. native_id Native integral thread ID of this thread, or None if it has not been started. This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.","title":"Instance variables"},{"location":"reference/blueye/sdk/connection/#methods_4","text":"","title":"Methods"},{"location":"reference/blueye/sdk/connection/#getname_3","text":"def getName ( self ) Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. View Source def getName(self): \"\"\"Return a string used for identification purposes only. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('getName() is deprecated, get the name attribute instead', DeprecationWarning, stacklevel=2) return self.name","title":"getName"},{"location":"reference/blueye/sdk/connection/#isdaemon_3","text":"def isDaemon ( self ) Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. View Source def isDaemon(self): \"\"\"Return whether this thread is a daemon. This method is deprecated, use the daemon attribute instead. \"\"\" import warnings warnings.warn('isDaemon() is deprecated, get the daemon attribute instead', DeprecationWarning, stacklevel=2) return self.daemon","title":"isDaemon"},{"location":"reference/blueye/sdk/connection/#is_alive_3","text":"def is_alive ( self ) Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). View Source def is_alive(self): \"\"\"Return whether the thread is alive. This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate(). \"\"\" assert self._initialized, \"Thread.__init__() not called\" if self._is_stopped or not self._started.is_set(): return False self._wait_for_tstate_lock(False) return not self._is_stopped","title":"is_alive"},{"location":"reference/blueye/sdk/connection/#join_3","text":"def join ( self , timeout = None ) Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. View Source def join(self, timeout=None): \"\"\"Wait until the thread terminates. This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs. When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out. When the timeout argument is not present or None, the operation will block until the thread terminates. A thread can be join()ed many times. join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception. \"\"\" if not self._initialized: raise RuntimeError(\"Thread.__init__() not called\") if not self._started.is_set(): raise RuntimeError(\"cannot join thread before it is started\") if self is current_thread(): raise RuntimeError(\"cannot join current thread\") if timeout is None: self._wait_for_tstate_lock() else: # the behavior of a negative timeout isn't documented, but # historically .join(timeout=x) for x<0 has acted as if timeout=0 self._wait_for_tstate_lock(timeout=max(timeout, 0))","title":"join"},{"location":"reference/blueye/sdk/connection/#pet_watchdog","text":"def pet_watchdog ( self , duration ) View Source def pet_watchdog(self, duration): msg = blueye.protocol.WatchdogCtrl( connection_duration={\"value\": duration}, client_id=self._parent_drone.client_id ) self._socket.send_multipart( [ bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"), blueye.protocol.WatchdogCtrl.serialize(msg), ] )","title":"pet_watchdog"},{"location":"reference/blueye/sdk/connection/#run_3","text":"def run ( self ) Method representing the thread's activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively. View Source def run(self): duration = 0 WATCHDOG_DELAY = 1 while not self._exit_flag.wait(WATCHDOG_DELAY): self.pet_watchdog(duration) duration += 1","title":"run"},{"location":"reference/blueye/sdk/connection/#setdaemon_3","text":"def setDaemon ( self , daemonic ) Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. View Source def setDaemon(self, daemonic): \"\"\"Set whether this thread is a daemon. This method is deprecated, use the .daemon property instead. \"\"\" import warnings warnings.warn('setDaemon() is deprecated, set the daemon attribute instead', DeprecationWarning, stacklevel=2) self.daemon = daemonic","title":"setDaemon"},{"location":"reference/blueye/sdk/connection/#setname_3","text":"def setName ( self , name ) Set the name string for this thread. This method is deprecated, use the name attribute instead. View Source def setName(self, name): \"\"\"Set the name string for this thread. This method is deprecated, use the name attribute instead. \"\"\" import warnings warnings.warn('setName() is deprecated, set the name attribute instead', DeprecationWarning, stacklevel=2) self.name = name","title":"setName"},{"location":"reference/blueye/sdk/connection/#start_3","text":"def start ( self ) Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. View Source def start(self): \"\"\"Start the thread's activity. It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. \"\"\" if not self._initialized: raise RuntimeError(\"thread.__init__() not called\") if self._started.is_set(): raise RuntimeError(\"threads can only be started once\") with _active_limbo_lock: _limbo[self] = self try: _start_new_thread(self._bootstrap, ()) except Exception: with _active_limbo_lock: del _limbo[self] raise self._started.wait()","title":"start"},{"location":"reference/blueye/sdk/connection/#stop_3","text":"def stop ( self ) Stop the watchdog thread started by run() View Source def stop(self): \"\"\"Stop the watchdog thread started by run()\"\"\" self._exit_flag.set()","title":"stop"},{"location":"reference/blueye/sdk/constants/","text":"Module blueye.sdk.constants This file contains constants used by the SDK. View Source \"\"\" This file contains constants used by the SDK. \"\"\" class WaterDensities: \"\"\" Various typical densities for salt water (in kilograms/liter) \"\"\" fresh = 0.997 brackish = 1.011 salty = 1.025 Classes WaterDensities class WaterDensities ( / , * args , ** kwargs ) Various typical densities for salt water (in kilograms/liter) View Source class WaterDensities: \"\"\" Various typical densities for salt water (in kilograms/liter) \"\"\" fresh = 0.997 brackish = 1.011 salty = 1.025 Class variables brackish fresh salty","title":"Constants"},{"location":"reference/blueye/sdk/constants/#module-blueyesdkconstants","text":"This file contains constants used by the SDK. View Source \"\"\" This file contains constants used by the SDK. \"\"\" class WaterDensities: \"\"\" Various typical densities for salt water (in kilograms/liter) \"\"\" fresh = 0.997 brackish = 1.011 salty = 1.025","title":"Module blueye.sdk.constants"},{"location":"reference/blueye/sdk/constants/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/constants/#waterdensities","text":"class WaterDensities ( / , * args , ** kwargs ) Various typical densities for salt water (in kilograms/liter) View Source class WaterDensities: \"\"\" Various typical densities for salt water (in kilograms/liter) \"\"\" fresh = 0.997 brackish = 1.011 salty = 1.025","title":"WaterDensities"},{"location":"reference/blueye/sdk/constants/#class-variables","text":"brackish fresh salty","title":"Class variables"},{"location":"reference/blueye/sdk/drone/","text":"Module blueye.sdk.drone View Source #!/usr/bin/env python3 from __future__ import annotations import logging import time from datetime import datetime from json import JSONDecodeError from typing import Callable, Dict, List, Optional import blueye.protocol import proto import requests from packaging import version from .battery import Battery from .camera import Camera from .connection import CtrlClient, ReqRepClient, TelemetryClient, WatchdogPublisher from .constants import WaterDensities from .logs import Logs from .motion import Motion logger = logging.getLogger(__name__) class Config: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone self._water_density = WaterDensities.salty @property def water_density(self): \"\"\"Get or set the current water density for increased pressure sensor accuracy Older software versions will assume a water density of 1.025 kilograms per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses). \"\"\" return self._water_density @water_density.setter def water_density(self, density: float): self._water_density = density self._parent_drone._ctrl_client.set_water_density(density) def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._req_rep_client.sync_time(time) class _NoConnectionClient: \"\"\"A client that raises a ConnectionError if you use any of its functions\"\"\" def __getattr__(self, name): def method(*args, **kwargs): raise ConnectionError( \"The connection to the drone is not established, \" \"try calling the connect method before retrying\" ) return method class Telemetry: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone def set_msg_publish_frequency(self, msg: proto.message.Message, frequency: float): \"\"\"Set the publishing frequency of a specific telemetry message Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a frequency outside the valid range, or an incorrect message type. *Arguments*: * msg (proto.message.Message): The message to set the frequency of. Needs to be one of the messages in blueye.protocol that end in Tel, eg. blueye.protocol.DepthTel * frequency (float): The frequency in Hz. Valid range is (0 .. 100). \"\"\" resp = self._parent_drone._req_rep_client.set_telemetry_msg_publish_frequency( msg, frequency ) if not resp.success: raise RuntimeError(\"Could not set telemetry message frequency\") def add_msg_callback( self, msg_filter: List[proto.message.Message], callback: Callable[[str, proto.message.Message], None], raw: bool = False, ) -> str: \"\"\"Register a telemetry message callback The callback is called each time a message of the type is received *Arguments*: * msg_filter: A list of message types to register the callback for. Eg. `[blueye.protocol.DepthTel, blueye.protocol.Imu1Tel]`. If the list is empty the callback will be registered for all message types * callback: The callback function. It should be minimal and return as fast as possible to not block the telemetry communication. It is called with two arguments, the message type name and the message object * raw: Pass the raw data instead of the deserialized message to the callback function *Returns*: * uuid: Callback id. Can be used to remove callback in the future \"\"\" uuid_hex = self._parent_drone._telemetry_watcher.add_callback(msg_filter, callback, raw=raw) return uuid_hex def remove_msg_callback(self, callback_id: str) -> Optional[str]: \"\"\"Remove a telemetry message callback *Arguments*: * callback_id: The callback id \"\"\" self._parent_drone._telemetry_watcher.remove_callback(callback_id) def get( self, msg_type: proto.message.Message, deserialize=True ) -> Optional[proto.message.Message | bytes]: \"\"\"Get the latest telemetry message of the specified type *Arguments*: * msg_type: The message type to get. Eg. blueye.protocol.DepthTel * deserialize: If True, the message will be deserialized before being returned. If False, the raw bytes will be returned. *Returns*: * The latest message of the specified type, or None if no message has been received yet \"\"\" try: msg = self._parent_drone._telemetry_watcher.get(msg_type) except KeyError: return None if deserialize: return msg_type.deserialize(msg) else: return msg class Drone: \"\"\"A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip when instantiated, this behaviour can be disabled by setting `auto_connect=False`. \"\"\" def __init__( self, ip=\"192.168.1.101\", auto_connect=True, timeout=3, disconnect_other_clients=False, ): self._ip = ip self.camera = Camera(self, is_guestport_camera=False) self.motion = Motion(self) self.logs = Logs(self) self.config = Config(self) self.battery = Battery(self) self.telemetry = Telemetry(self) self.connected = False self.client_id: int = None self.in_control: bool = False self._watchdog_publisher = _NoConnectionClient() self._telemetry_watcher = _NoConnectionClient() self._req_rep_client = _NoConnectionClient() self._ctrl_client = _NoConnectionClient() if auto_connect is True: self.connect(timeout=timeout, disconnect_other_clients=disconnect_other_clients) def _verify_required_blunux_version(self, requirement: str): \"\"\"Verify that Blunux version is higher than requirement requirement needs to be a string that's able to be parsed by version.parse() Raises a RuntimeError if the Blunux version of the connected drone does not match or exceed the requirement. \"\"\" if version.parse(self.software_version_short) < version.parse(requirement): raise RuntimeError( f\"Blunux version of connected drone is {self.software_version_short}. Version \" f\"{requirement} or higher is required.\" ) def _update_drone_info(self, timeout: float = 3): \"\"\"Request and store information about the connected drone\"\"\" try: response = requests.get( f\"http://{self._ip}/diagnostics/drone_info\", timeout=timeout ).json() except ( requests.ConnectTimeout, requests.ReadTimeout, requests.ConnectionError, JSONDecodeError, ) as e: raise ConnectionError(\"Could not establish connection with drone\") from e try: self.features = list(filter(None, response[\"features\"].split(\",\"))) except KeyError: # Drone versions older than 1.4.7 did not have this field. self.features = [] self.software_version = response[\"sw_version\"] self.software_version_short = self.software_version.split(\"-\")[0] self.serial_number = response[\"serial_number\"] self.uuid = response[\"hardware_id\"] def connect( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 4, disconnect_other_clients: bool = False, ): \"\"\"Establish a connection to the drone Spawns of several threads for receiving telemetry, sending control messages and publishing watchdog messages. When a watchdog message is receieved by the drone the thrusters are armed, so to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. ** Arguments ** - *client_info*: Information about the client connecting, if None the SDK will attempt to read it from the environment - *timeout*: Seconds to wait for connection. The first connection on boot can be a little slower than the following ones - *disconnect_other_clients*: If True, disconnect clients until drone reports that we are in control ** Raises ** - *ConnectionError*: If the connection attempt fails - *RuntimeError*: If the Blunux version of the connected drone is too old \"\"\" logger.info(f\"Attempting to connect to drone at {self._ip}\") self._update_drone_info(timeout=timeout) self._verify_required_blunux_version(\"3.2\") self._telemetry_watcher = TelemetryClient(self) self._ctrl_client = CtrlClient(self) self._watchdog_publisher = WatchdogPublisher(self) self._req_rep_client = ReqRepClient(self) self._telemetry_watcher.start() self._req_rep_client.start() self._ctrl_client.start() self._watchdog_publisher.start() self.ping() connect_resp = self._req_rep_client.connect_client(client_info=client_info) logger.info(f\"Connection successful, client id: {connect_resp.client_id}\") logger.info(f\"Client id in control: {connect_resp.client_id_in_control}\") logger.info(f\"There are {len(connect_resp.connected_clients)-1} other clients connected\") self.client_id = connect_resp.client_id self.in_control = connect_resp.client_id == connect_resp.client_id_in_control self.connected = True if disconnect_other_clients and not self.in_control: self.take_control() if self.in_control: # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time current_time = int(time.time()) time_formatted = datetime.fromtimestamp(current_time).strftime(\"%d. %b %Y %H:%M\") logger.debug(f\"Setting current time to {current_time} ({time_formatted})\") self.config.set_drone_time(current_time) logger.debug(f\"Disabling thrusters\") self.motion.send_thruster_setpoint(0, 0, 0, 0) def disconnect(self): \"\"\"Disconnects the connection, allowing another client to take control of the drone\"\"\" try: self._req_rep_client.disconnect_client(self.client_id) except blueye.protocol.exceptions.ResponseTimeout: # If there's no response the connection is likely already closed, so we can just # continue to stop threads and disconnect pass self._watchdog_publisher.stop() self._telemetry_watcher.stop() self._req_rep_client.stop() self._ctrl_client.stop() self._watchdog_publisher = _NoConnectionClient() self._telemetry_watcher = _NoConnectionClient() self._req_rep_client = _NoConnectionClient() self._ctrl_client = _NoConnectionClient() self.connected = False @property def connected_clients(self) -> Optional[List[blueye.protocol.ConnectedClient]]: \"\"\"Get a list of connected clients\"\"\" clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel) if clients_tel is None: return None else: return list(clients_tel.connected_clients) @property def client_in_control(self) -> Optional[int]: \"\"\"Get the client id of the client in control of the drone\"\"\" clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel) if clients_tel is None: return None else: return clients_tel.client_id_in_control def take_control(self, timeout=1): \"\"\"Take control of the drone, disconnecting other clients Will disconnect other clients until the client is in control of the drone. Raises a RuntimeError if the client could not take control of the drone in the given time. \"\"\" start_time = time.time() client_in_control = self.client_in_control while self.client_id != client_in_control: if time.time() - start_time > timeout: raise RuntimeError(\"Could not take control of the drone in the given time\") resp = self._req_rep_client.disconnect_client(client_in_control) client_in_control = resp.client_id_in_control self.in_control = True @property def lights(self) -> Optional[float]: \"\"\"Get or set the intensity of the drone lights *Arguments*: * brightness (float): Set the intensity of the drone light (0..1) *Returns*: * brightness (float): The intensity of the drone light (0..1) \"\"\" return self.telemetry.get(blueye.protocol.LightsTel).lights.value @lights.setter def lights(self, brightness: float): if not 0 <= brightness <= 1: raise ValueError(\"Error occured while trying to set lights to: \" f\"{brightness}\") self._ctrl_client.set_lights(brightness) @property def depth(self) -> Optional[float]: \"\"\"Get the current depth in meters *Returns*: * depth (float): The depth in meters of water column. \"\"\" depth_tel = self.telemetry.get(blueye.protocol.DepthTel) if depth_tel is None: return None else: return depth_tel.depth.value @property def pose(self) -> Optional[dict]: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" attitude_tel = self.telemetry.get(blueye.protocol.AttitudeTel) if attitude_tel is None: return None attitude = attitude_tel.attitude pose = { \"roll\": (attitude.roll + 360) % 360, \"pitch\": (attitude.pitch + 360) % 360, \"yaw\": (attitude.yaw + 360) % 360, } return pose @property def error_flags(self) -> Optional[Dict[str, bool]]: \"\"\"Get the error flags *Returns*: * error_flags (dict): The error flags as bools in a dictionary \"\"\" error_flags_tel = self.telemetry.get(blueye.protocol.ErrorFlagsTel) if error_flags_tel is None: return None error_flags_msg = error_flags_tel.error_flags error_flags = {} possible_flags = [attr for attr in dir(error_flags_msg) if not attr.startswith(\"__\")] for flag in possible_flags: error_flags[flag] = getattr(error_flags_msg, flag) return error_flags @property def active_video_streams(self) -> Optional[Dict[str, int]]: \"\"\"Get the number of currently active connections to the video stream Every client connected to the RTSP stream (does not matter if it's directly from GStreamer, or from the Blueye app) counts as one connection. \"\"\" n_streamers_msg_tel = self.telemetry.get(blueye.protocol.NStreamersTel) if n_streamers_msg_tel is None: return None n_streamers_msg = n_streamers_msg_tel.n_streamers return {\"main\": n_streamers_msg.main, \"guestport\": n_streamers_msg.guestport} def ping(self, timeout: float = 1.0): \"\"\"Ping drone Raises a ResponseTimeout exception if the drone does not respond within the timeout period. \"\"\" self._req_rep_client.ping(timeout) Variables logger Classes Config class Config ( parent_drone : \"'Drone'\" ) View Source class Config: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone self._water_density = WaterDensities.salty @property def water_density(self): \"\"\"Get or set the current water density for increased pressure sensor accuracy Older software versions will assume a water density of 1.025 kilograms per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses). \"\"\" return self._water_density @water_density.setter def water_density(self, density: float): self._water_density = density self._parent_drone._ctrl_client.set_water_density(density) def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._req_rep_client.sync_time(time) Instance variables water_density Get or set the current water density for increased pressure sensor accuracy Older software versions will assume a water density of 1.025 kilograms per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses). Methods set_drone_time def set_drone_time ( self , time : 'int' ) Set the system for the drone This method is used to set the system time for the drone. The argument time is expected to be a Unix timestamp (ie. the number of seconds since the epoch). View Source def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._req_rep_client.sync_time(time) Drone class Drone ( ip = '192.168.1.101' , auto_connect = True , timeout = 3 , disconnect_other_clients = False ) A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip when instantiated, this behaviour can be disabled by setting auto_connect=False . View Source class Drone: \"\"\"A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip when instantiated, this behaviour can be disabled by setting `auto_connect=False`. \"\"\" def __init__( self, ip=\"192.168.1.101\", auto_connect=True, timeout=3, disconnect_other_clients=False, ): self._ip = ip self.camera = Camera(self, is_guestport_camera=False) self.motion = Motion(self) self.logs = Logs(self) self.config = Config(self) self.battery = Battery(self) self.telemetry = Telemetry(self) self.connected = False self.client_id: int = None self.in_control: bool = False self._watchdog_publisher = _NoConnectionClient() self._telemetry_watcher = _NoConnectionClient() self._req_rep_client = _NoConnectionClient() self._ctrl_client = _NoConnectionClient() if auto_connect is True: self.connect(timeout=timeout, disconnect_other_clients=disconnect_other_clients) def _verify_required_blunux_version(self, requirement: str): \"\"\"Verify that Blunux version is higher than requirement requirement needs to be a string that's able to be parsed by version.parse() Raises a RuntimeError if the Blunux version of the connected drone does not match or exceed the requirement. \"\"\" if version.parse(self.software_version_short) < version.parse(requirement): raise RuntimeError( f\"Blunux version of connected drone is {self.software_version_short}. Version \" f\"{requirement} or higher is required.\" ) def _update_drone_info(self, timeout: float = 3): \"\"\"Request and store information about the connected drone\"\"\" try: response = requests.get( f\"http://{self._ip}/diagnostics/drone_info\", timeout=timeout ).json() except ( requests.ConnectTimeout, requests.ReadTimeout, requests.ConnectionError, JSONDecodeError, ) as e: raise ConnectionError(\"Could not establish connection with drone\") from e try: self.features = list(filter(None, response[\"features\"].split(\",\"))) except KeyError: # Drone versions older than 1.4.7 did not have this field. self.features = [] self.software_version = response[\"sw_version\"] self.software_version_short = self.software_version.split(\"-\")[0] self.serial_number = response[\"serial_number\"] self.uuid = response[\"hardware_id\"] def connect( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 4, disconnect_other_clients: bool = False, ): \"\"\"Establish a connection to the drone Spawns of several threads for receiving telemetry, sending control messages and publishing watchdog messages. When a watchdog message is receieved by the drone the thrusters are armed, so to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. ** Arguments ** - *client_info*: Information about the client connecting, if None the SDK will attempt to read it from the environment - *timeout*: Seconds to wait for connection. The first connection on boot can be a little slower than the following ones - *disconnect_other_clients*: If True, disconnect clients until drone reports that we are in control ** Raises ** - *ConnectionError*: If the connection attempt fails - *RuntimeError*: If the Blunux version of the connected drone is too old \"\"\" logger.info(f\"Attempting to connect to drone at {self._ip}\") self._update_drone_info(timeout=timeout) self._verify_required_blunux_version(\"3.2\") self._telemetry_watcher = TelemetryClient(self) self._ctrl_client = CtrlClient(self) self._watchdog_publisher = WatchdogPublisher(self) self._req_rep_client = ReqRepClient(self) self._telemetry_watcher.start() self._req_rep_client.start() self._ctrl_client.start() self._watchdog_publisher.start() self.ping() connect_resp = self._req_rep_client.connect_client(client_info=client_info) logger.info(f\"Connection successful, client id: {connect_resp.client_id}\") logger.info(f\"Client id in control: {connect_resp.client_id_in_control}\") logger.info(f\"There are {len(connect_resp.connected_clients)-1} other clients connected\") self.client_id = connect_resp.client_id self.in_control = connect_resp.client_id == connect_resp.client_id_in_control self.connected = True if disconnect_other_clients and not self.in_control: self.take_control() if self.in_control: # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time current_time = int(time.time()) time_formatted = datetime.fromtimestamp(current_time).strftime(\"%d. %b %Y %H:%M\") logger.debug(f\"Setting current time to {current_time} ({time_formatted})\") self.config.set_drone_time(current_time) logger.debug(f\"Disabling thrusters\") self.motion.send_thruster_setpoint(0, 0, 0, 0) def disconnect(self): \"\"\"Disconnects the connection, allowing another client to take control of the drone\"\"\" try: self._req_rep_client.disconnect_client(self.client_id) except blueye.protocol.exceptions.ResponseTimeout: # If there's no response the connection is likely already closed, so we can just # continue to stop threads and disconnect pass self._watchdog_publisher.stop() self._telemetry_watcher.stop() self._req_rep_client.stop() self._ctrl_client.stop() self._watchdog_publisher = _NoConnectionClient() self._telemetry_watcher = _NoConnectionClient() self._req_rep_client = _NoConnectionClient() self._ctrl_client = _NoConnectionClient() self.connected = False @property def connected_clients(self) -> Optional[List[blueye.protocol.ConnectedClient]]: \"\"\"Get a list of connected clients\"\"\" clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel) if clients_tel is None: return None else: return list(clients_tel.connected_clients) @property def client_in_control(self) -> Optional[int]: \"\"\"Get the client id of the client in control of the drone\"\"\" clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel) if clients_tel is None: return None else: return clients_tel.client_id_in_control def take_control(self, timeout=1): \"\"\"Take control of the drone, disconnecting other clients Will disconnect other clients until the client is in control of the drone. Raises a RuntimeError if the client could not take control of the drone in the given time. \"\"\" start_time = time.time() client_in_control = self.client_in_control while self.client_id != client_in_control: if time.time() - start_time > timeout: raise RuntimeError(\"Could not take control of the drone in the given time\") resp = self._req_rep_client.disconnect_client(client_in_control) client_in_control = resp.client_id_in_control self.in_control = True @property def lights(self) -> Optional[float]: \"\"\"Get or set the intensity of the drone lights *Arguments*: * brightness (float): Set the intensity of the drone light (0..1) *Returns*: * brightness (float): The intensity of the drone light (0..1) \"\"\" return self.telemetry.get(blueye.protocol.LightsTel).lights.value @lights.setter def lights(self, brightness: float): if not 0 <= brightness <= 1: raise ValueError(\"Error occured while trying to set lights to: \" f\"{brightness}\") self._ctrl_client.set_lights(brightness) @property def depth(self) -> Optional[float]: \"\"\"Get the current depth in meters *Returns*: * depth (float): The depth in meters of water column. \"\"\" depth_tel = self.telemetry.get(blueye.protocol.DepthTel) if depth_tel is None: return None else: return depth_tel.depth.value @property def pose(self) -> Optional[dict]: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" attitude_tel = self.telemetry.get(blueye.protocol.AttitudeTel) if attitude_tel is None: return None attitude = attitude_tel.attitude pose = { \"roll\": (attitude.roll + 360) % 360, \"pitch\": (attitude.pitch + 360) % 360, \"yaw\": (attitude.yaw + 360) % 360, } return pose @property def error_flags(self) -> Optional[Dict[str, bool]]: \"\"\"Get the error flags *Returns*: * error_flags (dict): The error flags as bools in a dictionary \"\"\" error_flags_tel = self.telemetry.get(blueye.protocol.ErrorFlagsTel) if error_flags_tel is None: return None error_flags_msg = error_flags_tel.error_flags error_flags = {} possible_flags = [attr for attr in dir(error_flags_msg) if not attr.startswith(\"__\")] for flag in possible_flags: error_flags[flag] = getattr(error_flags_msg, flag) return error_flags @property def active_video_streams(self) -> Optional[Dict[str, int]]: \"\"\"Get the number of currently active connections to the video stream Every client connected to the RTSP stream (does not matter if it's directly from GStreamer, or from the Blueye app) counts as one connection. \"\"\" n_streamers_msg_tel = self.telemetry.get(blueye.protocol.NStreamersTel) if n_streamers_msg_tel is None: return None n_streamers_msg = n_streamers_msg_tel.n_streamers return {\"main\": n_streamers_msg.main, \"guestport\": n_streamers_msg.guestport} def ping(self, timeout: float = 1.0): \"\"\"Ping drone Raises a ResponseTimeout exception if the drone does not respond within the timeout period. \"\"\" self._req_rep_client.ping(timeout) Instance variables active_video_streams Get the number of currently active connections to the video stream Every client connected to the RTSP stream (does not matter if it's directly from GStreamer, or from the Blueye app) counts as one connection. client_in_control Get the client id of the client in control of the drone connected_clients Get a list of connected clients depth Get the current depth in meters Returns : depth (float): The depth in meters of water column. error_flags Get the error flags Returns : error_flags (dict): The error flags as bools in a dictionary lights Get or set the intensity of the drone lights Arguments : brightness (float): Set the intensity of the drone light (0..1) Returns : brightness (float): The intensity of the drone light (0..1) pose Get the current orientation of the drone Returns : pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. Methods connect def connect ( self , client_info : 'blueye.protocol.ClientInfo' = None , timeout : 'float' = 4 , disconnect_other_clients : 'bool' = False ) Establish a connection to the drone Spawns of several threads for receiving telemetry, sending control messages and publishing watchdog messages. When a watchdog message is receieved by the drone the thrusters are armed, so to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. Arguments - client_info : Information about the client connecting, if None the SDK will attempt to read it from the environment - timeout : Seconds to wait for connection. The first connection on boot can be a little slower than the following ones - disconnect_other_clients : If True, disconnect clients until drone reports that we are in control Raises - ConnectionError : If the connection attempt fails - RuntimeError : If the Blunux version of the connected drone is too old View Source def connect( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 4, disconnect_other_clients: bool = False, ): \"\"\"Establish a connection to the drone Spawns of several threads for receiving telemetry, sending control messages and publishing watchdog messages. When a watchdog message is receieved by the drone the thrusters are armed, so to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. ** Arguments ** - *client_info*: Information about the client connecting, if None the SDK will attempt to read it from the environment - *timeout*: Seconds to wait for connection. The first connection on boot can be a little slower than the following ones - *disconnect_other_clients*: If True, disconnect clients until drone reports that we are in control ** Raises ** - *ConnectionError*: If the connection attempt fails - *RuntimeError*: If the Blunux version of the connected drone is too old \"\"\" logger.info(f\"Attempting to connect to drone at {self._ip}\") self._update_drone_info(timeout=timeout) self._verify_required_blunux_version(\"3.2\") self._telemetry_watcher = TelemetryClient(self) self._ctrl_client = CtrlClient(self) self._watchdog_publisher = WatchdogPublisher(self) self._req_rep_client = ReqRepClient(self) self._telemetry_watcher.start() self._req_rep_client.start() self._ctrl_client.start() self._watchdog_publisher.start() self.ping() connect_resp = self._req_rep_client.connect_client(client_info=client_info) logger.info(f\"Connection successful, client id: {connect_resp.client_id}\") logger.info(f\"Client id in control: {connect_resp.client_id_in_control}\") logger.info(f\"There are {len(connect_resp.connected_clients)-1} other clients connected\") self.client_id = connect_resp.client_id self.in_control = connect_resp.client_id == connect_resp.client_id_in_control self.connected = True if disconnect_other_clients and not self.in_control: self.take_control() if self.in_control: # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time current_time = int(time.time()) time_formatted = datetime.fromtimestamp(current_time).strftime(\"%d. %b %Y %H:%M\") logger.debug(f\"Setting current time to {current_time} ({time_formatted})\") self.config.set_drone_time(current_time) logger.debug(f\"Disabling thrusters\") self.motion.send_thruster_setpoint(0, 0, 0, 0) disconnect def disconnect ( self ) Disconnects the connection, allowing another client to take control of the drone View Source def disconnect(self): \"\"\"Disconnects the connection, allowing another client to take control of the drone\"\"\" try: self._req_rep_client.disconnect_client(self.client_id) except blueye.protocol.exceptions.ResponseTimeout: # If there's no response the connection is likely already closed, so we can just # continue to stop threads and disconnect pass self._watchdog_publisher.stop() self._telemetry_watcher.stop() self._req_rep_client.stop() self._ctrl_client.stop() self._watchdog_publisher = _NoConnectionClient() self._telemetry_watcher = _NoConnectionClient() self._req_rep_client = _NoConnectionClient() self._ctrl_client = _NoConnectionClient() self.connected = False ping def ping ( self , timeout : 'float' = 1.0 ) Ping drone Raises a ResponseTimeout exception if the drone does not respond within the timeout period. View Source def ping(self, timeout: float = 1.0): \"\"\"Ping drone Raises a ResponseTimeout exception if the drone does not respond within the timeout period. \"\"\" self._req_rep_client.ping(timeout) take_control def take_control ( self , timeout = 1 ) Take control of the drone, disconnecting other clients Will disconnect other clients until the client is in control of the drone. Raises a RuntimeError if the client could not take control of the drone in the given time. View Source def take_control(self, timeout=1): \"\"\"Take control of the drone, disconnecting other clients Will disconnect other clients until the client is in control of the drone. Raises a RuntimeError if the client could not take control of the drone in the given time. \"\"\" start_time = time.time() client_in_control = self.client_in_control while self.client_id != client_in_control: if time.time() - start_time > timeout: raise RuntimeError(\"Could not take control of the drone in the given time\") resp = self._req_rep_client.disconnect_client(client_in_control) client_in_control = resp.client_id_in_control self.in_control = True Telemetry class Telemetry ( parent_drone : \"'Drone'\" ) View Source class Telemetry: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone def set_msg_publish_frequency(self, msg: proto.message.Message, frequency: float): \"\"\"Set the publishing frequency of a specific telemetry message Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a frequency outside the valid range, or an incorrect message type. *Arguments*: * msg (proto.message.Message): The message to set the frequency of. Needs to be one of the messages in blueye.protocol that end in Tel, eg. blueye.protocol.DepthTel * frequency (float): The frequency in Hz. Valid range is (0 .. 100). \"\"\" resp = self._parent_drone._req_rep_client.set_telemetry_msg_publish_frequency( msg, frequency ) if not resp.success: raise RuntimeError(\"Could not set telemetry message frequency\") def add_msg_callback( self, msg_filter: List[proto.message.Message], callback: Callable[[str, proto.message.Message], None], raw: bool = False, ) -> str: \"\"\"Register a telemetry message callback The callback is called each time a message of the type is received *Arguments*: * msg_filter: A list of message types to register the callback for. Eg. `[blueye.protocol.DepthTel, blueye.protocol.Imu1Tel]`. If the list is empty the callback will be registered for all message types * callback: The callback function. It should be minimal and return as fast as possible to not block the telemetry communication. It is called with two arguments, the message type name and the message object * raw: Pass the raw data instead of the deserialized message to the callback function *Returns*: * uuid: Callback id. Can be used to remove callback in the future \"\"\" uuid_hex = self._parent_drone._telemetry_watcher.add_callback(msg_filter, callback, raw=raw) return uuid_hex def remove_msg_callback(self, callback_id: str) -> Optional[str]: \"\"\"Remove a telemetry message callback *Arguments*: * callback_id: The callback id \"\"\" self._parent_drone._telemetry_watcher.remove_callback(callback_id) def get( self, msg_type: proto.message.Message, deserialize=True ) -> Optional[proto.message.Message | bytes]: \"\"\"Get the latest telemetry message of the specified type *Arguments*: * msg_type: The message type to get. Eg. blueye.protocol.DepthTel * deserialize: If True, the message will be deserialized before being returned. If False, the raw bytes will be returned. *Returns*: * The latest message of the specified type, or None if no message has been received yet \"\"\" try: msg = self._parent_drone._telemetry_watcher.get(msg_type) except KeyError: return None if deserialize: return msg_type.deserialize(msg) else: return msg Methods add_msg_callback def add_msg_callback ( self , msg_filter : 'List[proto.message.Message]' , callback : 'Callable[[str, proto.message.Message], None]' , raw : 'bool' = False ) -> 'str' Register a telemetry message callback The callback is called each time a message of the type is received Arguments : msg_filter: A list of message types to register the callback for. Eg. [blueye.protocol.DepthTel, blueye.protocol.Imu1Tel] . If the list is empty the callback will be registered for all message types callback: The callback function. It should be minimal and return as fast as possible to not block the telemetry communication. It is called with two arguments, the message type name and the message object raw: Pass the raw data instead of the deserialized message to the callback function Returns : uuid: Callback id. Can be used to remove callback in the future View Source def add_msg_callback( self, msg_filter: List[proto.message.Message], callback: Callable[[str, proto.message.Message], None], raw: bool = False, ) -> str: \"\"\"Register a telemetry message callback The callback is called each time a message of the type is received *Arguments*: * msg_filter: A list of message types to register the callback for. Eg. `[blueye.protocol.DepthTel, blueye.protocol.Imu1Tel]`. If the list is empty the callback will be registered for all message types * callback: The callback function. It should be minimal and return as fast as possible to not block the telemetry communication. It is called with two arguments, the message type name and the message object * raw: Pass the raw data instead of the deserialized message to the callback function *Returns*: * uuid: Callback id. Can be used to remove callback in the future \"\"\" uuid_hex = self._parent_drone._telemetry_watcher.add_callback(msg_filter, callback, raw=raw) return uuid_hex get def get ( self , msg_type : 'proto.message.Message' , deserialize = True ) -> 'Optional[proto.message.Message | bytes]' Get the latest telemetry message of the specified type Arguments : msg_type: The message type to get. Eg. blueye.protocol.DepthTel deserialize: If True, the message will be deserialized before being returned. If False, the raw bytes will be returned. Returns : The latest message of the specified type, or None if no message has been received yet View Source def get( self, msg_type: proto.message.Message, deserialize=True ) -> Optional[proto.message.Message | bytes]: \"\"\"Get the latest telemetry message of the specified type *Arguments*: * msg_type: The message type to get. Eg. blueye.protocol.DepthTel * deserialize: If True, the message will be deserialized before being returned. If False, the raw bytes will be returned. *Returns*: * The latest message of the specified type, or None if no message has been received yet \"\"\" try: msg = self._parent_drone._telemetry_watcher.get(msg_type) except KeyError: return None if deserialize: return msg_type.deserialize(msg) else: return msg remove_msg_callback def remove_msg_callback ( self , callback_id : 'str' ) -> 'Optional[str]' Remove a telemetry message callback Arguments : callback_id: The callback id View Source def remove_msg_callback(self, callback_id: str) -> Optional[str]: \"\"\"Remove a telemetry message callback *Arguments*: * callback_id: The callback id \"\"\" self._parent_drone._telemetry_watcher.remove_callback(callback_id) set_msg_publish_frequency def set_msg_publish_frequency ( self , msg : 'proto.message.Message' , frequency : 'float' ) Set the publishing frequency of a specific telemetry message Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a frequency outside the valid range, or an incorrect message type. Arguments : msg (proto.message.Message): The message to set the frequency of. Needs to be one of the messages in blueye.protocol that end in Tel, eg. blueye.protocol.DepthTel frequency (float): The frequency in Hz. Valid range is (0 .. 100). View Source def set_msg_publish_frequency(self, msg: proto.message.Message, frequency: float): \"\"\"Set the publishing frequency of a specific telemetry message Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a frequency outside the valid range, or an incorrect message type. *Arguments*: * msg (proto.message.Message): The message to set the frequency of. Needs to be one of the messages in blueye.protocol that end in Tel, eg. blueye.protocol.DepthTel * frequency (float): The frequency in Hz. Valid range is (0 .. 100). \"\"\" resp = self._parent_drone._req_rep_client.set_telemetry_msg_publish_frequency( msg, frequency ) if not resp.success: raise RuntimeError(\"Could not set telemetry message frequency\")","title":"Drone"},{"location":"reference/blueye/sdk/drone/#module-blueyesdkdrone","text":"View Source #!/usr/bin/env python3 from __future__ import annotations import logging import time from datetime import datetime from json import JSONDecodeError from typing import Callable, Dict, List, Optional import blueye.protocol import proto import requests from packaging import version from .battery import Battery from .camera import Camera from .connection import CtrlClient, ReqRepClient, TelemetryClient, WatchdogPublisher from .constants import WaterDensities from .logs import Logs from .motion import Motion logger = logging.getLogger(__name__) class Config: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone self._water_density = WaterDensities.salty @property def water_density(self): \"\"\"Get or set the current water density for increased pressure sensor accuracy Older software versions will assume a water density of 1.025 kilograms per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses). \"\"\" return self._water_density @water_density.setter def water_density(self, density: float): self._water_density = density self._parent_drone._ctrl_client.set_water_density(density) def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._req_rep_client.sync_time(time) class _NoConnectionClient: \"\"\"A client that raises a ConnectionError if you use any of its functions\"\"\" def __getattr__(self, name): def method(*args, **kwargs): raise ConnectionError( \"The connection to the drone is not established, \" \"try calling the connect method before retrying\" ) return method class Telemetry: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone def set_msg_publish_frequency(self, msg: proto.message.Message, frequency: float): \"\"\"Set the publishing frequency of a specific telemetry message Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a frequency outside the valid range, or an incorrect message type. *Arguments*: * msg (proto.message.Message): The message to set the frequency of. Needs to be one of the messages in blueye.protocol that end in Tel, eg. blueye.protocol.DepthTel * frequency (float): The frequency in Hz. Valid range is (0 .. 100). \"\"\" resp = self._parent_drone._req_rep_client.set_telemetry_msg_publish_frequency( msg, frequency ) if not resp.success: raise RuntimeError(\"Could not set telemetry message frequency\") def add_msg_callback( self, msg_filter: List[proto.message.Message], callback: Callable[[str, proto.message.Message], None], raw: bool = False, ) -> str: \"\"\"Register a telemetry message callback The callback is called each time a message of the type is received *Arguments*: * msg_filter: A list of message types to register the callback for. Eg. `[blueye.protocol.DepthTel, blueye.protocol.Imu1Tel]`. If the list is empty the callback will be registered for all message types * callback: The callback function. It should be minimal and return as fast as possible to not block the telemetry communication. It is called with two arguments, the message type name and the message object * raw: Pass the raw data instead of the deserialized message to the callback function *Returns*: * uuid: Callback id. Can be used to remove callback in the future \"\"\" uuid_hex = self._parent_drone._telemetry_watcher.add_callback(msg_filter, callback, raw=raw) return uuid_hex def remove_msg_callback(self, callback_id: str) -> Optional[str]: \"\"\"Remove a telemetry message callback *Arguments*: * callback_id: The callback id \"\"\" self._parent_drone._telemetry_watcher.remove_callback(callback_id) def get( self, msg_type: proto.message.Message, deserialize=True ) -> Optional[proto.message.Message | bytes]: \"\"\"Get the latest telemetry message of the specified type *Arguments*: * msg_type: The message type to get. Eg. blueye.protocol.DepthTel * deserialize: If True, the message will be deserialized before being returned. If False, the raw bytes will be returned. *Returns*: * The latest message of the specified type, or None if no message has been received yet \"\"\" try: msg = self._parent_drone._telemetry_watcher.get(msg_type) except KeyError: return None if deserialize: return msg_type.deserialize(msg) else: return msg class Drone: \"\"\"A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip when instantiated, this behaviour can be disabled by setting `auto_connect=False`. \"\"\" def __init__( self, ip=\"192.168.1.101\", auto_connect=True, timeout=3, disconnect_other_clients=False, ): self._ip = ip self.camera = Camera(self, is_guestport_camera=False) self.motion = Motion(self) self.logs = Logs(self) self.config = Config(self) self.battery = Battery(self) self.telemetry = Telemetry(self) self.connected = False self.client_id: int = None self.in_control: bool = False self._watchdog_publisher = _NoConnectionClient() self._telemetry_watcher = _NoConnectionClient() self._req_rep_client = _NoConnectionClient() self._ctrl_client = _NoConnectionClient() if auto_connect is True: self.connect(timeout=timeout, disconnect_other_clients=disconnect_other_clients) def _verify_required_blunux_version(self, requirement: str): \"\"\"Verify that Blunux version is higher than requirement requirement needs to be a string that's able to be parsed by version.parse() Raises a RuntimeError if the Blunux version of the connected drone does not match or exceed the requirement. \"\"\" if version.parse(self.software_version_short) < version.parse(requirement): raise RuntimeError( f\"Blunux version of connected drone is {self.software_version_short}. Version \" f\"{requirement} or higher is required.\" ) def _update_drone_info(self, timeout: float = 3): \"\"\"Request and store information about the connected drone\"\"\" try: response = requests.get( f\"http://{self._ip}/diagnostics/drone_info\", timeout=timeout ).json() except ( requests.ConnectTimeout, requests.ReadTimeout, requests.ConnectionError, JSONDecodeError, ) as e: raise ConnectionError(\"Could not establish connection with drone\") from e try: self.features = list(filter(None, response[\"features\"].split(\",\"))) except KeyError: # Drone versions older than 1.4.7 did not have this field. self.features = [] self.software_version = response[\"sw_version\"] self.software_version_short = self.software_version.split(\"-\")[0] self.serial_number = response[\"serial_number\"] self.uuid = response[\"hardware_id\"] def connect( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 4, disconnect_other_clients: bool = False, ): \"\"\"Establish a connection to the drone Spawns of several threads for receiving telemetry, sending control messages and publishing watchdog messages. When a watchdog message is receieved by the drone the thrusters are armed, so to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. ** Arguments ** - *client_info*: Information about the client connecting, if None the SDK will attempt to read it from the environment - *timeout*: Seconds to wait for connection. The first connection on boot can be a little slower than the following ones - *disconnect_other_clients*: If True, disconnect clients until drone reports that we are in control ** Raises ** - *ConnectionError*: If the connection attempt fails - *RuntimeError*: If the Blunux version of the connected drone is too old \"\"\" logger.info(f\"Attempting to connect to drone at {self._ip}\") self._update_drone_info(timeout=timeout) self._verify_required_blunux_version(\"3.2\") self._telemetry_watcher = TelemetryClient(self) self._ctrl_client = CtrlClient(self) self._watchdog_publisher = WatchdogPublisher(self) self._req_rep_client = ReqRepClient(self) self._telemetry_watcher.start() self._req_rep_client.start() self._ctrl_client.start() self._watchdog_publisher.start() self.ping() connect_resp = self._req_rep_client.connect_client(client_info=client_info) logger.info(f\"Connection successful, client id: {connect_resp.client_id}\") logger.info(f\"Client id in control: {connect_resp.client_id_in_control}\") logger.info(f\"There are {len(connect_resp.connected_clients)-1} other clients connected\") self.client_id = connect_resp.client_id self.in_control = connect_resp.client_id == connect_resp.client_id_in_control self.connected = True if disconnect_other_clients and not self.in_control: self.take_control() if self.in_control: # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time current_time = int(time.time()) time_formatted = datetime.fromtimestamp(current_time).strftime(\"%d. %b %Y %H:%M\") logger.debug(f\"Setting current time to {current_time} ({time_formatted})\") self.config.set_drone_time(current_time) logger.debug(f\"Disabling thrusters\") self.motion.send_thruster_setpoint(0, 0, 0, 0) def disconnect(self): \"\"\"Disconnects the connection, allowing another client to take control of the drone\"\"\" try: self._req_rep_client.disconnect_client(self.client_id) except blueye.protocol.exceptions.ResponseTimeout: # If there's no response the connection is likely already closed, so we can just # continue to stop threads and disconnect pass self._watchdog_publisher.stop() self._telemetry_watcher.stop() self._req_rep_client.stop() self._ctrl_client.stop() self._watchdog_publisher = _NoConnectionClient() self._telemetry_watcher = _NoConnectionClient() self._req_rep_client = _NoConnectionClient() self._ctrl_client = _NoConnectionClient() self.connected = False @property def connected_clients(self) -> Optional[List[blueye.protocol.ConnectedClient]]: \"\"\"Get a list of connected clients\"\"\" clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel) if clients_tel is None: return None else: return list(clients_tel.connected_clients) @property def client_in_control(self) -> Optional[int]: \"\"\"Get the client id of the client in control of the drone\"\"\" clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel) if clients_tel is None: return None else: return clients_tel.client_id_in_control def take_control(self, timeout=1): \"\"\"Take control of the drone, disconnecting other clients Will disconnect other clients until the client is in control of the drone. Raises a RuntimeError if the client could not take control of the drone in the given time. \"\"\" start_time = time.time() client_in_control = self.client_in_control while self.client_id != client_in_control: if time.time() - start_time > timeout: raise RuntimeError(\"Could not take control of the drone in the given time\") resp = self._req_rep_client.disconnect_client(client_in_control) client_in_control = resp.client_id_in_control self.in_control = True @property def lights(self) -> Optional[float]: \"\"\"Get or set the intensity of the drone lights *Arguments*: * brightness (float): Set the intensity of the drone light (0..1) *Returns*: * brightness (float): The intensity of the drone light (0..1) \"\"\" return self.telemetry.get(blueye.protocol.LightsTel).lights.value @lights.setter def lights(self, brightness: float): if not 0 <= brightness <= 1: raise ValueError(\"Error occured while trying to set lights to: \" f\"{brightness}\") self._ctrl_client.set_lights(brightness) @property def depth(self) -> Optional[float]: \"\"\"Get the current depth in meters *Returns*: * depth (float): The depth in meters of water column. \"\"\" depth_tel = self.telemetry.get(blueye.protocol.DepthTel) if depth_tel is None: return None else: return depth_tel.depth.value @property def pose(self) -> Optional[dict]: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" attitude_tel = self.telemetry.get(blueye.protocol.AttitudeTel) if attitude_tel is None: return None attitude = attitude_tel.attitude pose = { \"roll\": (attitude.roll + 360) % 360, \"pitch\": (attitude.pitch + 360) % 360, \"yaw\": (attitude.yaw + 360) % 360, } return pose @property def error_flags(self) -> Optional[Dict[str, bool]]: \"\"\"Get the error flags *Returns*: * error_flags (dict): The error flags as bools in a dictionary \"\"\" error_flags_tel = self.telemetry.get(blueye.protocol.ErrorFlagsTel) if error_flags_tel is None: return None error_flags_msg = error_flags_tel.error_flags error_flags = {} possible_flags = [attr for attr in dir(error_flags_msg) if not attr.startswith(\"__\")] for flag in possible_flags: error_flags[flag] = getattr(error_flags_msg, flag) return error_flags @property def active_video_streams(self) -> Optional[Dict[str, int]]: \"\"\"Get the number of currently active connections to the video stream Every client connected to the RTSP stream (does not matter if it's directly from GStreamer, or from the Blueye app) counts as one connection. \"\"\" n_streamers_msg_tel = self.telemetry.get(blueye.protocol.NStreamersTel) if n_streamers_msg_tel is None: return None n_streamers_msg = n_streamers_msg_tel.n_streamers return {\"main\": n_streamers_msg.main, \"guestport\": n_streamers_msg.guestport} def ping(self, timeout: float = 1.0): \"\"\"Ping drone Raises a ResponseTimeout exception if the drone does not respond within the timeout period. \"\"\" self._req_rep_client.ping(timeout)","title":"Module blueye.sdk.drone"},{"location":"reference/blueye/sdk/drone/#variables","text":"logger","title":"Variables"},{"location":"reference/blueye/sdk/drone/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/drone/#config","text":"class Config ( parent_drone : \"'Drone'\" ) View Source class Config: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone self._water_density = WaterDensities.salty @property def water_density(self): \"\"\"Get or set the current water density for increased pressure sensor accuracy Older software versions will assume a water density of 1.025 kilograms per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses). \"\"\" return self._water_density @water_density.setter def water_density(self, density: float): self._water_density = density self._parent_drone._ctrl_client.set_water_density(density) def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._req_rep_client.sync_time(time)","title":"Config"},{"location":"reference/blueye/sdk/drone/#instance-variables","text":"water_density Get or set the current water density for increased pressure sensor accuracy Older software versions will assume a water density of 1.025 kilograms per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses).","title":"Instance variables"},{"location":"reference/blueye/sdk/drone/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/drone/#set_drone_time","text":"def set_drone_time ( self , time : 'int' ) Set the system for the drone This method is used to set the system time for the drone. The argument time is expected to be a Unix timestamp (ie. the number of seconds since the epoch). View Source def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._req_rep_client.sync_time(time)","title":"set_drone_time"},{"location":"reference/blueye/sdk/drone/#drone","text":"class Drone ( ip = '192.168.1.101' , auto_connect = True , timeout = 3 , disconnect_other_clients = False ) A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip when instantiated, this behaviour can be disabled by setting auto_connect=False . View Source class Drone: \"\"\"A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip when instantiated, this behaviour can be disabled by setting `auto_connect=False`. \"\"\" def __init__( self, ip=\"192.168.1.101\", auto_connect=True, timeout=3, disconnect_other_clients=False, ): self._ip = ip self.camera = Camera(self, is_guestport_camera=False) self.motion = Motion(self) self.logs = Logs(self) self.config = Config(self) self.battery = Battery(self) self.telemetry = Telemetry(self) self.connected = False self.client_id: int = None self.in_control: bool = False self._watchdog_publisher = _NoConnectionClient() self._telemetry_watcher = _NoConnectionClient() self._req_rep_client = _NoConnectionClient() self._ctrl_client = _NoConnectionClient() if auto_connect is True: self.connect(timeout=timeout, disconnect_other_clients=disconnect_other_clients) def _verify_required_blunux_version(self, requirement: str): \"\"\"Verify that Blunux version is higher than requirement requirement needs to be a string that's able to be parsed by version.parse() Raises a RuntimeError if the Blunux version of the connected drone does not match or exceed the requirement. \"\"\" if version.parse(self.software_version_short) < version.parse(requirement): raise RuntimeError( f\"Blunux version of connected drone is {self.software_version_short}. Version \" f\"{requirement} or higher is required.\" ) def _update_drone_info(self, timeout: float = 3): \"\"\"Request and store information about the connected drone\"\"\" try: response = requests.get( f\"http://{self._ip}/diagnostics/drone_info\", timeout=timeout ).json() except ( requests.ConnectTimeout, requests.ReadTimeout, requests.ConnectionError, JSONDecodeError, ) as e: raise ConnectionError(\"Could not establish connection with drone\") from e try: self.features = list(filter(None, response[\"features\"].split(\",\"))) except KeyError: # Drone versions older than 1.4.7 did not have this field. self.features = [] self.software_version = response[\"sw_version\"] self.software_version_short = self.software_version.split(\"-\")[0] self.serial_number = response[\"serial_number\"] self.uuid = response[\"hardware_id\"] def connect( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 4, disconnect_other_clients: bool = False, ): \"\"\"Establish a connection to the drone Spawns of several threads for receiving telemetry, sending control messages and publishing watchdog messages. When a watchdog message is receieved by the drone the thrusters are armed, so to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. ** Arguments ** - *client_info*: Information about the client connecting, if None the SDK will attempt to read it from the environment - *timeout*: Seconds to wait for connection. The first connection on boot can be a little slower than the following ones - *disconnect_other_clients*: If True, disconnect clients until drone reports that we are in control ** Raises ** - *ConnectionError*: If the connection attempt fails - *RuntimeError*: If the Blunux version of the connected drone is too old \"\"\" logger.info(f\"Attempting to connect to drone at {self._ip}\") self._update_drone_info(timeout=timeout) self._verify_required_blunux_version(\"3.2\") self._telemetry_watcher = TelemetryClient(self) self._ctrl_client = CtrlClient(self) self._watchdog_publisher = WatchdogPublisher(self) self._req_rep_client = ReqRepClient(self) self._telemetry_watcher.start() self._req_rep_client.start() self._ctrl_client.start() self._watchdog_publisher.start() self.ping() connect_resp = self._req_rep_client.connect_client(client_info=client_info) logger.info(f\"Connection successful, client id: {connect_resp.client_id}\") logger.info(f\"Client id in control: {connect_resp.client_id_in_control}\") logger.info(f\"There are {len(connect_resp.connected_clients)-1} other clients connected\") self.client_id = connect_resp.client_id self.in_control = connect_resp.client_id == connect_resp.client_id_in_control self.connected = True if disconnect_other_clients and not self.in_control: self.take_control() if self.in_control: # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time current_time = int(time.time()) time_formatted = datetime.fromtimestamp(current_time).strftime(\"%d. %b %Y %H:%M\") logger.debug(f\"Setting current time to {current_time} ({time_formatted})\") self.config.set_drone_time(current_time) logger.debug(f\"Disabling thrusters\") self.motion.send_thruster_setpoint(0, 0, 0, 0) def disconnect(self): \"\"\"Disconnects the connection, allowing another client to take control of the drone\"\"\" try: self._req_rep_client.disconnect_client(self.client_id) except blueye.protocol.exceptions.ResponseTimeout: # If there's no response the connection is likely already closed, so we can just # continue to stop threads and disconnect pass self._watchdog_publisher.stop() self._telemetry_watcher.stop() self._req_rep_client.stop() self._ctrl_client.stop() self._watchdog_publisher = _NoConnectionClient() self._telemetry_watcher = _NoConnectionClient() self._req_rep_client = _NoConnectionClient() self._ctrl_client = _NoConnectionClient() self.connected = False @property def connected_clients(self) -> Optional[List[blueye.protocol.ConnectedClient]]: \"\"\"Get a list of connected clients\"\"\" clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel) if clients_tel is None: return None else: return list(clients_tel.connected_clients) @property def client_in_control(self) -> Optional[int]: \"\"\"Get the client id of the client in control of the drone\"\"\" clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel) if clients_tel is None: return None else: return clients_tel.client_id_in_control def take_control(self, timeout=1): \"\"\"Take control of the drone, disconnecting other clients Will disconnect other clients until the client is in control of the drone. Raises a RuntimeError if the client could not take control of the drone in the given time. \"\"\" start_time = time.time() client_in_control = self.client_in_control while self.client_id != client_in_control: if time.time() - start_time > timeout: raise RuntimeError(\"Could not take control of the drone in the given time\") resp = self._req_rep_client.disconnect_client(client_in_control) client_in_control = resp.client_id_in_control self.in_control = True @property def lights(self) -> Optional[float]: \"\"\"Get or set the intensity of the drone lights *Arguments*: * brightness (float): Set the intensity of the drone light (0..1) *Returns*: * brightness (float): The intensity of the drone light (0..1) \"\"\" return self.telemetry.get(blueye.protocol.LightsTel).lights.value @lights.setter def lights(self, brightness: float): if not 0 <= brightness <= 1: raise ValueError(\"Error occured while trying to set lights to: \" f\"{brightness}\") self._ctrl_client.set_lights(brightness) @property def depth(self) -> Optional[float]: \"\"\"Get the current depth in meters *Returns*: * depth (float): The depth in meters of water column. \"\"\" depth_tel = self.telemetry.get(blueye.protocol.DepthTel) if depth_tel is None: return None else: return depth_tel.depth.value @property def pose(self) -> Optional[dict]: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" attitude_tel = self.telemetry.get(blueye.protocol.AttitudeTel) if attitude_tel is None: return None attitude = attitude_tel.attitude pose = { \"roll\": (attitude.roll + 360) % 360, \"pitch\": (attitude.pitch + 360) % 360, \"yaw\": (attitude.yaw + 360) % 360, } return pose @property def error_flags(self) -> Optional[Dict[str, bool]]: \"\"\"Get the error flags *Returns*: * error_flags (dict): The error flags as bools in a dictionary \"\"\" error_flags_tel = self.telemetry.get(blueye.protocol.ErrorFlagsTel) if error_flags_tel is None: return None error_flags_msg = error_flags_tel.error_flags error_flags = {} possible_flags = [attr for attr in dir(error_flags_msg) if not attr.startswith(\"__\")] for flag in possible_flags: error_flags[flag] = getattr(error_flags_msg, flag) return error_flags @property def active_video_streams(self) -> Optional[Dict[str, int]]: \"\"\"Get the number of currently active connections to the video stream Every client connected to the RTSP stream (does not matter if it's directly from GStreamer, or from the Blueye app) counts as one connection. \"\"\" n_streamers_msg_tel = self.telemetry.get(blueye.protocol.NStreamersTel) if n_streamers_msg_tel is None: return None n_streamers_msg = n_streamers_msg_tel.n_streamers return {\"main\": n_streamers_msg.main, \"guestport\": n_streamers_msg.guestport} def ping(self, timeout: float = 1.0): \"\"\"Ping drone Raises a ResponseTimeout exception if the drone does not respond within the timeout period. \"\"\" self._req_rep_client.ping(timeout)","title":"Drone"},{"location":"reference/blueye/sdk/drone/#instance-variables_1","text":"active_video_streams Get the number of currently active connections to the video stream Every client connected to the RTSP stream (does not matter if it's directly from GStreamer, or from the Blueye app) counts as one connection. client_in_control Get the client id of the client in control of the drone connected_clients Get a list of connected clients depth Get the current depth in meters Returns : depth (float): The depth in meters of water column. error_flags Get the error flags Returns : error_flags (dict): The error flags as bools in a dictionary lights Get or set the intensity of the drone lights Arguments : brightness (float): Set the intensity of the drone light (0..1) Returns : brightness (float): The intensity of the drone light (0..1) pose Get the current orientation of the drone Returns : pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359.","title":"Instance variables"},{"location":"reference/blueye/sdk/drone/#methods_1","text":"","title":"Methods"},{"location":"reference/blueye/sdk/drone/#connect","text":"def connect ( self , client_info : 'blueye.protocol.ClientInfo' = None , timeout : 'float' = 4 , disconnect_other_clients : 'bool' = False ) Establish a connection to the drone Spawns of several threads for receiving telemetry, sending control messages and publishing watchdog messages. When a watchdog message is receieved by the drone the thrusters are armed, so to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. Arguments - client_info : Information about the client connecting, if None the SDK will attempt to read it from the environment - timeout : Seconds to wait for connection. The first connection on boot can be a little slower than the following ones - disconnect_other_clients : If True, disconnect clients until drone reports that we are in control Raises - ConnectionError : If the connection attempt fails - RuntimeError : If the Blunux version of the connected drone is too old View Source def connect( self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 4, disconnect_other_clients: bool = False, ): \"\"\"Establish a connection to the drone Spawns of several threads for receiving telemetry, sending control messages and publishing watchdog messages. When a watchdog message is receieved by the drone the thrusters are armed, so to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. ** Arguments ** - *client_info*: Information about the client connecting, if None the SDK will attempt to read it from the environment - *timeout*: Seconds to wait for connection. The first connection on boot can be a little slower than the following ones - *disconnect_other_clients*: If True, disconnect clients until drone reports that we are in control ** Raises ** - *ConnectionError*: If the connection attempt fails - *RuntimeError*: If the Blunux version of the connected drone is too old \"\"\" logger.info(f\"Attempting to connect to drone at {self._ip}\") self._update_drone_info(timeout=timeout) self._verify_required_blunux_version(\"3.2\") self._telemetry_watcher = TelemetryClient(self) self._ctrl_client = CtrlClient(self) self._watchdog_publisher = WatchdogPublisher(self) self._req_rep_client = ReqRepClient(self) self._telemetry_watcher.start() self._req_rep_client.start() self._ctrl_client.start() self._watchdog_publisher.start() self.ping() connect_resp = self._req_rep_client.connect_client(client_info=client_info) logger.info(f\"Connection successful, client id: {connect_resp.client_id}\") logger.info(f\"Client id in control: {connect_resp.client_id_in_control}\") logger.info(f\"There are {len(connect_resp.connected_clients)-1} other clients connected\") self.client_id = connect_resp.client_id self.in_control = connect_resp.client_id == connect_resp.client_id_in_control self.connected = True if disconnect_other_clients and not self.in_control: self.take_control() if self.in_control: # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time current_time = int(time.time()) time_formatted = datetime.fromtimestamp(current_time).strftime(\"%d. %b %Y %H:%M\") logger.debug(f\"Setting current time to {current_time} ({time_formatted})\") self.config.set_drone_time(current_time) logger.debug(f\"Disabling thrusters\") self.motion.send_thruster_setpoint(0, 0, 0, 0)","title":"connect"},{"location":"reference/blueye/sdk/drone/#disconnect","text":"def disconnect ( self ) Disconnects the connection, allowing another client to take control of the drone View Source def disconnect(self): \"\"\"Disconnects the connection, allowing another client to take control of the drone\"\"\" try: self._req_rep_client.disconnect_client(self.client_id) except blueye.protocol.exceptions.ResponseTimeout: # If there's no response the connection is likely already closed, so we can just # continue to stop threads and disconnect pass self._watchdog_publisher.stop() self._telemetry_watcher.stop() self._req_rep_client.stop() self._ctrl_client.stop() self._watchdog_publisher = _NoConnectionClient() self._telemetry_watcher = _NoConnectionClient() self._req_rep_client = _NoConnectionClient() self._ctrl_client = _NoConnectionClient() self.connected = False","title":"disconnect"},{"location":"reference/blueye/sdk/drone/#ping","text":"def ping ( self , timeout : 'float' = 1.0 ) Ping drone Raises a ResponseTimeout exception if the drone does not respond within the timeout period. View Source def ping(self, timeout: float = 1.0): \"\"\"Ping drone Raises a ResponseTimeout exception if the drone does not respond within the timeout period. \"\"\" self._req_rep_client.ping(timeout)","title":"ping"},{"location":"reference/blueye/sdk/drone/#take_control","text":"def take_control ( self , timeout = 1 ) Take control of the drone, disconnecting other clients Will disconnect other clients until the client is in control of the drone. Raises a RuntimeError if the client could not take control of the drone in the given time. View Source def take_control(self, timeout=1): \"\"\"Take control of the drone, disconnecting other clients Will disconnect other clients until the client is in control of the drone. Raises a RuntimeError if the client could not take control of the drone in the given time. \"\"\" start_time = time.time() client_in_control = self.client_in_control while self.client_id != client_in_control: if time.time() - start_time > timeout: raise RuntimeError(\"Could not take control of the drone in the given time\") resp = self._req_rep_client.disconnect_client(client_in_control) client_in_control = resp.client_id_in_control self.in_control = True","title":"take_control"},{"location":"reference/blueye/sdk/drone/#telemetry","text":"class Telemetry ( parent_drone : \"'Drone'\" ) View Source class Telemetry: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone def set_msg_publish_frequency(self, msg: proto.message.Message, frequency: float): \"\"\"Set the publishing frequency of a specific telemetry message Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a frequency outside the valid range, or an incorrect message type. *Arguments*: * msg (proto.message.Message): The message to set the frequency of. Needs to be one of the messages in blueye.protocol that end in Tel, eg. blueye.protocol.DepthTel * frequency (float): The frequency in Hz. Valid range is (0 .. 100). \"\"\" resp = self._parent_drone._req_rep_client.set_telemetry_msg_publish_frequency( msg, frequency ) if not resp.success: raise RuntimeError(\"Could not set telemetry message frequency\") def add_msg_callback( self, msg_filter: List[proto.message.Message], callback: Callable[[str, proto.message.Message], None], raw: bool = False, ) -> str: \"\"\"Register a telemetry message callback The callback is called each time a message of the type is received *Arguments*: * msg_filter: A list of message types to register the callback for. Eg. `[blueye.protocol.DepthTel, blueye.protocol.Imu1Tel]`. If the list is empty the callback will be registered for all message types * callback: The callback function. It should be minimal and return as fast as possible to not block the telemetry communication. It is called with two arguments, the message type name and the message object * raw: Pass the raw data instead of the deserialized message to the callback function *Returns*: * uuid: Callback id. Can be used to remove callback in the future \"\"\" uuid_hex = self._parent_drone._telemetry_watcher.add_callback(msg_filter, callback, raw=raw) return uuid_hex def remove_msg_callback(self, callback_id: str) -> Optional[str]: \"\"\"Remove a telemetry message callback *Arguments*: * callback_id: The callback id \"\"\" self._parent_drone._telemetry_watcher.remove_callback(callback_id) def get( self, msg_type: proto.message.Message, deserialize=True ) -> Optional[proto.message.Message | bytes]: \"\"\"Get the latest telemetry message of the specified type *Arguments*: * msg_type: The message type to get. Eg. blueye.protocol.DepthTel * deserialize: If True, the message will be deserialized before being returned. If False, the raw bytes will be returned. *Returns*: * The latest message of the specified type, or None if no message has been received yet \"\"\" try: msg = self._parent_drone._telemetry_watcher.get(msg_type) except KeyError: return None if deserialize: return msg_type.deserialize(msg) else: return msg","title":"Telemetry"},{"location":"reference/blueye/sdk/drone/#methods_2","text":"","title":"Methods"},{"location":"reference/blueye/sdk/drone/#add_msg_callback","text":"def add_msg_callback ( self , msg_filter : 'List[proto.message.Message]' , callback : 'Callable[[str, proto.message.Message], None]' , raw : 'bool' = False ) -> 'str' Register a telemetry message callback The callback is called each time a message of the type is received Arguments : msg_filter: A list of message types to register the callback for. Eg. [blueye.protocol.DepthTel, blueye.protocol.Imu1Tel] . If the list is empty the callback will be registered for all message types callback: The callback function. It should be minimal and return as fast as possible to not block the telemetry communication. It is called with two arguments, the message type name and the message object raw: Pass the raw data instead of the deserialized message to the callback function Returns : uuid: Callback id. Can be used to remove callback in the future View Source def add_msg_callback( self, msg_filter: List[proto.message.Message], callback: Callable[[str, proto.message.Message], None], raw: bool = False, ) -> str: \"\"\"Register a telemetry message callback The callback is called each time a message of the type is received *Arguments*: * msg_filter: A list of message types to register the callback for. Eg. `[blueye.protocol.DepthTel, blueye.protocol.Imu1Tel]`. If the list is empty the callback will be registered for all message types * callback: The callback function. It should be minimal and return as fast as possible to not block the telemetry communication. It is called with two arguments, the message type name and the message object * raw: Pass the raw data instead of the deserialized message to the callback function *Returns*: * uuid: Callback id. Can be used to remove callback in the future \"\"\" uuid_hex = self._parent_drone._telemetry_watcher.add_callback(msg_filter, callback, raw=raw) return uuid_hex","title":"add_msg_callback"},{"location":"reference/blueye/sdk/drone/#get","text":"def get ( self , msg_type : 'proto.message.Message' , deserialize = True ) -> 'Optional[proto.message.Message | bytes]' Get the latest telemetry message of the specified type Arguments : msg_type: The message type to get. Eg. blueye.protocol.DepthTel deserialize: If True, the message will be deserialized before being returned. If False, the raw bytes will be returned. Returns : The latest message of the specified type, or None if no message has been received yet View Source def get( self, msg_type: proto.message.Message, deserialize=True ) -> Optional[proto.message.Message | bytes]: \"\"\"Get the latest telemetry message of the specified type *Arguments*: * msg_type: The message type to get. Eg. blueye.protocol.DepthTel * deserialize: If True, the message will be deserialized before being returned. If False, the raw bytes will be returned. *Returns*: * The latest message of the specified type, or None if no message has been received yet \"\"\" try: msg = self._parent_drone._telemetry_watcher.get(msg_type) except KeyError: return None if deserialize: return msg_type.deserialize(msg) else: return msg","title":"get"},{"location":"reference/blueye/sdk/drone/#remove_msg_callback","text":"def remove_msg_callback ( self , callback_id : 'str' ) -> 'Optional[str]' Remove a telemetry message callback Arguments : callback_id: The callback id View Source def remove_msg_callback(self, callback_id: str) -> Optional[str]: \"\"\"Remove a telemetry message callback *Arguments*: * callback_id: The callback id \"\"\" self._parent_drone._telemetry_watcher.remove_callback(callback_id)","title":"remove_msg_callback"},{"location":"reference/blueye/sdk/drone/#set_msg_publish_frequency","text":"def set_msg_publish_frequency ( self , msg : 'proto.message.Message' , frequency : 'float' ) Set the publishing frequency of a specific telemetry message Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a frequency outside the valid range, or an incorrect message type. Arguments : msg (proto.message.Message): The message to set the frequency of. Needs to be one of the messages in blueye.protocol that end in Tel, eg. blueye.protocol.DepthTel frequency (float): The frequency in Hz. Valid range is (0 .. 100). View Source def set_msg_publish_frequency(self, msg: proto.message.Message, frequency: float): \"\"\"Set the publishing frequency of a specific telemetry message Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a frequency outside the valid range, or an incorrect message type. *Arguments*: * msg (proto.message.Message): The message to set the frequency of. Needs to be one of the messages in blueye.protocol that end in Tel, eg. blueye.protocol.DepthTel * frequency (float): The frequency in Hz. Valid range is (0 .. 100). \"\"\" resp = self._parent_drone._req_rep_client.set_telemetry_msg_publish_frequency( msg, frequency ) if not resp.success: raise RuntimeError(\"Could not set telemetry message frequency\")","title":"set_msg_publish_frequency"},{"location":"reference/blueye/sdk/logs/","text":"Module blueye.sdk.logs View Source import logging from datetime import datetime import dateutil.parser import requests import tabulate logger = logging.getLogger(__name__) class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called `myDrone`: ``` print(myDrone.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{myDrone.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp: datetime = dateutil.parser.isoparse(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item] class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called `myDrone`, you can do: ``` print(myDrone.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `myDrone.logs[0]`, or if you want some particular log you can do `myDrone.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `myDrone.logs[-10:]`. \"\"\" def __init__(self, parent_drone, auto_download_index=False): self.ip = parent_drone._ip self._parent_drone = parent_drone self.index_downloaded = False if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: try: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) except dateutil.parser.ParserError: logger.warning( f\"Could not parse timestamp for log {log['name']}, skipping this log file\" ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" if not self._parent_drone.connected: raise ConnectionError( \"The connection to the drone is not established, try calling the connect method \" \"before retrying\" ) list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True def __len__(self): if not self.index_downloaded: self.refresh_log_index() return len(self._logs) def __getitem__(self, item): if not self.index_downloaded: self.refresh_log_index() if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) Variables logger Classes LogFile class LogFile ( maxdepth , name , timestamp , binsize , ip ) This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called myDrone : print(myDrone.logs[0]) or, if you want to display the header you can format the object with with_header : print(f\"{myDrone.logs[0]:with_header}\") Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. View Source class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called `myDrone`: ``` print(myDrone.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{myDrone.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp: datetime = dateutil.parser.isoparse(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item] Methods download def download ( self , output_path = None , output_name = None , downsample_divisor = 10 ) Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. View Source def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) Logs class Logs ( parent_drone , auto_download_index = False ) This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called myDrone , you can do: print(myDrone.logs) This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do myDrone.logs[0] , or if you want some particular log you can do myDrone.logs[\"exampleName0001.csv\"] . You can even give it a slice, so if you want the last 10 logs you can do myDrone.logs[-10:] . View Source class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called `myDrone`, you can do: ``` print(myDrone.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `myDrone.logs[0]`, or if you want some particular log you can do `myDrone.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `myDrone.logs[-10:]`. \"\"\" def __init__(self, parent_drone, auto_download_index=False): self.ip = parent_drone._ip self._parent_drone = parent_drone self.index_downloaded = False if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: try: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) except dateutil.parser.ParserError: logger.warning( f\"Could not parse timestamp for log {log['name']}, skipping this log file\" ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" if not self._parent_drone.connected: raise ConnectionError( \"The connection to the drone is not established, try calling the connect method \" \"before retrying\" ) list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True def __len__(self): if not self.index_downloaded: self.refresh_log_index() return len(self._logs) def __getitem__(self, item): if not self.index_downloaded: self.refresh_log_index() if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) Methods refresh_log_index def refresh_log_index ( self ) Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. View Source def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" if not self._parent_drone.connected: raise ConnectionError( \"The connection to the drone is not established, try calling the connect method \" \"before retrying\" ) list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True","title":"Logs"},{"location":"reference/blueye/sdk/logs/#module-blueyesdklogs","text":"View Source import logging from datetime import datetime import dateutil.parser import requests import tabulate logger = logging.getLogger(__name__) class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called `myDrone`: ``` print(myDrone.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{myDrone.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp: datetime = dateutil.parser.isoparse(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item] class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called `myDrone`, you can do: ``` print(myDrone.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `myDrone.logs[0]`, or if you want some particular log you can do `myDrone.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `myDrone.logs[-10:]`. \"\"\" def __init__(self, parent_drone, auto_download_index=False): self.ip = parent_drone._ip self._parent_drone = parent_drone self.index_downloaded = False if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: try: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) except dateutil.parser.ParserError: logger.warning( f\"Could not parse timestamp for log {log['name']}, skipping this log file\" ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" if not self._parent_drone.connected: raise ConnectionError( \"The connection to the drone is not established, try calling the connect method \" \"before retrying\" ) list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True def __len__(self): if not self.index_downloaded: self.refresh_log_index() return len(self._logs) def __getitem__(self, item): if not self.index_downloaded: self.refresh_log_index() if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" )","title":"Module blueye.sdk.logs"},{"location":"reference/blueye/sdk/logs/#variables","text":"logger","title":"Variables"},{"location":"reference/blueye/sdk/logs/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/logs/#logfile","text":"class LogFile ( maxdepth , name , timestamp , binsize , ip ) This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called myDrone : print(myDrone.logs[0]) or, if you want to display the header you can format the object with with_header : print(f\"{myDrone.logs[0]:with_header}\") Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. View Source class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called `myDrone`: ``` print(myDrone.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{myDrone.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp: datetime = dateutil.parser.isoparse(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item]","title":"LogFile"},{"location":"reference/blueye/sdk/logs/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/logs/#download","text":"def download ( self , output_path = None , output_name = None , downsample_divisor = 10 ) Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. View Source def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log)","title":"download"},{"location":"reference/blueye/sdk/logs/#logs","text":"class Logs ( parent_drone , auto_download_index = False ) This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called myDrone , you can do: print(myDrone.logs) This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do myDrone.logs[0] , or if you want some particular log you can do myDrone.logs[\"exampleName0001.csv\"] . You can even give it a slice, so if you want the last 10 logs you can do myDrone.logs[-10:] . View Source class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called `myDrone`, you can do: ``` print(myDrone.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `myDrone.logs[0]`, or if you want some particular log you can do `myDrone.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `myDrone.logs[-10:]`. \"\"\" def __init__(self, parent_drone, auto_download_index=False): self.ip = parent_drone._ip self._parent_drone = parent_drone self.index_downloaded = False if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: try: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) except dateutil.parser.ParserError: logger.warning( f\"Could not parse timestamp for log {log['name']}, skipping this log file\" ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" if not self._parent_drone.connected: raise ConnectionError( \"The connection to the drone is not established, try calling the connect method \" \"before retrying\" ) list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True def __len__(self): if not self.index_downloaded: self.refresh_log_index() return len(self._logs) def __getitem__(self, item): if not self.index_downloaded: self.refresh_log_index() if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" )","title":"Logs"},{"location":"reference/blueye/sdk/logs/#methods_1","text":"","title":"Methods"},{"location":"reference/blueye/sdk/logs/#refresh_log_index","text":"def refresh_log_index ( self ) Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. View Source def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" if not self._parent_drone.connected: raise ConnectionError( \"The connection to the drone is not established, try calling the connect method \" \"before retrying\" ) list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True","title":"refresh_log_index"},{"location":"reference/blueye/sdk/motion/","text":"Module blueye.sdk.motion View Source import threading from typing import Optional import blueye.protocol class Motion: \"\"\"Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. \"\"\" def __init__(self, parent_drone): self._parent_drone = parent_drone self.thruster_lock = threading.Lock() self._current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} self._current_boost_setpoints = {\"slow\": 0, \"boost\": 0} @property def current_thruster_setpoints(self): \"\"\"Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone expects to receive all of the setpoints at once. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. \"\"\" return self._current_thruster_setpoints @current_thruster_setpoints.setter def current_thruster_setpoints(self, *args, **kwargs): raise AttributeError( \"Do not set the setpoints directly, use the surge, sway, heave, yaw properties or the \" \"send_thruster_setpoint function for that.\" ) def _send_motion_input_message(self): \"\"\"Small helper function for building argument list to motion_input command\"\"\" thruster_setpoints = self.current_thruster_setpoints.values() boost_setpoints = self._current_boost_setpoints.values() self._parent_drone._ctrl_client.set_motion_input(*thruster_setpoints, *boost_setpoints) @property def surge(self) -> float: \"\"\"Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge_value self._send_motion_input_message() @property def sway(self) -> float: \"\"\"Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"sway\"] = sway_value self._send_motion_input_message() @property def heave(self) -> float: \"\"\"Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"heave\"] = heave_value self._send_motion_input_message() @property def yaw(self) -> float: \"\"\"Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"yaw\"] = yaw_value self._send_motion_input_message() def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message() @property def boost(self) -> float: \"\"\"Get or set the boost gain Arguments: * **boost_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"boost\"] @boost.setter def boost(self, boost_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"boost\"] = boost_gain self._send_motion_input_message() @property def slow(self) -> float: \"\"\"Get or set the \"slow gain\" (inverse of boost) Arguments: * **slow_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"slow\"] @slow.setter def slow(self, slow_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"slow\"] = slow_gain self._send_motion_input_message() @property def auto_depth_active(self) -> Optional[bool]: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * Enable (bool): Activate auto depth mode if true, de-activate if false *Returns*: * Auto depth state (bool): True if auto depth is active, false if not \"\"\" control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel) if control_mode_tel is None: return None else: return control_mode_tel.state.auto_depth @auto_depth_active.setter def auto_depth_active(self, enable: bool): self._parent_drone._ctrl_client.set_auto_depth_state(enable) @property def auto_heading_active(self) -> Optional[bool]: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * Enable (bool): Activate auto heading mode if true, de-activate if false *Returns*: * Auto heading state (bool): True if auto heading mode is active, false if not \"\"\" control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel) if control_mode_tel is None: return None else: return control_mode_tel.state.auto_heading @auto_heading_active.setter def auto_heading_active(self, enable: bool): self._parent_drone._ctrl_client.set_auto_heading_state(enable) Classes Motion class Motion ( parent_drone ) Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the send_thruster_setpoint method. View Source class Motion: \"\"\"Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. \"\"\" def __init__(self, parent_drone): self._parent_drone = parent_drone self.thruster_lock = threading.Lock() self._current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} self._current_boost_setpoints = {\"slow\": 0, \"boost\": 0} @property def current_thruster_setpoints(self): \"\"\"Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone expects to receive all of the setpoints at once. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. \"\"\" return self._current_thruster_setpoints @current_thruster_setpoints.setter def current_thruster_setpoints(self, *args, **kwargs): raise AttributeError( \"Do not set the setpoints directly, use the surge, sway, heave, yaw properties or the \" \"send_thruster_setpoint function for that.\" ) def _send_motion_input_message(self): \"\"\"Small helper function for building argument list to motion_input command\"\"\" thruster_setpoints = self.current_thruster_setpoints.values() boost_setpoints = self._current_boost_setpoints.values() self._parent_drone._ctrl_client.set_motion_input(*thruster_setpoints, *boost_setpoints) @property def surge(self) -> float: \"\"\"Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge_value self._send_motion_input_message() @property def sway(self) -> float: \"\"\"Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"sway\"] = sway_value self._send_motion_input_message() @property def heave(self) -> float: \"\"\"Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"heave\"] = heave_value self._send_motion_input_message() @property def yaw(self) -> float: \"\"\"Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"yaw\"] = yaw_value self._send_motion_input_message() def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message() @property def boost(self) -> float: \"\"\"Get or set the boost gain Arguments: * **boost_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"boost\"] @boost.setter def boost(self, boost_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"boost\"] = boost_gain self._send_motion_input_message() @property def slow(self) -> float: \"\"\"Get or set the \"slow gain\" (inverse of boost) Arguments: * **slow_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"slow\"] @slow.setter def slow(self, slow_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"slow\"] = slow_gain self._send_motion_input_message() @property def auto_depth_active(self) -> Optional[bool]: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * Enable (bool): Activate auto depth mode if true, de-activate if false *Returns*: * Auto depth state (bool): True if auto depth is active, false if not \"\"\" control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel) if control_mode_tel is None: return None else: return control_mode_tel.state.auto_depth @auto_depth_active.setter def auto_depth_active(self, enable: bool): self._parent_drone._ctrl_client.set_auto_depth_state(enable) @property def auto_heading_active(self) -> Optional[bool]: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * Enable (bool): Activate auto heading mode if true, de-activate if false *Returns*: * Auto heading state (bool): True if auto heading mode is active, false if not \"\"\" control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel) if control_mode_tel is None: return None else: return control_mode_tel.state.auto_heading @auto_heading_active.setter def auto_heading_active(self, enable: bool): self._parent_drone._ctrl_client.set_auto_heading_state(enable) Instance variables auto_depth_active Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. Arguments : Enable (bool): Activate auto depth mode if true, de-activate if false Returns : Auto depth state (bool): True if auto depth is active, false if not auto_heading_active Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. Arguments : Enable (bool): Activate auto heading mode if true, de-activate if false Returns : Auto heading state (bool): True if auto heading mode is active, false if not boost Get or set the boost gain Arguments: boost_gain (float): Range from 0 to 1. current_thruster_setpoints Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone expects to receive all of the setpoints at once. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. heave Set force reference for the heave direction Arguments: heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards slow Get or set the \"slow gain\" (inverse of boost) Arguments: slow_gain (float): Range from 0 to 1. surge Set force reference for the surge direction Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway Set force reference for the sway direction Arguments: sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right yaw Set force reference for the yaw direction Arguments: yaw (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. Methods send_thruster_setpoint def send_thruster_setpoint ( self , surge , sway , heave , yaw ) Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. yaw (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. View Source def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message()","title":"Motion"},{"location":"reference/blueye/sdk/motion/#module-blueyesdkmotion","text":"View Source import threading from typing import Optional import blueye.protocol class Motion: \"\"\"Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. \"\"\" def __init__(self, parent_drone): self._parent_drone = parent_drone self.thruster_lock = threading.Lock() self._current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} self._current_boost_setpoints = {\"slow\": 0, \"boost\": 0} @property def current_thruster_setpoints(self): \"\"\"Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone expects to receive all of the setpoints at once. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. \"\"\" return self._current_thruster_setpoints @current_thruster_setpoints.setter def current_thruster_setpoints(self, *args, **kwargs): raise AttributeError( \"Do not set the setpoints directly, use the surge, sway, heave, yaw properties or the \" \"send_thruster_setpoint function for that.\" ) def _send_motion_input_message(self): \"\"\"Small helper function for building argument list to motion_input command\"\"\" thruster_setpoints = self.current_thruster_setpoints.values() boost_setpoints = self._current_boost_setpoints.values() self._parent_drone._ctrl_client.set_motion_input(*thruster_setpoints, *boost_setpoints) @property def surge(self) -> float: \"\"\"Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge_value self._send_motion_input_message() @property def sway(self) -> float: \"\"\"Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"sway\"] = sway_value self._send_motion_input_message() @property def heave(self) -> float: \"\"\"Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"heave\"] = heave_value self._send_motion_input_message() @property def yaw(self) -> float: \"\"\"Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"yaw\"] = yaw_value self._send_motion_input_message() def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message() @property def boost(self) -> float: \"\"\"Get or set the boost gain Arguments: * **boost_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"boost\"] @boost.setter def boost(self, boost_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"boost\"] = boost_gain self._send_motion_input_message() @property def slow(self) -> float: \"\"\"Get or set the \"slow gain\" (inverse of boost) Arguments: * **slow_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"slow\"] @slow.setter def slow(self, slow_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"slow\"] = slow_gain self._send_motion_input_message() @property def auto_depth_active(self) -> Optional[bool]: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * Enable (bool): Activate auto depth mode if true, de-activate if false *Returns*: * Auto depth state (bool): True if auto depth is active, false if not \"\"\" control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel) if control_mode_tel is None: return None else: return control_mode_tel.state.auto_depth @auto_depth_active.setter def auto_depth_active(self, enable: bool): self._parent_drone._ctrl_client.set_auto_depth_state(enable) @property def auto_heading_active(self) -> Optional[bool]: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * Enable (bool): Activate auto heading mode if true, de-activate if false *Returns*: * Auto heading state (bool): True if auto heading mode is active, false if not \"\"\" control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel) if control_mode_tel is None: return None else: return control_mode_tel.state.auto_heading @auto_heading_active.setter def auto_heading_active(self, enable: bool): self._parent_drone._ctrl_client.set_auto_heading_state(enable)","title":"Module blueye.sdk.motion"},{"location":"reference/blueye/sdk/motion/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/motion/#motion","text":"class Motion ( parent_drone ) Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the send_thruster_setpoint method. View Source class Motion: \"\"\"Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. \"\"\" def __init__(self, parent_drone): self._parent_drone = parent_drone self.thruster_lock = threading.Lock() self._current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} self._current_boost_setpoints = {\"slow\": 0, \"boost\": 0} @property def current_thruster_setpoints(self): \"\"\"Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone expects to receive all of the setpoints at once. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. \"\"\" return self._current_thruster_setpoints @current_thruster_setpoints.setter def current_thruster_setpoints(self, *args, **kwargs): raise AttributeError( \"Do not set the setpoints directly, use the surge, sway, heave, yaw properties or the \" \"send_thruster_setpoint function for that.\" ) def _send_motion_input_message(self): \"\"\"Small helper function for building argument list to motion_input command\"\"\" thruster_setpoints = self.current_thruster_setpoints.values() boost_setpoints = self._current_boost_setpoints.values() self._parent_drone._ctrl_client.set_motion_input(*thruster_setpoints, *boost_setpoints) @property def surge(self) -> float: \"\"\"Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge_value self._send_motion_input_message() @property def sway(self) -> float: \"\"\"Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"sway\"] = sway_value self._send_motion_input_message() @property def heave(self) -> float: \"\"\"Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"heave\"] = heave_value self._send_motion_input_message() @property def yaw(self) -> float: \"\"\"Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"yaw\"] = yaw_value self._send_motion_input_message() def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message() @property def boost(self) -> float: \"\"\"Get or set the boost gain Arguments: * **boost_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"boost\"] @boost.setter def boost(self, boost_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"boost\"] = boost_gain self._send_motion_input_message() @property def slow(self) -> float: \"\"\"Get or set the \"slow gain\" (inverse of boost) Arguments: * **slow_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"slow\"] @slow.setter def slow(self, slow_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"slow\"] = slow_gain self._send_motion_input_message() @property def auto_depth_active(self) -> Optional[bool]: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * Enable (bool): Activate auto depth mode if true, de-activate if false *Returns*: * Auto depth state (bool): True if auto depth is active, false if not \"\"\" control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel) if control_mode_tel is None: return None else: return control_mode_tel.state.auto_depth @auto_depth_active.setter def auto_depth_active(self, enable: bool): self._parent_drone._ctrl_client.set_auto_depth_state(enable) @property def auto_heading_active(self) -> Optional[bool]: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * Enable (bool): Activate auto heading mode if true, de-activate if false *Returns*: * Auto heading state (bool): True if auto heading mode is active, false if not \"\"\" control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel) if control_mode_tel is None: return None else: return control_mode_tel.state.auto_heading @auto_heading_active.setter def auto_heading_active(self, enable: bool): self._parent_drone._ctrl_client.set_auto_heading_state(enable)","title":"Motion"},{"location":"reference/blueye/sdk/motion/#instance-variables","text":"auto_depth_active Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. Arguments : Enable (bool): Activate auto depth mode if true, de-activate if false Returns : Auto depth state (bool): True if auto depth is active, false if not auto_heading_active Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. Arguments : Enable (bool): Activate auto heading mode if true, de-activate if false Returns : Auto heading state (bool): True if auto heading mode is active, false if not boost Get or set the boost gain Arguments: boost_gain (float): Range from 0 to 1. current_thruster_setpoints Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone expects to receive all of the setpoints at once. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. heave Set force reference for the heave direction Arguments: heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards slow Get or set the \"slow gain\" (inverse of boost) Arguments: slow_gain (float): Range from 0 to 1. surge Set force reference for the surge direction Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway Set force reference for the sway direction Arguments: sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right yaw Set force reference for the yaw direction Arguments: yaw (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise.","title":"Instance variables"},{"location":"reference/blueye/sdk/motion/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/motion/#send_thruster_setpoint","text":"def send_thruster_setpoint ( self , surge , sway , heave , yaw ) Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. yaw (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. View Source def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message()","title":"send_thruster_setpoint"},{"location":"reference/blueye/sdk/utils/","text":"Module blueye.sdk.utils View Source import webbrowser import os import blueye.sdk def open_local_documentation(): \"\"\"Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. \"\"\" sdk_path = os.path.dirname(blueye.sdk.__file__) # The documentation is located next to the top-level package so we move up a couple of levels documentation_path = os.path.abspath(sdk_path + \"/../../blueye.sdk_docs/README.html\") webbrowser.open(documentation_path) Functions open_local_documentation def open_local_documentation ( ) Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. View Source def open_local_documentation(): \"\"\"Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. \"\"\" sdk_path = os.path.dirname(blueye.sdk.__file__) # The documentation is located next to the top-level package so we move up a couple of levels documentation_path = os.path.abspath(sdk_path + \"/../../blueye.sdk_docs/README.html\") webbrowser.open(documentation_path)","title":"Utils"},{"location":"reference/blueye/sdk/utils/#module-blueyesdkutils","text":"View Source import webbrowser import os import blueye.sdk def open_local_documentation(): \"\"\"Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. \"\"\" sdk_path = os.path.dirname(blueye.sdk.__file__) # The documentation is located next to the top-level package so we move up a couple of levels documentation_path = os.path.abspath(sdk_path + \"/../../blueye.sdk_docs/README.html\") webbrowser.open(documentation_path)","title":"Module blueye.sdk.utils"},{"location":"reference/blueye/sdk/utils/#functions","text":"","title":"Functions"},{"location":"reference/blueye/sdk/utils/#open_local_documentation","text":"def open_local_documentation ( ) Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. View Source def open_local_documentation(): \"\"\"Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. \"\"\" sdk_path = os.path.dirname(blueye.sdk.__file__) # The documentation is located next to the top-level package so we move up a couple of levels documentation_path = os.path.abspath(sdk_path + \"/../../blueye.sdk_docs/README.html\") webbrowser.open(documentation_path)","title":"open_local_documentation"}]}