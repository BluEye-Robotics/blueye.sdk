{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"blueye.sdk Read Latest Documentation - Browse GitHub Code Repository Note: This is a pre-release -- Please report any issues you might encounter A Python package for remote control of the Blueye Pioneer and Blueye Pro underwater drones. About Blueye Underwater Drones The Blueye Pioneer and Blueye Pro are underwater drones designed for inspections. It is produced and sold by the Norwegian company Blueye Robotics . Here is a Youtube video that gives a overview of the system and its specifications. This SDK and the Blueye drones A Blueye drone is normally controlled via a mobile device through the Blueye App ( iOS / Android ). The mobile device is connected via Wi-Fi to a surface unit, and the Pioneer or Pro is connected to the surface unit via a tether cable. This python SDK exposes the functionality of the Blueye app through a Python object. The SDK enables remote control of the Blueye Pioneer and Blueye Pro as well as reading telemetry data and viewing video streams. It is not meant for executing code on the Pioneer. To control the drone you connect your laptop to the surface unit Wi-Fi and run code that interfaces with the Blueye Pro or Blueye Pioneer through the Pioneer Python object. Check out the Quick Start Guide to get started with using the SDK.","title":"About the Blueye Drones"},{"location":"#blueyesdk","text":"Read Latest Documentation - Browse GitHub Code Repository Note: This is a pre-release -- Please report any issues you might encounter A Python package for remote control of the Blueye Pioneer and Blueye Pro underwater drones.","title":"blueye.sdk"},{"location":"#about-blueye-underwater-drones","text":"The Blueye Pioneer and Blueye Pro are underwater drones designed for inspections. It is produced and sold by the Norwegian company Blueye Robotics . Here is a Youtube video that gives a overview of the system and its specifications.","title":"About Blueye Underwater Drones"},{"location":"#this-sdk-and-the-blueye-drones","text":"A Blueye drone is normally controlled via a mobile device through the Blueye App ( iOS / Android ). The mobile device is connected via Wi-Fi to a surface unit, and the Pioneer or Pro is connected to the surface unit via a tether cable. This python SDK exposes the functionality of the Blueye app through a Python object. The SDK enables remote control of the Blueye Pioneer and Blueye Pro as well as reading telemetry data and viewing video streams. It is not meant for executing code on the Pioneer. To control the drone you connect your laptop to the surface unit Wi-Fi and run code that interfaces with the Blueye Pro or Blueye Pioneer through the Pioneer Python object. Check out the Quick Start Guide to get started with using the SDK.","title":"This SDK and the Blueye drones"},{"location":"contributing/","text":"Development Project structure and context blueye.sdk is a Python package that exposes the functionality of the Blueye app. The SDK depends on three projects: ProtocolDefinitons : TCP commands are sent from a computer or mobile device to the drone, and UDP messages with telemetry data are sent from the drone back to the top side device. These TCP commands and UDP telemetry messages are defined as json files in this project. blueye.protocol : Implements a TCP client for connecting to a Blueye drone and sending the TCP commands defined in ProtocolDefinitions , and a UDP client for receiving and parsing the telemetry messages defined in ProtocolDefinitions blueye.sdk : Wraps the TCP and UDP client from blueye.protocol into an easy to use Python object. blueye.sdk also adds functionality for downloading log files from the drone. Tests To run the tests when connected to a surface unit with an active drone, do: pytest To run tests when not connected to a drone, do: pytest -k \"not connected_to_drone\" Documentation The documentation is written in markdown and converted to html with portray . To generate and open the documentation locally run portray in_browser Formatting To keep the code style consistent Black is used for code formatting. To format code with black run black . in the project root directory. Adding a pre-commit hook ensures black is run before every commit pre-commit install adds a pre-commit hook for black formatting. Can't find what you are looking for? This SDK is still very much a work in progress, if you feel features are missing or something feels clunky, please open an issue and suggest a change. Bug reports and fixes are of course always welcome!","title":"Development"},{"location":"contributing/#development","text":"","title":"Development"},{"location":"contributing/#project-structure-and-context","text":"blueye.sdk is a Python package that exposes the functionality of the Blueye app. The SDK depends on three projects: ProtocolDefinitons : TCP commands are sent from a computer or mobile device to the drone, and UDP messages with telemetry data are sent from the drone back to the top side device. These TCP commands and UDP telemetry messages are defined as json files in this project. blueye.protocol : Implements a TCP client for connecting to a Blueye drone and sending the TCP commands defined in ProtocolDefinitions , and a UDP client for receiving and parsing the telemetry messages defined in ProtocolDefinitions blueye.sdk : Wraps the TCP and UDP client from blueye.protocol into an easy to use Python object. blueye.sdk also adds functionality for downloading log files from the drone.","title":"Project structure and context"},{"location":"contributing/#tests","text":"To run the tests when connected to a surface unit with an active drone, do: pytest To run tests when not connected to a drone, do: pytest -k \"not connected_to_drone\"","title":"Tests"},{"location":"contributing/#documentation","text":"The documentation is written in markdown and converted to html with portray . To generate and open the documentation locally run portray in_browser","title":"Documentation"},{"location":"contributing/#formatting","text":"To keep the code style consistent Black is used for code formatting. To format code with black run black . in the project root directory. Adding a pre-commit hook ensures black is run before every commit pre-commit install adds a pre-commit hook for black formatting.","title":"Formatting"},{"location":"contributing/#cant-find-what-you-are-looking-for","text":"This SDK is still very much a work in progress, if you feel features are missing or something feels clunky, please open an issue and suggest a change. Bug reports and fixes are of course always welcome!","title":"Can't find what you are looking for?"},{"location":"docs/configuration/","text":"There are settings on the drone that are remotely configurable from the Blueye mobile app. These can also be set directly from the SDK. Configure time and date The drone does not keep track of time internally. The SDK sets the time on the drone automatically when you connect initially. But you can also configure time and date manually like this import time from blueye.sdk import Drone myDrone = Drone () time_to_set_on_drone = int ( time . time ()) # Unix Timestamp myDrone . config . set_drone_time ( time_to_set_on_drone ) or if we for example want to offset the drone time 5 hours relative to our current system time we can do something like this: from blueye.sdk import Drone from datetime import timezone , timedelta , datetime myDrone = Drone () offset_in_hours = timedelta ( hours = 5 ) equivalent_timezone = timezone ( offset_in_hours ) unix_timestamp = datetime . now ( tz = equivalent_timezone ) . timestamp () myDrone . config . set_drone_time ( int ( unix_timestamp )) Calibrate pressure sensor for water density The water density on the drone default to a reasonable density for salt water: 1025 grams per liter. For more accurate depth readings, the water density can be configured manually to suit your local conditions from blueye.sdk import Drone , WaterDensities myDrone = Drone () # Salt water myDrone . config . water_density = WaterDensities . salty # 1025 g/L # Brackish water myDrone . config . water_density = WaterDensities . brackish # 1011 g/L # Fresh water myDrone . config . water_density = WaterDensities . fresh # 997 g/L # Can also be set to arbitrary values myDrone . config . water_density = 1234 Configure camera parameters There are 6 different camera parameters that can be set. For a full list of camera parameters and their possible values see the camera reference section. For example you could set the bit rate like this from blueye.sdk import Drone myDrone = Drone () myDrone . camera . bitrate = 8_000_000 # 8 Mbit bitrate Due to a bug in the camera streaming on the drone a camera stream has to have been opened at least once before camera parameters can be set on the drone, see issue #67 . For instructions on how to start a video stream see, the Quick Start Guide .","title":"Configure drone parameters"},{"location":"docs/configuration/#configure-time-and-date","text":"The drone does not keep track of time internally. The SDK sets the time on the drone automatically when you connect initially. But you can also configure time and date manually like this import time from blueye.sdk import Drone myDrone = Drone () time_to_set_on_drone = int ( time . time ()) # Unix Timestamp myDrone . config . set_drone_time ( time_to_set_on_drone ) or if we for example want to offset the drone time 5 hours relative to our current system time we can do something like this: from blueye.sdk import Drone from datetime import timezone , timedelta , datetime myDrone = Drone () offset_in_hours = timedelta ( hours = 5 ) equivalent_timezone = timezone ( offset_in_hours ) unix_timestamp = datetime . now ( tz = equivalent_timezone ) . timestamp () myDrone . config . set_drone_time ( int ( unix_timestamp ))","title":"Configure time and date"},{"location":"docs/configuration/#calibrate-pressure-sensor-for-water-density","text":"The water density on the drone default to a reasonable density for salt water: 1025 grams per liter. For more accurate depth readings, the water density can be configured manually to suit your local conditions from blueye.sdk import Drone , WaterDensities myDrone = Drone () # Salt water myDrone . config . water_density = WaterDensities . salty # 1025 g/L # Brackish water myDrone . config . water_density = WaterDensities . brackish # 1011 g/L # Fresh water myDrone . config . water_density = WaterDensities . fresh # 997 g/L # Can also be set to arbitrary values myDrone . config . water_density = 1234","title":"Calibrate pressure sensor for water density"},{"location":"docs/configuration/#configure-camera-parameters","text":"There are 6 different camera parameters that can be set. For a full list of camera parameters and their possible values see the camera reference section. For example you could set the bit rate like this from blueye.sdk import Drone myDrone = Drone () myDrone . camera . bitrate = 8_000_000 # 8 Mbit bitrate Due to a bug in the camera streaming on the drone a camera stream has to have been opened at least once before camera parameters can be set on the drone, see issue #67 . For instructions on how to start a video stream see, the Quick Start Guide .","title":"Configure camera parameters"},{"location":"docs/quick_start/","text":"Installation The SDK requires Python 3.7 or higher. Since many operating systems do not package the newest version of Python we recommend using pyenv or something similar for configuring multiple python versions on the same system. Pyenv also has the added benefit of managing your virtual environments for you, though you are of course free to use other tools for that as well. The instructions below show the necessary steps to get started with the SDK on a fresh install: Windows Install Python Install Python 3.7 or higher, you can find the latest python versions here . Remember to check the option \"Add Python to path\" when installing. Install virtualenv for managing Python versions (optional) Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. # Upgrade pip version python -m pip install --upgrade pip pip install virtualenv Next, we create a virtual environment cd . \\D esktop mkdir drone_project cd . \\d rone_project # Replace \"C:\\Program Files\\Python37\\python.exe\" with the path # to the python version you want to use in the line below virtualenv blueye_sdk_env -p \"C:\\Program Files\\Python37\\python.exe\" activate the virtual environment . \\b lueye_sdk_env \\S cripts \\a ctivate.bat if you are not allowed to activate the virtual environment, you might have to allow running unsigned scripts, see this link for instructions. Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Mac OS Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl https://pyenv.run | bash pyenv update If you want pyenv to be loaded each time you open a new terminal you can add this to your .zshrc or the equivalent for your terminal export PATH=\"$HOME/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" The Pyenv wiki recommends installing some additional dependencies before building Python. # optional, but recommended: brew install openssl readline sqlite3 xz zlib When running Mojave or higher (10.14+) you will also need to install the additional SDK headers: sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target / Then build Python with pyenv pyenv install 3.8.0 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.8.0 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as. pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Linux These instructions are directed at Ubuntu, but the process should be similar for other distributions. Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash pyenv update Install the needed dependencies for building python 3.8.0 apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\ xz-utils tk-dev libffi-dev liblzma-dev python-openssl Then build python with pyenv pyenv install 3.8.0 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.8.0 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Connect to the drone To use the SDK your computer must be connected to the drone via the surface unit WiFi. For a how-to on turning on the drone and surface unit you can watch the quick start video . Control the drone Most of the functionality is controlled using Python properties and we will illustrate the use of properties by showing how to control the lights: import time from blueye.sdk import Drone # When the Drone object is instantiatied a connection to the drone is established myDrone = Drone () # Setting the lights property to 10 myDrone . lights = 10 time . sleep ( 2 ) # We can also get the current brightness of the lights through the lights property print ( f \"Current light intensity: { myDrone . lights } \" ) myDrone . lights = 0 # Properties can also be used for reading telemetry data from the drone print ( f \"Current depth in millimeters: { myDrone . depth } \" ) For an overview of the properties that are available for controlling and reading data from the drone, go to the Reference section of the documentation. The valid input ranges and descriptions of the different properties can also be found there. Tip You can explore the properties of the drone interactively using an interactive python interpreter like iPython , install it with: pip install ipython By instantiating a Drone object and using the completion key (normally the tab-key \u21b9 ) you can get a interactive list of the available properties on the drone, it is then easy to try setting and getting the different properties. Watching the video stream The easiest way to open the RTSP video stream is using VLC media player . Once VLC is downloaded you can start the stream like this, the RTSP URL is: rtsp://192.168.1.101:8554/test For lower latency streaming (on a PC) you can see the instructions on using Gstreamer , or if you just want to watch a low latency stream you can download the Blueye Dive Buddy ( iOS / Android ) The normal Blueye app can not be used to spectate when controlling the drone from the SDK because it will interfere with the commands sent from the SDK. The dive buddy app, however, is only a spectator and can be used together with the SDK. Explore the examples For further examples on how to use the SDK to control the drone have a look at the motion examples . Remember to install the example dependencies before running the examples. pip install \"blueye.sdk[examples]\" Local documentation Since the drone surface unit (usually) does not have internet access it can be a bit tricky to reference this documentation while developing on the drone. Luckily when you install the SDK from PyPI it includes a pre-built, local copy of this documentation. This documentation can be viewed by executing the following Python snippet: import blueye.sdk blueye . sdk . open_local_documentation ()","title":"Quick Start"},{"location":"docs/quick_start/#installation","text":"The SDK requires Python 3.7 or higher. Since many operating systems do not package the newest version of Python we recommend using pyenv or something similar for configuring multiple python versions on the same system. Pyenv also has the added benefit of managing your virtual environments for you, though you are of course free to use other tools for that as well. The instructions below show the necessary steps to get started with the SDK on a fresh install: Windows Install Python Install Python 3.7 or higher, you can find the latest python versions here . Remember to check the option \"Add Python to path\" when installing. Install virtualenv for managing Python versions (optional) Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. # Upgrade pip version python -m pip install --upgrade pip pip install virtualenv Next, we create a virtual environment cd . \\D esktop mkdir drone_project cd . \\d rone_project # Replace \"C:\\Program Files\\Python37\\python.exe\" with the path # to the python version you want to use in the line below virtualenv blueye_sdk_env -p \"C:\\Program Files\\Python37\\python.exe\" activate the virtual environment . \\b lueye_sdk_env \\S cripts \\a ctivate.bat if you are not allowed to activate the virtual environment, you might have to allow running unsigned scripts, see this link for instructions. Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Mac OS Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl https://pyenv.run | bash pyenv update If you want pyenv to be loaded each time you open a new terminal you can add this to your .zshrc or the equivalent for your terminal export PATH=\"$HOME/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" The Pyenv wiki recommends installing some additional dependencies before building Python. # optional, but recommended: brew install openssl readline sqlite3 xz zlib When running Mojave or higher (10.14+) you will also need to install the additional SDK headers: sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target / Then build Python with pyenv pyenv install 3.8.0 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.8.0 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as. pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Linux These instructions are directed at Ubuntu, but the process should be similar for other distributions. Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash pyenv update Install the needed dependencies for building python 3.8.0 apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\ xz-utils tk-dev libffi-dev liblzma-dev python-openssl Then build python with pyenv pyenv install 3.8.0 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.8.0 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\"","title":"Installation"},{"location":"docs/quick_start/#connect-to-the-drone","text":"To use the SDK your computer must be connected to the drone via the surface unit WiFi. For a how-to on turning on the drone and surface unit you can watch the quick start video .","title":"Connect to the drone"},{"location":"docs/quick_start/#control-the-drone","text":"Most of the functionality is controlled using Python properties and we will illustrate the use of properties by showing how to control the lights: import time from blueye.sdk import Drone # When the Drone object is instantiatied a connection to the drone is established myDrone = Drone () # Setting the lights property to 10 myDrone . lights = 10 time . sleep ( 2 ) # We can also get the current brightness of the lights through the lights property print ( f \"Current light intensity: { myDrone . lights } \" ) myDrone . lights = 0 # Properties can also be used for reading telemetry data from the drone print ( f \"Current depth in millimeters: { myDrone . depth } \" ) For an overview of the properties that are available for controlling and reading data from the drone, go to the Reference section of the documentation. The valid input ranges and descriptions of the different properties can also be found there. Tip You can explore the properties of the drone interactively using an interactive python interpreter like iPython , install it with: pip install ipython By instantiating a Drone object and using the completion key (normally the tab-key \u21b9 ) you can get a interactive list of the available properties on the drone, it is then easy to try setting and getting the different properties.","title":"Control the drone"},{"location":"docs/quick_start/#watching-the-video-stream","text":"The easiest way to open the RTSP video stream is using VLC media player . Once VLC is downloaded you can start the stream like this, the RTSP URL is: rtsp://192.168.1.101:8554/test For lower latency streaming (on a PC) you can see the instructions on using Gstreamer , or if you just want to watch a low latency stream you can download the Blueye Dive Buddy ( iOS / Android ) The normal Blueye app can not be used to spectate when controlling the drone from the SDK because it will interfere with the commands sent from the SDK. The dive buddy app, however, is only a spectator and can be used together with the SDK.","title":"Watching the video stream"},{"location":"docs/quick_start/#explore-the-examples","text":"For further examples on how to use the SDK to control the drone have a look at the motion examples . Remember to install the example dependencies before running the examples. pip install \"blueye.sdk[examples]\"","title":"Explore the examples"},{"location":"docs/quick_start/#local-documentation","text":"Since the drone surface unit (usually) does not have internet access it can be a bit tricky to reference this documentation while developing on the drone. Luckily when you install the SDK from PyPI it includes a pre-built, local copy of this documentation. This documentation can be viewed by executing the following Python snippet: import blueye.sdk blueye . sdk . open_local_documentation ()","title":"Local documentation"},{"location":"docs/logs/listing-and-downloading/","text":"Logs from the drone When the drone is powered on a new comma-separated-value file, where it stores telemetry data such as depth, temperature, and more, is created. The drone will log data as long as it is powered on. These files can be downloaded to your local system where you can plot them or use them however you see fit. Listing the log files If your drone has completed 5 dives and you do from blueye.sdk import Drone myDrone = Drone () print ( myDrone . logs ) you should see something like the following lines be printed Name Time Max depth Size ea9add4d40f69d4-00000.csv 24. Oct 2018 09:40 21.05 m 6.3 MiB ea9add4d40f69d4-00001.csv 25. Oct 2018 10:29 21.06 m 879.2 KiB ea9add4d40f69d4-00002.csv 31. Oct 2018 10:05 60.69 m 8.5 MiB ea9add4d40f69d4-00003.csv 31. Oct 2018 12:13 41.68 m 8.4 MiB ea9add4d40f69d4-00004.csv 02. Nov 2018 08:59 52.52 m 7.8 MiB The first part of the filename (the part before the -) is the unique ID of your drone and second part is the dive number. In addition we see the start time of the dive, the maximum depth reached, as well as the size of the log file. You might notice that there can be more log files listed then the amount of dives you have done. This is due to the fact that the drone creates a new log file whenever it is turned on, regardless of whether you actually took the drone for a dive. To easier separate out the log files that result from actual dives you can filter out all the dives with a max depth below some threshold. The Blueye app does this, filtering out all log files with a max depth below 20 cm. Downloading a log file to your computer When you want to download a log file all you have to do is to call the download() method on the desired log and the file will be downloaded to your current folder. The download() method takes two optional parameters, output_path and output_name . These specify, respectively, which folder the log is downloaded to and what name it's stored with. Example: Downloading multiple log files Downloading multiple log files is solved by a simple Python for-loop. The example below shows how one can download the last 3 logs to the current folder: from blueye.sdk import Drone myDrone = Drone () for log in myDrone . logs [: - 3 ]: log . download () Example: Adding a prefix to log names The example code below shows how one can add a simple prefix to all log files when downloading: from blueye.sdk import Drone myDrone = Drone () prefix = \"pre_\" for log in myDrone . logs : log . download ( output_name = prefix + log . name )","title":"Listing and downloading log files"},{"location":"docs/logs/listing-and-downloading/#logs-from-the-drone","text":"When the drone is powered on a new comma-separated-value file, where it stores telemetry data such as depth, temperature, and more, is created. The drone will log data as long as it is powered on. These files can be downloaded to your local system where you can plot them or use them however you see fit.","title":"Logs from the drone"},{"location":"docs/logs/listing-and-downloading/#listing-the-log-files","text":"If your drone has completed 5 dives and you do from blueye.sdk import Drone myDrone = Drone () print ( myDrone . logs ) you should see something like the following lines be printed Name Time Max depth Size ea9add4d40f69d4-00000.csv 24. Oct 2018 09:40 21.05 m 6.3 MiB ea9add4d40f69d4-00001.csv 25. Oct 2018 10:29 21.06 m 879.2 KiB ea9add4d40f69d4-00002.csv 31. Oct 2018 10:05 60.69 m 8.5 MiB ea9add4d40f69d4-00003.csv 31. Oct 2018 12:13 41.68 m 8.4 MiB ea9add4d40f69d4-00004.csv 02. Nov 2018 08:59 52.52 m 7.8 MiB The first part of the filename (the part before the -) is the unique ID of your drone and second part is the dive number. In addition we see the start time of the dive, the maximum depth reached, as well as the size of the log file. You might notice that there can be more log files listed then the amount of dives you have done. This is due to the fact that the drone creates a new log file whenever it is turned on, regardless of whether you actually took the drone for a dive. To easier separate out the log files that result from actual dives you can filter out all the dives with a max depth below some threshold. The Blueye app does this, filtering out all log files with a max depth below 20 cm.","title":"Listing the log files"},{"location":"docs/logs/listing-and-downloading/#downloading-a-log-file-to-your-computer","text":"When you want to download a log file all you have to do is to call the download() method on the desired log and the file will be downloaded to your current folder. The download() method takes two optional parameters, output_path and output_name . These specify, respectively, which folder the log is downloaded to and what name it's stored with.","title":"Downloading a log file to your computer"},{"location":"docs/logs/listing-and-downloading/#example-downloading-multiple-log-files","text":"Downloading multiple log files is solved by a simple Python for-loop. The example below shows how one can download the last 3 logs to the current folder: from blueye.sdk import Drone myDrone = Drone () for log in myDrone . logs [: - 3 ]: log . download ()","title":"Example: Downloading multiple log files"},{"location":"docs/logs/listing-and-downloading/#example-adding-a-prefix-to-log-names","text":"The example code below shows how one can add a simple prefix to all log files when downloading: from blueye.sdk import Drone myDrone = Drone () prefix = \"pre_\" for log in myDrone . logs : log . download ( output_name = prefix + log . name )","title":"Example: Adding a prefix to log names"},{"location":"docs/logs/log-file-format/","text":"Log file format The log files from the Blueye drones are in essence a recording of the data that is published over UDP stored as a comma-separated-value (CSV) file. The rest of this page documents the most useful fields of the log files. The column indices listed are zero-based. If you feel that some fields need more documentation, feel free to open an issue on Github , and we'll happily supply the requested information. Time Column Type Unit Description 2 Integer Milliseconds The elapsed time since the start of the log 3 Float Unix timestamp Global time Position The position is based on the user's phone's GPS at the start of the dive. Column Type Unit Description 6 Float Degrees Latitude 7 Float Degrees Longitude File storage Column Type Unit Description 8 Integer Bytes Total file storage on the drone 9 Integer Bytes Available free space Temperature Note: All temperatures are in \"deci-degrees Celsius\", ie. to get \u00b0C you need to divide the value by 10. Column Type Unit Description 11 Integer Deci-Celsius Bottom canister temperature 12 Integer Deci-Celsius Water temperature 13 Integer Deci-Celsius Top canister temperature 14 Integer Deci-Celsius CPU temperature Internal humidity Note: The unit is in deci-percent (ie. divide by 10 to get percent). Column Type Unit Description 15 Integer Deci-percent Humidity in the top canister. 16 Integer Deci-percent Humidity in the bottom canister. Lights Column Type Unit Description 17 Integer - State of the on-board light. Range is 0 to 255. Depth Column Type Unit Description 22 Integer Milli-meters Depth below water surface. Positive values are below the surface, negative are above. Control force Control force is the force exerted on the drone by the control system. Column Type Unit Description 29 Float Newton Force in the surge direction. 30 Float Newton Force in the sway direction. 31 Float Newton Force in the heave direction. 32 Float Newton-meters Moment in the yaw direction. Orientation (pose) Column Type Unit Description 32 Float Degrees Roll angle. Range from -180\u00b0 - 180\u00b0 33 Float Degrees Pitch angle. Range from -180\u00b0 - 180\u00b0 34 Float Degrees Yaw angle. Range from -180\u00b0 - 180\u00b0 Battery Column Type Unit Description 38 Integer Milli-volts Battery voltage 39 Integer Milli-amperes Battery current. Negative values are drained from the battery, positive are charged. 41 Integer Percent Relative state of charge. Range from 0 - 100 %","title":"Log file format"},{"location":"docs/logs/log-file-format/#log-file-format","text":"The log files from the Blueye drones are in essence a recording of the data that is published over UDP stored as a comma-separated-value (CSV) file. The rest of this page documents the most useful fields of the log files. The column indices listed are zero-based. If you feel that some fields need more documentation, feel free to open an issue on Github , and we'll happily supply the requested information.","title":"Log file format"},{"location":"docs/logs/log-file-format/#time","text":"Column Type Unit Description 2 Integer Milliseconds The elapsed time since the start of the log 3 Float Unix timestamp Global time","title":"Time"},{"location":"docs/logs/log-file-format/#position","text":"The position is based on the user's phone's GPS at the start of the dive. Column Type Unit Description 6 Float Degrees Latitude 7 Float Degrees Longitude","title":"Position"},{"location":"docs/logs/log-file-format/#file-storage","text":"Column Type Unit Description 8 Integer Bytes Total file storage on the drone 9 Integer Bytes Available free space","title":"File storage"},{"location":"docs/logs/log-file-format/#temperature","text":"Note: All temperatures are in \"deci-degrees Celsius\", ie. to get \u00b0C you need to divide the value by 10. Column Type Unit Description 11 Integer Deci-Celsius Bottom canister temperature 12 Integer Deci-Celsius Water temperature 13 Integer Deci-Celsius Top canister temperature 14 Integer Deci-Celsius CPU temperature","title":"Temperature"},{"location":"docs/logs/log-file-format/#internal-humidity","text":"Note: The unit is in deci-percent (ie. divide by 10 to get percent). Column Type Unit Description 15 Integer Deci-percent Humidity in the top canister. 16 Integer Deci-percent Humidity in the bottom canister.","title":"Internal humidity"},{"location":"docs/logs/log-file-format/#lights","text":"Column Type Unit Description 17 Integer - State of the on-board light. Range is 0 to 255.","title":"Lights"},{"location":"docs/logs/log-file-format/#depth","text":"Column Type Unit Description 22 Integer Milli-meters Depth below water surface. Positive values are below the surface, negative are above.","title":"Depth"},{"location":"docs/logs/log-file-format/#control-force","text":"Control force is the force exerted on the drone by the control system. Column Type Unit Description 29 Float Newton Force in the surge direction. 30 Float Newton Force in the sway direction. 31 Float Newton Force in the heave direction. 32 Float Newton-meters Moment in the yaw direction.","title":"Control force"},{"location":"docs/logs/log-file-format/#orientation-pose","text":"Column Type Unit Description 32 Float Degrees Roll angle. Range from -180\u00b0 - 180\u00b0 33 Float Degrees Pitch angle. Range from -180\u00b0 - 180\u00b0 34 Float Degrees Yaw angle. Range from -180\u00b0 - 180\u00b0","title":"Orientation (pose)"},{"location":"docs/logs/log-file-format/#battery","text":"Column Type Unit Description 38 Integer Milli-volts Battery voltage 39 Integer Milli-amperes Battery current. Negative values are drained from the battery, positive are charged. 41 Integer Percent Relative state of charge. Range from 0 - 100 %","title":"Battery"},{"location":"docs/logs/plotting/","text":"Plotting This example shows how one can pull a log file from the drone and use pandas and matplotlib to plot it. We'll start by downloading a log file from the drone from blueye.sdk import Drone myDrone = Drone () myDrone . logs [ 0 ] . download ( output_name = \"log0.csv\" ) We can now read the csv-file into a pandas object for easy manipulation import pandas divelog = pandas . read_csv ( \"log0.csv\" ) and then we'll convert the unix timestamp in rt_clock into a more readable format: divelog [ \"rt_clock\" ] = pandas . to_datetime ( divelog [ \"rt_clock\" ], unit = \"s\" ) Next we will plot depth vs time with matplotlib: import matplotlib.pyplot as plt # Instantiate our figure and axes to plot on figure , axes = plt . subplots () x = divelog [ \"rt_clock\" ] y = divelog [ \"depth\" ] / 1000 # Dividing by 1000 to get depth in meters # Plot the depth values against time axes . plot ( x , y , label = \"depth\" ) # Set title, labels, and legend plt . title ( \"Depth chart\" ) plt . xlabel ( \"Time\" ) plt . ylabel ( \"Depth [m]\" ) plt . legend () # Save the figure figure . savefig ( \"depth_plot.svg\" ) This should yield us a plot that looks something like this: See the matplotlib documentation for more ways to plot your data.","title":"Plotting log files"},{"location":"docs/logs/plotting/#plotting","text":"This example shows how one can pull a log file from the drone and use pandas and matplotlib to plot it. We'll start by downloading a log file from the drone from blueye.sdk import Drone myDrone = Drone () myDrone . logs [ 0 ] . download ( output_name = \"log0.csv\" ) We can now read the csv-file into a pandas object for easy manipulation import pandas divelog = pandas . read_csv ( \"log0.csv\" ) and then we'll convert the unix timestamp in rt_clock into a more readable format: divelog [ \"rt_clock\" ] = pandas . to_datetime ( divelog [ \"rt_clock\" ], unit = \"s\" ) Next we will plot depth vs time with matplotlib: import matplotlib.pyplot as plt # Instantiate our figure and axes to plot on figure , axes = plt . subplots () x = divelog [ \"rt_clock\" ] y = divelog [ \"depth\" ] / 1000 # Dividing by 1000 to get depth in meters # Plot the depth values against time axes . plot ( x , y , label = \"depth\" ) # Set title, labels, and legend plt . title ( \"Depth chart\" ) plt . xlabel ( \"Time\" ) plt . ylabel ( \"Depth [m]\" ) plt . legend () # Save the figure figure . savefig ( \"depth_plot.svg\" ) This should yield us a plot that looks something like this: See the matplotlib documentation for more ways to plot your data.","title":"Plotting"},{"location":"docs/movement/from-the-CLI/","text":"Controlling from the Command Line Interface This is a super simple example showing how you make the drone move from the command line interface: import time from blueye.sdk import Drone myDrone = Drone () myDrone . motion . surge = 0.4 time . sleep ( 1 ) myDrone . motion . surge = 0","title":"Control from the CLI"},{"location":"docs/movement/from-the-CLI/#controlling-from-the-command-line-interface","text":"This is a super simple example showing how you make the drone move from the command line interface: import time from blueye.sdk import Drone myDrone = Drone () myDrone . motion . surge = 0.4 time . sleep ( 1 ) myDrone . motion . surge = 0","title":"Controlling from the Command Line Interface"},{"location":"docs/movement/with-a-gamepad/","text":"Controlling the drone from a gamepad To run the example remember to first install the optional dependencies needed for running the examples pip install \"blueye.sdk[examples]\" The example below illustrates how one could use an Xbox controller and the SDK to control the drone. The inputs library supports many other gamepads, so using a different controller should be as simple as looking up the event codes for the buttons/axes and mapping them to the functions you want. import inputs from blueye.sdk import Drone class JoystickHandler : \"\"\"Maps drone functions to joystick events\"\"\" def __init__ ( self , drone ): self . drone = drone self . event_to_function_map = { \"BTN_NORTH\" : self . handle_x_button , \"BTN_WEST\" : self . handle_y_button , \"BTN_EAST\" : self . handle_b_button , \"BTN_SOUTH\" : self . handle_a_button , \"ABS_X\" : self . handle_left_x_axis , \"ABS_Y\" : self . handle_left_y_axis , \"ABS_Z\" : self . handle_left_trigger , \"ABS_RX\" : self . handle_right_x_axis , \"ABS_RY\" : self . handle_right_y_axis , \"ABS_RZ\" : self . handle_right_trigger , } def handle_x_button ( self , value ): \"\"\"Starts/stops the video recording\"\"\" self . drone . camera . is_recording = value def handle_y_button ( self , value ): \"\"\"Turns lights on or off\"\"\" if value : if self . drone . lights > 0 : self . drone . lights = 0 else : self . drone . lights = 10 def handle_b_button ( self , value ): \"\"\"Toggles autoheading\"\"\" if value : self . drone . motion . auto_heading_active = not self . drone . motion . auto_heading_active def handle_a_button ( self , value ): \"\"\"Toggles autodepth\"\"\" if value : self . drone . motion . auto_depth_active = not self . drone . motion . auto_depth_active def filter_and_normalize ( self , value , lower = 5000 , upper = 32768 ): \"\"\"Normalizing the joystick axis range from (default) -32768<->32678 to -1<->1 The sticks also tend to not stop at 0 when you let them go but rather some low value, so we'll filter those out as well. \"\"\" if - lower < value < lower : return 0 elif lower <= value <= upper : return ( value - lower ) / ( upper - lower ) elif - upper <= value <= - lower : return ( value + lower ) / ( upper - lower ) else : return 0 def handle_left_x_axis ( self , value ): self . drone . motion . yaw = self . filter_and_normalize ( value ) def handle_left_y_axis ( self , value ): self . drone . motion . heave = self . filter_and_normalize ( value ) def handle_right_x_axis ( self , value ): self . drone . motion . sway = self . filter_and_normalize ( value ) def handle_right_y_axis ( self , value ): self . drone . motion . surge = - self . filter_and_normalize ( value ) def handle_left_trigger ( self , value ): self . drone . motion . slow = self . filter_and_normalize ( value , lower = 0 , upper = 255 ) def handle_right_trigger ( self , value ): self . drone . motion . boost = self . filter_and_normalize ( value , lower = 0 , upper = 255 ) if __name__ == \"__main__\" : try : myDrone = Drone () handler = JoystickHandler ( myDrone ) while True : events = inputs . get_gamepad () for event in events : if event . code in handler . event_to_function_map : handler . event_to_function_map [ event . code ]( event . state ) except KeyboardInterrupt : pass","title":"Control with a gamepad"},{"location":"docs/movement/with-a-gamepad/#controlling-the-drone-from-a-gamepad","text":"To run the example remember to first install the optional dependencies needed for running the examples pip install \"blueye.sdk[examples]\" The example below illustrates how one could use an Xbox controller and the SDK to control the drone. The inputs library supports many other gamepads, so using a different controller should be as simple as looking up the event codes for the buttons/axes and mapping them to the functions you want. import inputs from blueye.sdk import Drone class JoystickHandler : \"\"\"Maps drone functions to joystick events\"\"\" def __init__ ( self , drone ): self . drone = drone self . event_to_function_map = { \"BTN_NORTH\" : self . handle_x_button , \"BTN_WEST\" : self . handle_y_button , \"BTN_EAST\" : self . handle_b_button , \"BTN_SOUTH\" : self . handle_a_button , \"ABS_X\" : self . handle_left_x_axis , \"ABS_Y\" : self . handle_left_y_axis , \"ABS_Z\" : self . handle_left_trigger , \"ABS_RX\" : self . handle_right_x_axis , \"ABS_RY\" : self . handle_right_y_axis , \"ABS_RZ\" : self . handle_right_trigger , } def handle_x_button ( self , value ): \"\"\"Starts/stops the video recording\"\"\" self . drone . camera . is_recording = value def handle_y_button ( self , value ): \"\"\"Turns lights on or off\"\"\" if value : if self . drone . lights > 0 : self . drone . lights = 0 else : self . drone . lights = 10 def handle_b_button ( self , value ): \"\"\"Toggles autoheading\"\"\" if value : self . drone . motion . auto_heading_active = not self . drone . motion . auto_heading_active def handle_a_button ( self , value ): \"\"\"Toggles autodepth\"\"\" if value : self . drone . motion . auto_depth_active = not self . drone . motion . auto_depth_active def filter_and_normalize ( self , value , lower = 5000 , upper = 32768 ): \"\"\"Normalizing the joystick axis range from (default) -32768<->32678 to -1<->1 The sticks also tend to not stop at 0 when you let them go but rather some low value, so we'll filter those out as well. \"\"\" if - lower < value < lower : return 0 elif lower <= value <= upper : return ( value - lower ) / ( upper - lower ) elif - upper <= value <= - lower : return ( value + lower ) / ( upper - lower ) else : return 0 def handle_left_x_axis ( self , value ): self . drone . motion . yaw = self . filter_and_normalize ( value ) def handle_left_y_axis ( self , value ): self . drone . motion . heave = self . filter_and_normalize ( value ) def handle_right_x_axis ( self , value ): self . drone . motion . sway = self . filter_and_normalize ( value ) def handle_right_y_axis ( self , value ): self . drone . motion . surge = - self . filter_and_normalize ( value ) def handle_left_trigger ( self , value ): self . drone . motion . slow = self . filter_and_normalize ( value , lower = 0 , upper = 255 ) def handle_right_trigger ( self , value ): self . drone . motion . boost = self . filter_and_normalize ( value , lower = 0 , upper = 255 ) if __name__ == \"__main__\" : try : myDrone = Drone () handler = JoystickHandler ( myDrone ) while True : events = inputs . get_gamepad () for event in events : if event . code in handler . event_to_function_map : handler . event_to_function_map [ event . code ]( event . state ) except KeyboardInterrupt : pass","title":"Controlling the drone from a gamepad"},{"location":"docs/video/downloading/","text":"Downloading videos and images Videos and images can easiest be downloaded through the mobile app, or by using the Blueye file transfer desktop application for Windows, Mac OS and Linux. If one wants a more control over the download process, all files are listable through any client that supports WebDAV . The server is available on the drone (default ip: 192.168.1.101 ) and port 5050 . For example using a Python WebDAV client we could do the following to list the files on drone: import webdav3.client as wc # Define the options for connecting options = { 'webdav_hostname' : \"http://192.168.1.101:5050\" } # Instantiate the connection client = wc . Client ( options ) # List the avaiable files client . list () Understanding the file name formats An example output from listing available files could be: 'video_BYEDP000105_2019-08-13_103035.jpg' 'video_BYEDP000105_2019-08-13_103035.mp4' 'picture_BYEDP000105_2019-09-27_074152.431.jpg' , The format of the file names are described below. Video files For each video recorded on the drone two files will be created, a .mp4 file with the actual video, and a .jpg file with a thumbnail image from the video file. Other than the file extension the file names will be identical. An example of a video + thumbnail pair could be: 'video_BYEDP000105_2019-08-13_103035.jpg' 'video_BYEDP000105_2019-08-13_103035.mp4' The file names break down to: File Type Prefix Drone Serial Number Timestamp (yyyy-MM-dd_hhmmss) File Extension video BYEDP000105 2019-08-13_103035 .mp4 video BYEDP000105 2019-08-13_103035 .jpg Image files Image files are images captured with the still image function. The file name for image files follow the same format as the video files, but the time stamp is extended with milliseconds to differentiate still images captured within the same second. An example still image file could be: 'picture_BYEDP000105_2019-09-27_074152.431.jpg' , The file name breaks down to: File Type Prefix Drone Serial Number Timestamp (yyyy-MM-dd_hhmmss.SSS) File Extension picture BYEDP000105 2019-09-27_074152.431 .jpg","title":"Downloading videos and images"},{"location":"docs/video/downloading/#downloading-videos-and-images","text":"Videos and images can easiest be downloaded through the mobile app, or by using the Blueye file transfer desktop application for Windows, Mac OS and Linux. If one wants a more control over the download process, all files are listable through any client that supports WebDAV . The server is available on the drone (default ip: 192.168.1.101 ) and port 5050 . For example using a Python WebDAV client we could do the following to list the files on drone: import webdav3.client as wc # Define the options for connecting options = { 'webdav_hostname' : \"http://192.168.1.101:5050\" } # Instantiate the connection client = wc . Client ( options ) # List the avaiable files client . list ()","title":"Downloading videos and images"},{"location":"docs/video/downloading/#understanding-the-file-name-formats","text":"An example output from listing available files could be: 'video_BYEDP000105_2019-08-13_103035.jpg' 'video_BYEDP000105_2019-08-13_103035.mp4' 'picture_BYEDP000105_2019-09-27_074152.431.jpg' , The format of the file names are described below.","title":"Understanding the file name formats"},{"location":"docs/video/downloading/#video-files","text":"For each video recorded on the drone two files will be created, a .mp4 file with the actual video, and a .jpg file with a thumbnail image from the video file. Other than the file extension the file names will be identical. An example of a video + thumbnail pair could be: 'video_BYEDP000105_2019-08-13_103035.jpg' 'video_BYEDP000105_2019-08-13_103035.mp4' The file names break down to: File Type Prefix Drone Serial Number Timestamp (yyyy-MM-dd_hhmmss) File Extension video BYEDP000105 2019-08-13_103035 .mp4 video BYEDP000105 2019-08-13_103035 .jpg","title":"Video files"},{"location":"docs/video/downloading/#image-files","text":"Image files are images captured with the still image function. The file name for image files follow the same format as the video files, but the time stamp is extended with milliseconds to differentiate still images captured within the same second. An example still image file could be: 'picture_BYEDP000105_2019-09-27_074152.431.jpg' , The file name breaks down to: File Type Prefix Drone Serial Number Timestamp (yyyy-MM-dd_hhmmss.SSS) File Extension picture BYEDP000105 2019-09-27_074152.431 .jpg","title":"Image files"},{"location":"docs/video/gstreamer-for-video-streaming/","text":"GStreamer is the lowest latency alternative for streaming video from the drone to your laptop. Installing GStreamer To run the streaming pipeline in the next section you will need a runtime installation of GStreamer. The instructions below show the basic steps for installing GStreamer on the most common operating systems. You can find more in depth instruction for your specific operating system in the GStreamer docs . Windows On Windows the basic installation steps are: Download the relevant installer for your computer from https://gstreamer.freedesktop.org/download . Using the latest stable relase should be fine, at the time of writing that is 1.16.1 runtime installer Run the installer. When asked to choose a setup type choose to do a complete installation. This is because some plugins that are needed for the basic pipeline later are not included if you choose to install the typical setup To run GStreamer commands form the terminal, GStreamer must be added to the PATH environment variable. This can be done from the advanced system settings. Add %GSTREAMER_1_0_ROOT_X86_64%\\bin to path. Alternatively you can choose to run gst-launch-1.0.exe from the folder it is installed in, typically C:\\gstreamer\\1.0\\x86_64\\bin Mac OS On Mac OS GStreamer and its plugins can be installed using brew brew install gstreamer gst-plugins-base gst-plugins-good gst-plugins-bad gst-plugins-ugly gst-libav Linux On Ubuntu and Debian GStreamer and its plugins can be installed using apt. apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc \\ gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa You can test the installation by trying the basic pipeline from the next section when connected to a drone. Or with gst-launch-1.0 videotestsrc ! autovideosink Basic streaming pipeline After installing you can run this pipeline in your terminal: Windows gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 ! rtph264depay ! avdec_h264 ! videoconvert ! fpsdisplaysink sync = false Linux and macOS gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 \\ ! rtph264depay \\ ! avdec_h264 \\ ! videoconvert \\ ! fpsdisplaysink sync = false Running the pipeline will open a window with the camera stream and information about packet loss and camera frame rate. External camera streaming pipeline If you have a X3 drone with an external camera connected you can use the following pipeline: Windows gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8555/guestport_cam latency = 0 ! rtph264depay ! avdec_h264 ! videoconvert ! autovideosink sync = false Linux and macOS gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8555/guestport_cam latency = 0 \\ ! rtph264depay \\ ! avdec_h264 \\ ! videoconvert \\ ! autovideosink sync = false Running the pipeline will open a window with the external camera stream.","title":"GStreamer for video streaming"},{"location":"docs/video/gstreamer-for-video-streaming/#installing-gstreamer","text":"To run the streaming pipeline in the next section you will need a runtime installation of GStreamer. The instructions below show the basic steps for installing GStreamer on the most common operating systems. You can find more in depth instruction for your specific operating system in the GStreamer docs . Windows On Windows the basic installation steps are: Download the relevant installer for your computer from https://gstreamer.freedesktop.org/download . Using the latest stable relase should be fine, at the time of writing that is 1.16.1 runtime installer Run the installer. When asked to choose a setup type choose to do a complete installation. This is because some plugins that are needed for the basic pipeline later are not included if you choose to install the typical setup To run GStreamer commands form the terminal, GStreamer must be added to the PATH environment variable. This can be done from the advanced system settings. Add %GSTREAMER_1_0_ROOT_X86_64%\\bin to path. Alternatively you can choose to run gst-launch-1.0.exe from the folder it is installed in, typically C:\\gstreamer\\1.0\\x86_64\\bin Mac OS On Mac OS GStreamer and its plugins can be installed using brew brew install gstreamer gst-plugins-base gst-plugins-good gst-plugins-bad gst-plugins-ugly gst-libav Linux On Ubuntu and Debian GStreamer and its plugins can be installed using apt. apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc \\ gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa You can test the installation by trying the basic pipeline from the next section when connected to a drone. Or with gst-launch-1.0 videotestsrc ! autovideosink","title":"Installing GStreamer"},{"location":"docs/video/gstreamer-for-video-streaming/#basic-streaming-pipeline","text":"After installing you can run this pipeline in your terminal: Windows gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 ! rtph264depay ! avdec_h264 ! videoconvert ! fpsdisplaysink sync = false Linux and macOS gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 \\ ! rtph264depay \\ ! avdec_h264 \\ ! videoconvert \\ ! fpsdisplaysink sync = false Running the pipeline will open a window with the camera stream and information about packet loss and camera frame rate.","title":"Basic streaming pipeline"},{"location":"docs/video/gstreamer-for-video-streaming/#external-camera-streaming-pipeline","text":"If you have a X3 drone with an external camera connected you can use the following pipeline: Windows gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8555/guestport_cam latency = 0 ! rtph264depay ! avdec_h264 ! videoconvert ! autovideosink sync = false Linux and macOS gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8555/guestport_cam latency = 0 \\ ! rtph264depay \\ ! avdec_h264 \\ ! videoconvert \\ ! autovideosink sync = false Running the pipeline will open a window with the external camera stream.","title":"External camera streaming pipeline"},{"location":"reference/blueye/sdk/","text":"Module blueye.sdk View Source from .camera import DepthUnitOverlay, FontSizeOverlay, LogoOverlay, TemperatureUnitOverlay from .constants import WaterDensities from .drone import Drone, Pioneer from .utils import open_local_documentation Sub-modules blueye.sdk.camera blueye.sdk.constants blueye.sdk.drone blueye.sdk.logs blueye.sdk.motion blueye.sdk.utils","title":"Index"},{"location":"reference/blueye/sdk/#module-blueyesdk","text":"View Source from .camera import DepthUnitOverlay, FontSizeOverlay, LogoOverlay, TemperatureUnitOverlay from .constants import WaterDensities from .drone import Drone, Pioneer from .utils import open_local_documentation","title":"Module blueye.sdk"},{"location":"reference/blueye/sdk/#sub-modules","text":"blueye.sdk.camera blueye.sdk.constants blueye.sdk.drone blueye.sdk.logs blueye.sdk.motion blueye.sdk.utils","title":"Sub-modules"},{"location":"reference/blueye/sdk/camera/","text":"Module blueye.sdk.camera View Source from __future__ import annotations import re import warnings from collections import namedtuple from enum import Enum from typing import TYPE_CHECKING, NamedTuple import numpy as np import requests # Necessary to avoid cyclic imports if TYPE_CHECKING: from .drone import Drone class Tilt: @staticmethod def _tilt_angle_from_debug_flags(flags: int) -> int: \"\"\"Helper function for decoding tilt angle from debug flags The tilt angle is encoded as an int8, with 0 at 0 degrees, and each increment representing 0.5 degrees in either direction. A positive angle is upwards, and negative is downwards. \"\"\" tilt_angle_array = np.array( np.right_shift(np.bitwise_and(flags, 0x0000FF0000000000), 40), dtype=[(\"tilt_angle\", np.int8)], ).astype([(\"tilt_angle\", float)]) return tilt_angle_array[\"tilt_angle\"] / 2 def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def set_speed(self, speed: int): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * speed (int): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") self._parent_drone._verify_required_blunux_version(\"1.5\") # The tilt command is grouped together with the thruster commands, so to avoid messing with # the thruster setpoint while tilting we need to get the current setpoint and send it with # the tilt command. with self._parent_drone.motion.thruster_lock: thruster_setpoints = self._parent_drone.motion.current_thruster_setpoints.values() self._parent_drone._tcp_client.motion_input_tilt(*thruster_setpoints, 0, 0, speed) @property def angle(self) -> int: \"\"\"Return the current angle of the camera tilt Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") self._parent_drone._verify_required_blunux_version(\"1.5\") debug_flags = self._parent_drone._state_watcher.general_state[\"debug_flags\"] return self._tilt_angle_from_debug_flags(debug_flags) class LogoOverlay(Enum): DISABLED = 0 BLUEYE = 1 CUSTOM = 2 class DepthUnitOverlay(Enum): METERS = 0 FEET = 1 class TemperatureUnitOverlay(Enum): CELSIUS = 0 FAHRENHEIT = 1 class FontSizeOverlay(Enum): PX15 = 15 PX20 = 20 PX25 = 25 PX30 = 30 PX35 = 35 PX40 = 40 class Overlay: \"\"\"Control the overlay on videos and pictures\"\"\" def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def _get_named_overlay_parameters(self) -> NamedTuple: \"\"\"Get overlay parameters from drone and convert them to a named tuple\"\"\" NamedParameters = namedtuple( \"Parameters\", [ \"returned_parameter\", \"temperature_enabled\", \"depth_enabled\", \"heading_enabled\", \"tilt_enabled\", \"date_enabled\", \"logo_index\", \"depth_unit\", \"temperature_unit\", \"tz_offset\", \"margin_width\", \"margin_height\", \"font_size\", \"title\", \"subtitle\", \"date_format\", ], ) parameters = self._parent_drone._tcp_client.get_overlay_parameters() return NamedParameters(*parameters) @property def temperature_enabled(self) -> bool: \"\"\"Get or set the state of the temperature overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().temperature_enabled) @temperature_enabled.setter def temperature_enabled(self, enable_temperature: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_temperature_enabled( 1 if enable_temperature else 0 ) @property def depth_enabled(self) -> bool: \"\"\"Get or set the state of the depth overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().depth_enabled) @depth_enabled.setter def depth_enabled(self, enable_depth: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_depth_enabled(1 if enable_depth else 0) @property def heading_enabled(self) -> bool: \"\"\"Get or set the state of the heading overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().heading_enabled) @heading_enabled.setter def heading_enabled(self, enable_heading: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_heading_enabled(1 if enable_heading else 0) @property def tilt_enabled(self) -> bool: \"\"\"Get or set the state of the tilt overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().tilt_enabled) @tilt_enabled.setter def tilt_enabled(self, enable_tilt: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_tilt_enabled(1 if enable_tilt else 0) @property def date_enabled(self) -> bool: \"\"\"Get or set the state of the date overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().date_enabled) @date_enabled.setter def date_enabled(self, enable_date: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_date_enabled(1 if enable_date else 0) @property def logo(self) -> LogoOverlay: \"\"\"Get or set logo overlay selection Needs to be set to an instance of the `LogoOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.8.72 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") return LogoOverlay(self._get_named_overlay_parameters().logo_index) @logo.setter def logo(self, logo_index: LogoOverlay): self._parent_drone._verify_required_blunux_version(\"1.8.72\") if not isinstance(logo_index, LogoOverlay): warnings.warn(\"Invalid logo index, ignoring\", RuntimeWarning) elif logo_index.value not in range(3): warnings.warn(\"Logo index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_logo_index(logo_index.value) @property def depth_unit(self) -> DepthUnitOverlay: \"\"\"Get or set the depth unit for the overlay Needs to be set to an instance of the `DepthUnitOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return DepthUnitOverlay(self._get_named_overlay_parameters().depth_unit) @depth_unit.setter def depth_unit(self, unit_index: DepthUnitOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(unit_index, DepthUnitOverlay): warnings.warn(\"Invalid depth unit index, ignoring\", RuntimeWarning) elif unit_index.value not in range(2): warnings.warn(\"Depth unit index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_depth_unit(unit_index.value) @property def temperature_unit(self) -> TemperatureUnitOverlay: \"\"\"Get or set the temperature unit for the overlay Needs to be set to an instance of the `TemperatureUnitOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return TemperatureUnitOverlay(self._get_named_overlay_parameters().temperature_unit) @temperature_unit.setter def temperature_unit(self, unit_index: TemperatureUnitOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(unit_index, TemperatureUnitOverlay): warnings.warn(\"Invalid temperature unit index, ignoring\", RuntimeWarning) elif unit_index.value not in range(2): warnings.warn(\"Temperature unit index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_temperature_unit(unit_index.value) @property def timezone_offset(self) -> int: \"\"\"Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().tz_offset @timezone_offset.setter def timezone_offset(self, offset: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_tz_offset(offset) @property def margin_width(self) -> int: \"\"\"Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().margin_width @margin_width.setter def margin_width(self, width: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if width < 0: warnings.warn(\"Invalid margin width, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_margin_width(width) @property def margin_height(self) -> int: \"\"\"Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().margin_height @margin_height.setter def margin_height(self, height: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if height < 0: warnings.warn(\"Invalid margin height, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_margin_height(height) @property def font_size(self) -> FontSizeOverlay: \"\"\"Get or set the font size for the overlay Needs to be an instance of the `FontSizeOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return FontSizeOverlay(self._get_named_overlay_parameters().font_size) @font_size.setter def font_size(self, size: FontSizeOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(size, FontSizeOverlay): warnings.warn(\"Invalid font size, ignoring\", RuntimeWarning) elif size.value not in range(15, 41): warnings.warn(\"Font size out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_font_size(size.value) @property def title(self) -> str: \"\"\"Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().title.decode(\"utf-8\").rstrip(\"\\x00\") @title.setter def title(self, input_title: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") new_title = input_title if len(input_title) > 63: warnings.warn(\"Too long title, truncating to 63 characters\", RuntimeWarning) new_title = new_title[:63] try: encoded_title = bytes(new_title, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Title can only contain ASCII characters, ignoring\", RuntimeWarning) return self._parent_drone._tcp_client.set_overlay_title(encoded_title + b\"\\x00\") @property def subtitle(self) -> str: \"\"\"Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().subtitle.decode(\"utf-8\").rstrip(\"\\x00\") @subtitle.setter def subtitle(self, input_subtitle: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") new_subtitle = input_subtitle if len(input_subtitle) > 63: warnings.warn(\"Too long subtitle, truncating to 63 characters\", RuntimeWarning) new_subtitle = new_subtitle[:63] try: encoded_subtitle = bytes(new_subtitle, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Subtitle can only contain ASCII characters, ignoring\", RuntimeWarning) return self._parent_drone._tcp_client.set_overlay_subtitle(encoded_subtitle + b\"\\x00\") @property def date_format(self) -> str: \"\"\"Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().date_format.decode(\"utf-8\").rstrip(\"\\x00\") @date_format.setter def date_format(self, input_format_str: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") format_str = input_format_str if len(format_str) > 63: warnings.warn( \"Too long date format string, truncating to 63 characters\", RuntimeWarning ) format_str = format_str[:63] try: encoded_format_str = bytes(format_str, \"ascii\") except UnicodeEncodeError: warnings.warn( \"Date format string can only contain ASCII characters, ignoring\", RuntimeWarning ) return self._parent_drone._tcp_client.set_overlay_date_format(encoded_format_str + b\"\\x00\") def upload_logo(self, path_to_logo: str): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `LogoOverlay.CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. Requires Blunux version 1.8.72 or newer. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=1) response.raise_for_status() def download_logo(self, output_directory=\".\"): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content) def delete_logo(self): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status() class Camera: def __init__(self, parent_drone: Drone): self._state_watcher = parent_drone._state_watcher self._parent_drone = parent_drone self.tilt = Tilt(parent_drone) self.overlay = Overlay(parent_drone) @property def is_recording(self) -> bool: \"\"\"Start or stop a camera recording *Arguments*: * is_recording (bool): Set to True to start a recording, set to False to stop the current recording *Returns*: * is_recording (bool): True if the camera is currently recording, False if not \"\"\" state = self._state_watcher.general_state if state[\"camera_record_time\"] != -1: return True else: return False @is_recording.setter def is_recording(self, start_recording: bool): if start_recording: self._parent_drone._tcp_client.start_recording() else: self._parent_drone._tcp_client.stop_recording() @property def bitrate(self) -> int: \"\"\"Set or get the camera bitrate *Arguments*: * bitrate (int): Set the camera bitrate in bits, Valid values are in range <1 000 000, 16 000 000> *Returns*: * bitrate (int): Get the camera bitrate \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() bitrate = camera_parameters[1] return bitrate @bitrate.setter def bitrate(self, bitrate: int): self._parent_drone._tcp_client.set_camera_bitrate(bitrate) @property def exposure(self) -> int: \"\"\"Set or get the camera exposure *Arguments*: * exposure (int): Set the camera exposure_value: 1 = 1/1000th of a second, 5 = 1/200th of a second. Valid values are in the range <1, 5000> *Returns*: * exposure (int): Get the camera exposure \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() exposure = camera_parameters[2] return exposure @exposure.setter def exposure(self, exposure: int): self._parent_drone._tcp_client.set_camera_exposure(exposure) @property def whitebalance(self) -> int: \"\"\"Set or get the camera white balance *Arguments*: * whitebalance (int): Set the camera white balance. Valid values are in the range <2800, 9300> *Returns*: * whitebalance (int): Get the camera white balance \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() whitebalance = camera_parameters[3] return whitebalance @whitebalance.setter def whitebalance(self, whitebalance: int): self._parent_drone._tcp_client.set_camera_whitebalance(whitebalance) @property def hue(self) -> int: \"\"\"Set or get the camera hue *Arguments*: * hue (int): Set the camera hue. Valid values are in the range <-40, 40> *Returns*: * hue (int): Get the camera hue \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() hue = camera_parameters[4] return hue @hue.setter def hue(self, hue: int): self._parent_drone._tcp_client.set_camera_hue(hue) @property def resolution(self) -> int: \"\"\"Set or get the camera resolution *Arguments*: * resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 *Returns*: * resolution (int): Get the camera resolution \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() resolution = camera_parameters[5] return resolution @resolution.setter def resolution(self, resolution: int): self._parent_drone._tcp_client.set_camera_resolution(resolution) @property def framerate(self) -> int: \"\"\"Set or get the camera frame rate *Arguments*: * framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 *Returns*: * framerate (int): Get the camera frame rate \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() framerate = camera_parameters[6] return framerate @framerate.setter def framerate(self, framerate: int): self._parent_drone._tcp_client.set_camera_framerate(framerate) @property def record_time(self) -> int: \"\"\"Set or get the duration of the current camera recording *Returns*: * record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording \"\"\" return self._state_watcher.general_state[\"camera_record_time\"] def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. This feature was added with drone version 1.4.7, so if you try to use it with an older version this method will raise a RunTimeError. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.4.7\") self._parent_drone._tcp_client.take_still_picture() Variables TYPE_CHECKING Classes Camera class Camera ( parent_drone : 'Drone' ) View Source class Camera: def __init__(self, parent_drone: Drone): self._state_watcher = parent_drone._state_watcher self._parent_drone = parent_drone self.tilt = Tilt(parent_drone) self.overlay = Overlay(parent_drone) @property def is_recording(self) -> bool: \"\"\"Start or stop a camera recording *Arguments*: * is_recording (bool): Set to True to start a recording, set to False to stop the current recording *Returns*: * is_recording (bool): True if the camera is currently recording, False if not \"\"\" state = self._state_watcher.general_state if state[\"camera_record_time\"] != -1: return True else: return False @is_recording.setter def is_recording(self, start_recording: bool): if start_recording: self._parent_drone._tcp_client.start_recording() else: self._parent_drone._tcp_client.stop_recording() @property def bitrate(self) -> int: \"\"\"Set or get the camera bitrate *Arguments*: * bitrate (int): Set the camera bitrate in bits, Valid values are in range <1 000 000, 16 000 000> *Returns*: * bitrate (int): Get the camera bitrate \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() bitrate = camera_parameters[1] return bitrate @bitrate.setter def bitrate(self, bitrate: int): self._parent_drone._tcp_client.set_camera_bitrate(bitrate) @property def exposure(self) -> int: \"\"\"Set or get the camera exposure *Arguments*: * exposure (int): Set the camera exposure_value: 1 = 1/1000th of a second, 5 = 1/200th of a second. Valid values are in the range <1, 5000> *Returns*: * exposure (int): Get the camera exposure \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() exposure = camera_parameters[2] return exposure @exposure.setter def exposure(self, exposure: int): self._parent_drone._tcp_client.set_camera_exposure(exposure) @property def whitebalance(self) -> int: \"\"\"Set or get the camera white balance *Arguments*: * whitebalance (int): Set the camera white balance. Valid values are in the range <2800, 9300> *Returns*: * whitebalance (int): Get the camera white balance \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() whitebalance = camera_parameters[3] return whitebalance @whitebalance.setter def whitebalance(self, whitebalance: int): self._parent_drone._tcp_client.set_camera_whitebalance(whitebalance) @property def hue(self) -> int: \"\"\"Set or get the camera hue *Arguments*: * hue (int): Set the camera hue. Valid values are in the range <-40, 40> *Returns*: * hue (int): Get the camera hue \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() hue = camera_parameters[4] return hue @hue.setter def hue(self, hue: int): self._parent_drone._tcp_client.set_camera_hue(hue) @property def resolution(self) -> int: \"\"\"Set or get the camera resolution *Arguments*: * resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 *Returns*: * resolution (int): Get the camera resolution \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() resolution = camera_parameters[5] return resolution @resolution.setter def resolution(self, resolution: int): self._parent_drone._tcp_client.set_camera_resolution(resolution) @property def framerate(self) -> int: \"\"\"Set or get the camera frame rate *Arguments*: * framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 *Returns*: * framerate (int): Get the camera frame rate \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() framerate = camera_parameters[6] return framerate @framerate.setter def framerate(self, framerate: int): self._parent_drone._tcp_client.set_camera_framerate(framerate) @property def record_time(self) -> int: \"\"\"Set or get the duration of the current camera recording *Returns*: * record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording \"\"\" return self._state_watcher.general_state[\"camera_record_time\"] def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. This feature was added with drone version 1.4.7, so if you try to use it with an older version this method will raise a RunTimeError. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.4.7\") self._parent_drone._tcp_client.take_still_picture() Instance variables bitrate Set or get the camera bitrate Arguments : bitrate (int): Set the camera bitrate in bits, Valid values are in range <1 000 000, 16 000 000> Returns : bitrate (int): Get the camera bitrate exposure Set or get the camera exposure Arguments : exposure (int): Set the camera exposure_value: 1 = 1/1000 th of a second, 5 = 1/200 th of a second. Valid values are in the range <1, 5000> Returns : exposure (int): Get the camera exposure framerate Set or get the camera frame rate Arguments : framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 Returns : framerate (int): Get the camera frame rate hue Set or get the camera hue Arguments : hue (int): Set the camera hue. Valid values are in the range <-40, 40> Returns : hue (int): Get the camera hue is_recording Start or stop a camera recording Arguments : is_recording (bool): Set to True to start a recording, set to False to stop the current recording Returns : is_recording (bool): True if the camera is currently recording, False if not record_time Set or get the duration of the current camera recording Returns : record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording resolution Set or get the camera resolution Arguments : resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 Returns : resolution (int): Get the camera resolution whitebalance Set or get the camera white balance Arguments : whitebalance (int): Set the camera white balance. Valid values are in the range <2800, 9300> Returns : whitebalance (int): Get the camera white balance Methods take_picture def take_picture ( self ) Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. This feature was added with drone version 1.4.7, so if you try to use it with an older version this method will raise a RunTimeError. View Source def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. This feature was added with drone version 1.4.7, so if you try to use it with an older version this method will raise a RunTimeError. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.4.7\") self._parent_drone._tcp_client.take_still_picture() DepthUnitOverlay class DepthUnitOverlay ( / , * args , ** kwargs ) An enumeration. View Source class DepthUnitOverlay(Enum): METERS = 0 FEET = 1 Ancestors (in MRO) enum.Enum Class variables FEET METERS name value FontSizeOverlay class FontSizeOverlay ( / , * args , ** kwargs ) An enumeration. View Source class FontSizeOverlay(Enum): PX15 = 15 PX20 = 20 PX25 = 25 PX30 = 30 PX35 = 35 PX40 = 40 Ancestors (in MRO) enum.Enum Class variables PX15 PX20 PX25 PX30 PX35 PX40 name value LogoOverlay class LogoOverlay ( / , * args , ** kwargs ) An enumeration. View Source class LogoOverlay(Enum): DISABLED = 0 BLUEYE = 1 CUSTOM = 2 Ancestors (in MRO) enum.Enum Class variables BLUEYE CUSTOM DISABLED name value Overlay class Overlay ( parent_drone : 'Drone' ) Control the overlay on videos and pictures View Source class Overlay: \"\"\"Control the overlay on videos and pictures\"\"\" def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def _get_named_overlay_parameters(self) -> NamedTuple: \"\"\"Get overlay parameters from drone and convert them to a named tuple\"\"\" NamedParameters = namedtuple( \"Parameters\", [ \"returned_parameter\", \"temperature_enabled\", \"depth_enabled\", \"heading_enabled\", \"tilt_enabled\", \"date_enabled\", \"logo_index\", \"depth_unit\", \"temperature_unit\", \"tz_offset\", \"margin_width\", \"margin_height\", \"font_size\", \"title\", \"subtitle\", \"date_format\", ], ) parameters = self._parent_drone._tcp_client.get_overlay_parameters() return NamedParameters(*parameters) @property def temperature_enabled(self) -> bool: \"\"\"Get or set the state of the temperature overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().temperature_enabled) @temperature_enabled.setter def temperature_enabled(self, enable_temperature: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_temperature_enabled( 1 if enable_temperature else 0 ) @property def depth_enabled(self) -> bool: \"\"\"Get or set the state of the depth overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().depth_enabled) @depth_enabled.setter def depth_enabled(self, enable_depth: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_depth_enabled(1 if enable_depth else 0) @property def heading_enabled(self) -> bool: \"\"\"Get or set the state of the heading overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().heading_enabled) @heading_enabled.setter def heading_enabled(self, enable_heading: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_heading_enabled(1 if enable_heading else 0) @property def tilt_enabled(self) -> bool: \"\"\"Get or set the state of the tilt overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().tilt_enabled) @tilt_enabled.setter def tilt_enabled(self, enable_tilt: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_tilt_enabled(1 if enable_tilt else 0) @property def date_enabled(self) -> bool: \"\"\"Get or set the state of the date overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().date_enabled) @date_enabled.setter def date_enabled(self, enable_date: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_date_enabled(1 if enable_date else 0) @property def logo(self) -> LogoOverlay: \"\"\"Get or set logo overlay selection Needs to be set to an instance of the `LogoOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.8.72 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") return LogoOverlay(self._get_named_overlay_parameters().logo_index) @logo.setter def logo(self, logo_index: LogoOverlay): self._parent_drone._verify_required_blunux_version(\"1.8.72\") if not isinstance(logo_index, LogoOverlay): warnings.warn(\"Invalid logo index, ignoring\", RuntimeWarning) elif logo_index.value not in range(3): warnings.warn(\"Logo index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_logo_index(logo_index.value) @property def depth_unit(self) -> DepthUnitOverlay: \"\"\"Get or set the depth unit for the overlay Needs to be set to an instance of the `DepthUnitOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return DepthUnitOverlay(self._get_named_overlay_parameters().depth_unit) @depth_unit.setter def depth_unit(self, unit_index: DepthUnitOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(unit_index, DepthUnitOverlay): warnings.warn(\"Invalid depth unit index, ignoring\", RuntimeWarning) elif unit_index.value not in range(2): warnings.warn(\"Depth unit index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_depth_unit(unit_index.value) @property def temperature_unit(self) -> TemperatureUnitOverlay: \"\"\"Get or set the temperature unit for the overlay Needs to be set to an instance of the `TemperatureUnitOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return TemperatureUnitOverlay(self._get_named_overlay_parameters().temperature_unit) @temperature_unit.setter def temperature_unit(self, unit_index: TemperatureUnitOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(unit_index, TemperatureUnitOverlay): warnings.warn(\"Invalid temperature unit index, ignoring\", RuntimeWarning) elif unit_index.value not in range(2): warnings.warn(\"Temperature unit index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_temperature_unit(unit_index.value) @property def timezone_offset(self) -> int: \"\"\"Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().tz_offset @timezone_offset.setter def timezone_offset(self, offset: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_tz_offset(offset) @property def margin_width(self) -> int: \"\"\"Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().margin_width @margin_width.setter def margin_width(self, width: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if width < 0: warnings.warn(\"Invalid margin width, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_margin_width(width) @property def margin_height(self) -> int: \"\"\"Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().margin_height @margin_height.setter def margin_height(self, height: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if height < 0: warnings.warn(\"Invalid margin height, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_margin_height(height) @property def font_size(self) -> FontSizeOverlay: \"\"\"Get or set the font size for the overlay Needs to be an instance of the `FontSizeOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return FontSizeOverlay(self._get_named_overlay_parameters().font_size) @font_size.setter def font_size(self, size: FontSizeOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(size, FontSizeOverlay): warnings.warn(\"Invalid font size, ignoring\", RuntimeWarning) elif size.value not in range(15, 41): warnings.warn(\"Font size out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_font_size(size.value) @property def title(self) -> str: \"\"\"Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().title.decode(\"utf-8\").rstrip(\"\\x00\") @title.setter def title(self, input_title: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") new_title = input_title if len(input_title) > 63: warnings.warn(\"Too long title, truncating to 63 characters\", RuntimeWarning) new_title = new_title[:63] try: encoded_title = bytes(new_title, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Title can only contain ASCII characters, ignoring\", RuntimeWarning) return self._parent_drone._tcp_client.set_overlay_title(encoded_title + b\"\\x00\") @property def subtitle(self) -> str: \"\"\"Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().subtitle.decode(\"utf-8\").rstrip(\"\\x00\") @subtitle.setter def subtitle(self, input_subtitle: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") new_subtitle = input_subtitle if len(input_subtitle) > 63: warnings.warn(\"Too long subtitle, truncating to 63 characters\", RuntimeWarning) new_subtitle = new_subtitle[:63] try: encoded_subtitle = bytes(new_subtitle, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Subtitle can only contain ASCII characters, ignoring\", RuntimeWarning) return self._parent_drone._tcp_client.set_overlay_subtitle(encoded_subtitle + b\"\\x00\") @property def date_format(self) -> str: \"\"\"Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().date_format.decode(\"utf-8\").rstrip(\"\\x00\") @date_format.setter def date_format(self, input_format_str: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") format_str = input_format_str if len(format_str) > 63: warnings.warn( \"Too long date format string, truncating to 63 characters\", RuntimeWarning ) format_str = format_str[:63] try: encoded_format_str = bytes(format_str, \"ascii\") except UnicodeEncodeError: warnings.warn( \"Date format string can only contain ASCII characters, ignoring\", RuntimeWarning ) return self._parent_drone._tcp_client.set_overlay_date_format(encoded_format_str + b\"\\x00\") def upload_logo(self, path_to_logo: str): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `LogoOverlay.CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. Requires Blunux version 1.8.72 or newer. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=1) response.raise_for_status() def download_logo(self, output_directory=\".\"): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content) def delete_logo(self): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status() Instance variables date_enabled Get or set the state of the date overlay Requires Blunux version 1.7.60 or newer. date_format Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. depth_enabled Get or set the state of the depth overlay Requires Blunux version 1.7.60 or newer. depth_unit Get or set the depth unit for the overlay Needs to be set to an instance of the DepthUnitOverlay class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. font_size Get or set the font size for the overlay Needs to be an instance of the FontSizeOverlay class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. heading_enabled Get or set the state of the heading overlay Requires Blunux version 1.7.60 or newer. logo Get or set logo overlay selection Needs to be set to an instance of the LogoOverlay class, if not a RuntimeWarning is raised. Requires Blunux version 1.8.72 or newer. margin_height Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. margin_width Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. subtitle Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. Requires Blunux version 1.7.60 or newer. temperature_enabled Get or set the state of the temperature overlay Requires Blunux version 1.7.60 or newer. temperature_unit Get or set the temperature unit for the overlay Needs to be set to an instance of the TemperatureUnitOverlay class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. tilt_enabled Get or set the state of the tilt overlay Requires Blunux version 1.7.60 or newer. timezone_offset Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. Requires Blunux version 1.7.60 or newer. title Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. Requires Blunux version 1.7.60 or newer. Methods delete_logo def delete_logo ( self ) Delete the user uploaded logo from the drone Exceptions : requests.exceptions.HTTPError : If an error occurs during deletion requests.exceptions.ConnectTimeout : If unable to create a connection within 1s View Source def delete_logo(self): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status() download_logo def download_logo ( self , output_directory = '.' ) Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. Exceptions : requests.exceptions.HTTPError : If no custom logo is uploaded. requests.exceptions.ConnectTimeout : If unable to create a connection within 1s View Source def download_logo(self, output_directory=\".\"): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content) upload_logo def upload_logo ( self , path_to_logo : 'str' ) Upload user selectable logo for watermarking videos and pictures Set the logo-property to LogoOverlay.CUSTOM to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. Requires Blunux version 1.8.72 or newer. Exceptions : requests.exceptions.HTTPError : Status code 400 for invalid files requests.exceptions.ConnectTimeout : If unable to create a connection within 1s View Source def upload_logo(self, path_to_logo: str): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `LogoOverlay.CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. Requires Blunux version 1.8.72 or newer. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=1) response.raise_for_status() TemperatureUnitOverlay class TemperatureUnitOverlay ( / , * args , ** kwargs ) An enumeration. View Source class TemperatureUnitOverlay(Enum): CELSIUS = 0 FAHRENHEIT = 1 Ancestors (in MRO) enum.Enum Class variables CELSIUS FAHRENHEIT name value Tilt class Tilt ( parent_drone : 'Drone' ) View Source class Tilt: @staticmethod def _tilt_angle_from_debug_flags(flags: int) -> int: \"\"\"Helper function for decoding tilt angle from debug flags The tilt angle is encoded as an int8, with 0 at 0 degrees, and each increment representing 0.5 degrees in either direction. A positive angle is upwards, and negative is downwards. \"\"\" tilt_angle_array = np.array( np.right_shift(np.bitwise_and(flags, 0x0000FF0000000000), 40), dtype=[(\"tilt_angle\", np.int8)], ).astype([(\"tilt_angle\", float)]) return tilt_angle_array[\"tilt_angle\"] / 2 def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def set_speed(self, speed: int): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * speed (int): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") self._parent_drone._verify_required_blunux_version(\"1.5\") # The tilt command is grouped together with the thruster commands, so to avoid messing with # the thruster setpoint while tilting we need to get the current setpoint and send it with # the tilt command. with self._parent_drone.motion.thruster_lock: thruster_setpoints = self._parent_drone.motion.current_thruster_setpoints.values() self._parent_drone._tcp_client.motion_input_tilt(*thruster_setpoints, 0, 0, speed) @property def angle(self) -> int: \"\"\"Return the current angle of the camera tilt Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") self._parent_drone._verify_required_blunux_version(\"1.5\") debug_flags = self._parent_drone._state_watcher.general_state[\"debug_flags\"] return self._tilt_angle_from_debug_flags(debug_flags) Instance variables angle Return the current angle of the camera tilt Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. Methods set_speed def set_speed ( self , speed : 'int' ) Set the speed and direction of the camera tilt Arguments : speed (int): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. View Source def set_speed(self, speed: int): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * speed (int): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") self._parent_drone._verify_required_blunux_version(\"1.5\") # The tilt command is grouped together with the thruster commands, so to avoid messing with # the thruster setpoint while tilting we need to get the current setpoint and send it with # the tilt command. with self._parent_drone.motion.thruster_lock: thruster_setpoints = self._parent_drone.motion.current_thruster_setpoints.values() self._parent_drone._tcp_client.motion_input_tilt(*thruster_setpoints, 0, 0, speed)","title":"Camera"},{"location":"reference/blueye/sdk/camera/#module-blueyesdkcamera","text":"View Source from __future__ import annotations import re import warnings from collections import namedtuple from enum import Enum from typing import TYPE_CHECKING, NamedTuple import numpy as np import requests # Necessary to avoid cyclic imports if TYPE_CHECKING: from .drone import Drone class Tilt: @staticmethod def _tilt_angle_from_debug_flags(flags: int) -> int: \"\"\"Helper function for decoding tilt angle from debug flags The tilt angle is encoded as an int8, with 0 at 0 degrees, and each increment representing 0.5 degrees in either direction. A positive angle is upwards, and negative is downwards. \"\"\" tilt_angle_array = np.array( np.right_shift(np.bitwise_and(flags, 0x0000FF0000000000), 40), dtype=[(\"tilt_angle\", np.int8)], ).astype([(\"tilt_angle\", float)]) return tilt_angle_array[\"tilt_angle\"] / 2 def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def set_speed(self, speed: int): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * speed (int): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") self._parent_drone._verify_required_blunux_version(\"1.5\") # The tilt command is grouped together with the thruster commands, so to avoid messing with # the thruster setpoint while tilting we need to get the current setpoint and send it with # the tilt command. with self._parent_drone.motion.thruster_lock: thruster_setpoints = self._parent_drone.motion.current_thruster_setpoints.values() self._parent_drone._tcp_client.motion_input_tilt(*thruster_setpoints, 0, 0, speed) @property def angle(self) -> int: \"\"\"Return the current angle of the camera tilt Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") self._parent_drone._verify_required_blunux_version(\"1.5\") debug_flags = self._parent_drone._state_watcher.general_state[\"debug_flags\"] return self._tilt_angle_from_debug_flags(debug_flags) class LogoOverlay(Enum): DISABLED = 0 BLUEYE = 1 CUSTOM = 2 class DepthUnitOverlay(Enum): METERS = 0 FEET = 1 class TemperatureUnitOverlay(Enum): CELSIUS = 0 FAHRENHEIT = 1 class FontSizeOverlay(Enum): PX15 = 15 PX20 = 20 PX25 = 25 PX30 = 30 PX35 = 35 PX40 = 40 class Overlay: \"\"\"Control the overlay on videos and pictures\"\"\" def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def _get_named_overlay_parameters(self) -> NamedTuple: \"\"\"Get overlay parameters from drone and convert them to a named tuple\"\"\" NamedParameters = namedtuple( \"Parameters\", [ \"returned_parameter\", \"temperature_enabled\", \"depth_enabled\", \"heading_enabled\", \"tilt_enabled\", \"date_enabled\", \"logo_index\", \"depth_unit\", \"temperature_unit\", \"tz_offset\", \"margin_width\", \"margin_height\", \"font_size\", \"title\", \"subtitle\", \"date_format\", ], ) parameters = self._parent_drone._tcp_client.get_overlay_parameters() return NamedParameters(*parameters) @property def temperature_enabled(self) -> bool: \"\"\"Get or set the state of the temperature overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().temperature_enabled) @temperature_enabled.setter def temperature_enabled(self, enable_temperature: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_temperature_enabled( 1 if enable_temperature else 0 ) @property def depth_enabled(self) -> bool: \"\"\"Get or set the state of the depth overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().depth_enabled) @depth_enabled.setter def depth_enabled(self, enable_depth: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_depth_enabled(1 if enable_depth else 0) @property def heading_enabled(self) -> bool: \"\"\"Get or set the state of the heading overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().heading_enabled) @heading_enabled.setter def heading_enabled(self, enable_heading: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_heading_enabled(1 if enable_heading else 0) @property def tilt_enabled(self) -> bool: \"\"\"Get or set the state of the tilt overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().tilt_enabled) @tilt_enabled.setter def tilt_enabled(self, enable_tilt: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_tilt_enabled(1 if enable_tilt else 0) @property def date_enabled(self) -> bool: \"\"\"Get or set the state of the date overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().date_enabled) @date_enabled.setter def date_enabled(self, enable_date: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_date_enabled(1 if enable_date else 0) @property def logo(self) -> LogoOverlay: \"\"\"Get or set logo overlay selection Needs to be set to an instance of the `LogoOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.8.72 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") return LogoOverlay(self._get_named_overlay_parameters().logo_index) @logo.setter def logo(self, logo_index: LogoOverlay): self._parent_drone._verify_required_blunux_version(\"1.8.72\") if not isinstance(logo_index, LogoOverlay): warnings.warn(\"Invalid logo index, ignoring\", RuntimeWarning) elif logo_index.value not in range(3): warnings.warn(\"Logo index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_logo_index(logo_index.value) @property def depth_unit(self) -> DepthUnitOverlay: \"\"\"Get or set the depth unit for the overlay Needs to be set to an instance of the `DepthUnitOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return DepthUnitOverlay(self._get_named_overlay_parameters().depth_unit) @depth_unit.setter def depth_unit(self, unit_index: DepthUnitOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(unit_index, DepthUnitOverlay): warnings.warn(\"Invalid depth unit index, ignoring\", RuntimeWarning) elif unit_index.value not in range(2): warnings.warn(\"Depth unit index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_depth_unit(unit_index.value) @property def temperature_unit(self) -> TemperatureUnitOverlay: \"\"\"Get or set the temperature unit for the overlay Needs to be set to an instance of the `TemperatureUnitOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return TemperatureUnitOverlay(self._get_named_overlay_parameters().temperature_unit) @temperature_unit.setter def temperature_unit(self, unit_index: TemperatureUnitOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(unit_index, TemperatureUnitOverlay): warnings.warn(\"Invalid temperature unit index, ignoring\", RuntimeWarning) elif unit_index.value not in range(2): warnings.warn(\"Temperature unit index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_temperature_unit(unit_index.value) @property def timezone_offset(self) -> int: \"\"\"Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().tz_offset @timezone_offset.setter def timezone_offset(self, offset: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_tz_offset(offset) @property def margin_width(self) -> int: \"\"\"Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().margin_width @margin_width.setter def margin_width(self, width: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if width < 0: warnings.warn(\"Invalid margin width, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_margin_width(width) @property def margin_height(self) -> int: \"\"\"Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().margin_height @margin_height.setter def margin_height(self, height: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if height < 0: warnings.warn(\"Invalid margin height, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_margin_height(height) @property def font_size(self) -> FontSizeOverlay: \"\"\"Get or set the font size for the overlay Needs to be an instance of the `FontSizeOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return FontSizeOverlay(self._get_named_overlay_parameters().font_size) @font_size.setter def font_size(self, size: FontSizeOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(size, FontSizeOverlay): warnings.warn(\"Invalid font size, ignoring\", RuntimeWarning) elif size.value not in range(15, 41): warnings.warn(\"Font size out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_font_size(size.value) @property def title(self) -> str: \"\"\"Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().title.decode(\"utf-8\").rstrip(\"\\x00\") @title.setter def title(self, input_title: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") new_title = input_title if len(input_title) > 63: warnings.warn(\"Too long title, truncating to 63 characters\", RuntimeWarning) new_title = new_title[:63] try: encoded_title = bytes(new_title, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Title can only contain ASCII characters, ignoring\", RuntimeWarning) return self._parent_drone._tcp_client.set_overlay_title(encoded_title + b\"\\x00\") @property def subtitle(self) -> str: \"\"\"Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().subtitle.decode(\"utf-8\").rstrip(\"\\x00\") @subtitle.setter def subtitle(self, input_subtitle: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") new_subtitle = input_subtitle if len(input_subtitle) > 63: warnings.warn(\"Too long subtitle, truncating to 63 characters\", RuntimeWarning) new_subtitle = new_subtitle[:63] try: encoded_subtitle = bytes(new_subtitle, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Subtitle can only contain ASCII characters, ignoring\", RuntimeWarning) return self._parent_drone._tcp_client.set_overlay_subtitle(encoded_subtitle + b\"\\x00\") @property def date_format(self) -> str: \"\"\"Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().date_format.decode(\"utf-8\").rstrip(\"\\x00\") @date_format.setter def date_format(self, input_format_str: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") format_str = input_format_str if len(format_str) > 63: warnings.warn( \"Too long date format string, truncating to 63 characters\", RuntimeWarning ) format_str = format_str[:63] try: encoded_format_str = bytes(format_str, \"ascii\") except UnicodeEncodeError: warnings.warn( \"Date format string can only contain ASCII characters, ignoring\", RuntimeWarning ) return self._parent_drone._tcp_client.set_overlay_date_format(encoded_format_str + b\"\\x00\") def upload_logo(self, path_to_logo: str): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `LogoOverlay.CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. Requires Blunux version 1.8.72 or newer. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=1) response.raise_for_status() def download_logo(self, output_directory=\".\"): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content) def delete_logo(self): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status() class Camera: def __init__(self, parent_drone: Drone): self._state_watcher = parent_drone._state_watcher self._parent_drone = parent_drone self.tilt = Tilt(parent_drone) self.overlay = Overlay(parent_drone) @property def is_recording(self) -> bool: \"\"\"Start or stop a camera recording *Arguments*: * is_recording (bool): Set to True to start a recording, set to False to stop the current recording *Returns*: * is_recording (bool): True if the camera is currently recording, False if not \"\"\" state = self._state_watcher.general_state if state[\"camera_record_time\"] != -1: return True else: return False @is_recording.setter def is_recording(self, start_recording: bool): if start_recording: self._parent_drone._tcp_client.start_recording() else: self._parent_drone._tcp_client.stop_recording() @property def bitrate(self) -> int: \"\"\"Set or get the camera bitrate *Arguments*: * bitrate (int): Set the camera bitrate in bits, Valid values are in range <1 000 000, 16 000 000> *Returns*: * bitrate (int): Get the camera bitrate \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() bitrate = camera_parameters[1] return bitrate @bitrate.setter def bitrate(self, bitrate: int): self._parent_drone._tcp_client.set_camera_bitrate(bitrate) @property def exposure(self) -> int: \"\"\"Set or get the camera exposure *Arguments*: * exposure (int): Set the camera exposure_value: 1 = 1/1000th of a second, 5 = 1/200th of a second. Valid values are in the range <1, 5000> *Returns*: * exposure (int): Get the camera exposure \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() exposure = camera_parameters[2] return exposure @exposure.setter def exposure(self, exposure: int): self._parent_drone._tcp_client.set_camera_exposure(exposure) @property def whitebalance(self) -> int: \"\"\"Set or get the camera white balance *Arguments*: * whitebalance (int): Set the camera white balance. Valid values are in the range <2800, 9300> *Returns*: * whitebalance (int): Get the camera white balance \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() whitebalance = camera_parameters[3] return whitebalance @whitebalance.setter def whitebalance(self, whitebalance: int): self._parent_drone._tcp_client.set_camera_whitebalance(whitebalance) @property def hue(self) -> int: \"\"\"Set or get the camera hue *Arguments*: * hue (int): Set the camera hue. Valid values are in the range <-40, 40> *Returns*: * hue (int): Get the camera hue \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() hue = camera_parameters[4] return hue @hue.setter def hue(self, hue: int): self._parent_drone._tcp_client.set_camera_hue(hue) @property def resolution(self) -> int: \"\"\"Set or get the camera resolution *Arguments*: * resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 *Returns*: * resolution (int): Get the camera resolution \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() resolution = camera_parameters[5] return resolution @resolution.setter def resolution(self, resolution: int): self._parent_drone._tcp_client.set_camera_resolution(resolution) @property def framerate(self) -> int: \"\"\"Set or get the camera frame rate *Arguments*: * framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 *Returns*: * framerate (int): Get the camera frame rate \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() framerate = camera_parameters[6] return framerate @framerate.setter def framerate(self, framerate: int): self._parent_drone._tcp_client.set_camera_framerate(framerate) @property def record_time(self) -> int: \"\"\"Set or get the duration of the current camera recording *Returns*: * record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording \"\"\" return self._state_watcher.general_state[\"camera_record_time\"] def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. This feature was added with drone version 1.4.7, so if you try to use it with an older version this method will raise a RunTimeError. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.4.7\") self._parent_drone._tcp_client.take_still_picture()","title":"Module blueye.sdk.camera"},{"location":"reference/blueye/sdk/camera/#variables","text":"TYPE_CHECKING","title":"Variables"},{"location":"reference/blueye/sdk/camera/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/camera/#camera","text":"class Camera ( parent_drone : 'Drone' ) View Source class Camera: def __init__(self, parent_drone: Drone): self._state_watcher = parent_drone._state_watcher self._parent_drone = parent_drone self.tilt = Tilt(parent_drone) self.overlay = Overlay(parent_drone) @property def is_recording(self) -> bool: \"\"\"Start or stop a camera recording *Arguments*: * is_recording (bool): Set to True to start a recording, set to False to stop the current recording *Returns*: * is_recording (bool): True if the camera is currently recording, False if not \"\"\" state = self._state_watcher.general_state if state[\"camera_record_time\"] != -1: return True else: return False @is_recording.setter def is_recording(self, start_recording: bool): if start_recording: self._parent_drone._tcp_client.start_recording() else: self._parent_drone._tcp_client.stop_recording() @property def bitrate(self) -> int: \"\"\"Set or get the camera bitrate *Arguments*: * bitrate (int): Set the camera bitrate in bits, Valid values are in range <1 000 000, 16 000 000> *Returns*: * bitrate (int): Get the camera bitrate \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() bitrate = camera_parameters[1] return bitrate @bitrate.setter def bitrate(self, bitrate: int): self._parent_drone._tcp_client.set_camera_bitrate(bitrate) @property def exposure(self) -> int: \"\"\"Set or get the camera exposure *Arguments*: * exposure (int): Set the camera exposure_value: 1 = 1/1000th of a second, 5 = 1/200th of a second. Valid values are in the range <1, 5000> *Returns*: * exposure (int): Get the camera exposure \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() exposure = camera_parameters[2] return exposure @exposure.setter def exposure(self, exposure: int): self._parent_drone._tcp_client.set_camera_exposure(exposure) @property def whitebalance(self) -> int: \"\"\"Set or get the camera white balance *Arguments*: * whitebalance (int): Set the camera white balance. Valid values are in the range <2800, 9300> *Returns*: * whitebalance (int): Get the camera white balance \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() whitebalance = camera_parameters[3] return whitebalance @whitebalance.setter def whitebalance(self, whitebalance: int): self._parent_drone._tcp_client.set_camera_whitebalance(whitebalance) @property def hue(self) -> int: \"\"\"Set or get the camera hue *Arguments*: * hue (int): Set the camera hue. Valid values are in the range <-40, 40> *Returns*: * hue (int): Get the camera hue \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() hue = camera_parameters[4] return hue @hue.setter def hue(self, hue: int): self._parent_drone._tcp_client.set_camera_hue(hue) @property def resolution(self) -> int: \"\"\"Set or get the camera resolution *Arguments*: * resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 *Returns*: * resolution (int): Get the camera resolution \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() resolution = camera_parameters[5] return resolution @resolution.setter def resolution(self, resolution: int): self._parent_drone._tcp_client.set_camera_resolution(resolution) @property def framerate(self) -> int: \"\"\"Set or get the camera frame rate *Arguments*: * framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 *Returns*: * framerate (int): Get the camera frame rate \"\"\" camera_parameters = self._parent_drone._tcp_client.get_camera_parameters() framerate = camera_parameters[6] return framerate @framerate.setter def framerate(self, framerate: int): self._parent_drone._tcp_client.set_camera_framerate(framerate) @property def record_time(self) -> int: \"\"\"Set or get the duration of the current camera recording *Returns*: * record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording \"\"\" return self._state_watcher.general_state[\"camera_record_time\"] def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. This feature was added with drone version 1.4.7, so if you try to use it with an older version this method will raise a RunTimeError. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.4.7\") self._parent_drone._tcp_client.take_still_picture()","title":"Camera"},{"location":"reference/blueye/sdk/camera/#instance-variables","text":"bitrate Set or get the camera bitrate Arguments : bitrate (int): Set the camera bitrate in bits, Valid values are in range <1 000 000, 16 000 000> Returns : bitrate (int): Get the camera bitrate exposure Set or get the camera exposure Arguments : exposure (int): Set the camera exposure_value: 1 = 1/1000 th of a second, 5 = 1/200 th of a second. Valid values are in the range <1, 5000> Returns : exposure (int): Get the camera exposure framerate Set or get the camera frame rate Arguments : framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30 Returns : framerate (int): Get the camera frame rate hue Set or get the camera hue Arguments : hue (int): Set the camera hue. Valid values are in the range <-40, 40> Returns : hue (int): Get the camera hue is_recording Start or stop a camera recording Arguments : is_recording (bool): Set to True to start a recording, set to False to stop the current recording Returns : is_recording (bool): True if the camera is currently recording, False if not record_time Set or get the duration of the current camera recording Returns : record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording resolution Set or get the camera resolution Arguments : resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080 Returns : resolution (int): Get the camera resolution whitebalance Set or get the camera white balance Arguments : whitebalance (int): Set the camera white balance. Valid values are in the range <2800, 9300> Returns : whitebalance (int): Get the camera white balance","title":"Instance variables"},{"location":"reference/blueye/sdk/camera/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/camera/#take_picture","text":"def take_picture ( self ) Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. This feature was added with drone version 1.4.7, so if you try to use it with an older version this method will raise a RunTimeError. View Source def take_picture(self): \"\"\"Takes a still picture and stores it locally on the drone These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client. This feature was added with drone version 1.4.7, so if you try to use it with an older version this method will raise a RunTimeError. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.4.7\") self._parent_drone._tcp_client.take_still_picture()","title":"take_picture"},{"location":"reference/blueye/sdk/camera/#depthunitoverlay","text":"class DepthUnitOverlay ( / , * args , ** kwargs ) An enumeration. View Source class DepthUnitOverlay(Enum): METERS = 0 FEET = 1","title":"DepthUnitOverlay"},{"location":"reference/blueye/sdk/camera/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/camera/#class-variables","text":"FEET METERS name value","title":"Class variables"},{"location":"reference/blueye/sdk/camera/#fontsizeoverlay","text":"class FontSizeOverlay ( / , * args , ** kwargs ) An enumeration. View Source class FontSizeOverlay(Enum): PX15 = 15 PX20 = 20 PX25 = 25 PX30 = 30 PX35 = 35 PX40 = 40","title":"FontSizeOverlay"},{"location":"reference/blueye/sdk/camera/#ancestors-in-mro_1","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/camera/#class-variables_1","text":"PX15 PX20 PX25 PX30 PX35 PX40 name value","title":"Class variables"},{"location":"reference/blueye/sdk/camera/#logooverlay","text":"class LogoOverlay ( / , * args , ** kwargs ) An enumeration. View Source class LogoOverlay(Enum): DISABLED = 0 BLUEYE = 1 CUSTOM = 2","title":"LogoOverlay"},{"location":"reference/blueye/sdk/camera/#ancestors-in-mro_2","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/camera/#class-variables_2","text":"BLUEYE CUSTOM DISABLED name value","title":"Class variables"},{"location":"reference/blueye/sdk/camera/#overlay","text":"class Overlay ( parent_drone : 'Drone' ) Control the overlay on videos and pictures View Source class Overlay: \"\"\"Control the overlay on videos and pictures\"\"\" def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def _get_named_overlay_parameters(self) -> NamedTuple: \"\"\"Get overlay parameters from drone and convert them to a named tuple\"\"\" NamedParameters = namedtuple( \"Parameters\", [ \"returned_parameter\", \"temperature_enabled\", \"depth_enabled\", \"heading_enabled\", \"tilt_enabled\", \"date_enabled\", \"logo_index\", \"depth_unit\", \"temperature_unit\", \"tz_offset\", \"margin_width\", \"margin_height\", \"font_size\", \"title\", \"subtitle\", \"date_format\", ], ) parameters = self._parent_drone._tcp_client.get_overlay_parameters() return NamedParameters(*parameters) @property def temperature_enabled(self) -> bool: \"\"\"Get or set the state of the temperature overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().temperature_enabled) @temperature_enabled.setter def temperature_enabled(self, enable_temperature: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_temperature_enabled( 1 if enable_temperature else 0 ) @property def depth_enabled(self) -> bool: \"\"\"Get or set the state of the depth overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().depth_enabled) @depth_enabled.setter def depth_enabled(self, enable_depth: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_depth_enabled(1 if enable_depth else 0) @property def heading_enabled(self) -> bool: \"\"\"Get or set the state of the heading overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().heading_enabled) @heading_enabled.setter def heading_enabled(self, enable_heading: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_heading_enabled(1 if enable_heading else 0) @property def tilt_enabled(self) -> bool: \"\"\"Get or set the state of the tilt overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().tilt_enabled) @tilt_enabled.setter def tilt_enabled(self, enable_tilt: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_tilt_enabled(1 if enable_tilt else 0) @property def date_enabled(self) -> bool: \"\"\"Get or set the state of the date overlay Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return bool(self._get_named_overlay_parameters().date_enabled) @date_enabled.setter def date_enabled(self, enable_date: bool): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_date_enabled(1 if enable_date else 0) @property def logo(self) -> LogoOverlay: \"\"\"Get or set logo overlay selection Needs to be set to an instance of the `LogoOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.8.72 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") return LogoOverlay(self._get_named_overlay_parameters().logo_index) @logo.setter def logo(self, logo_index: LogoOverlay): self._parent_drone._verify_required_blunux_version(\"1.8.72\") if not isinstance(logo_index, LogoOverlay): warnings.warn(\"Invalid logo index, ignoring\", RuntimeWarning) elif logo_index.value not in range(3): warnings.warn(\"Logo index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_logo_index(logo_index.value) @property def depth_unit(self) -> DepthUnitOverlay: \"\"\"Get or set the depth unit for the overlay Needs to be set to an instance of the `DepthUnitOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return DepthUnitOverlay(self._get_named_overlay_parameters().depth_unit) @depth_unit.setter def depth_unit(self, unit_index: DepthUnitOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(unit_index, DepthUnitOverlay): warnings.warn(\"Invalid depth unit index, ignoring\", RuntimeWarning) elif unit_index.value not in range(2): warnings.warn(\"Depth unit index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_depth_unit(unit_index.value) @property def temperature_unit(self) -> TemperatureUnitOverlay: \"\"\"Get or set the temperature unit for the overlay Needs to be set to an instance of the `TemperatureUnitOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return TemperatureUnitOverlay(self._get_named_overlay_parameters().temperature_unit) @temperature_unit.setter def temperature_unit(self, unit_index: TemperatureUnitOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(unit_index, TemperatureUnitOverlay): warnings.warn(\"Invalid temperature unit index, ignoring\", RuntimeWarning) elif unit_index.value not in range(2): warnings.warn(\"Temperature unit index out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_temperature_unit(unit_index.value) @property def timezone_offset(self) -> int: \"\"\"Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().tz_offset @timezone_offset.setter def timezone_offset(self, offset: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") self._parent_drone._tcp_client.set_overlay_tz_offset(offset) @property def margin_width(self) -> int: \"\"\"Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().margin_width @margin_width.setter def margin_width(self, width: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if width < 0: warnings.warn(\"Invalid margin width, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_margin_width(width) @property def margin_height(self) -> int: \"\"\"Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().margin_height @margin_height.setter def margin_height(self, height: int): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if height < 0: warnings.warn(\"Invalid margin height, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_margin_height(height) @property def font_size(self) -> FontSizeOverlay: \"\"\"Get or set the font size for the overlay Needs to be an instance of the `FontSizeOverlay` class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return FontSizeOverlay(self._get_named_overlay_parameters().font_size) @font_size.setter def font_size(self, size: FontSizeOverlay): self._parent_drone._verify_required_blunux_version(\"1.7.60\") if not isinstance(size, FontSizeOverlay): warnings.warn(\"Invalid font size, ignoring\", RuntimeWarning) elif size.value not in range(15, 41): warnings.warn(\"Font size out of range, ignoring\", RuntimeWarning) else: self._parent_drone._tcp_client.set_overlay_font_size(size.value) @property def title(self) -> str: \"\"\"Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().title.decode(\"utf-8\").rstrip(\"\\x00\") @title.setter def title(self, input_title: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") new_title = input_title if len(input_title) > 63: warnings.warn(\"Too long title, truncating to 63 characters\", RuntimeWarning) new_title = new_title[:63] try: encoded_title = bytes(new_title, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Title can only contain ASCII characters, ignoring\", RuntimeWarning) return self._parent_drone._tcp_client.set_overlay_title(encoded_title + b\"\\x00\") @property def subtitle(self) -> str: \"\"\"Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. Requires Blunux version 1.7.60 or newer. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().subtitle.decode(\"utf-8\").rstrip(\"\\x00\") @subtitle.setter def subtitle(self, input_subtitle: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") new_subtitle = input_subtitle if len(input_subtitle) > 63: warnings.warn(\"Too long subtitle, truncating to 63 characters\", RuntimeWarning) new_subtitle = new_subtitle[:63] try: encoded_subtitle = bytes(new_subtitle, \"ascii\") except UnicodeEncodeError: warnings.warn(\"Subtitle can only contain ASCII characters, ignoring\", RuntimeWarning) return self._parent_drone._tcp_client.set_overlay_subtitle(encoded_subtitle + b\"\\x00\") @property def date_format(self) -> str: \"\"\"Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. \"\"\" self._parent_drone._verify_required_blunux_version(\"1.7.60\") return self._get_named_overlay_parameters().date_format.decode(\"utf-8\").rstrip(\"\\x00\") @date_format.setter def date_format(self, input_format_str: str): self._parent_drone._verify_required_blunux_version(\"1.7.60\") format_str = input_format_str if len(format_str) > 63: warnings.warn( \"Too long date format string, truncating to 63 characters\", RuntimeWarning ) format_str = format_str[:63] try: encoded_format_str = bytes(format_str, \"ascii\") except UnicodeEncodeError: warnings.warn( \"Date format string can only contain ASCII characters, ignoring\", RuntimeWarning ) return self._parent_drone._tcp_client.set_overlay_date_format(encoded_format_str + b\"\\x00\") def upload_logo(self, path_to_logo: str): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `LogoOverlay.CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. Requires Blunux version 1.8.72 or newer. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=1) response.raise_for_status() def download_logo(self, output_directory=\".\"): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content) def delete_logo(self): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status()","title":"Overlay"},{"location":"reference/blueye/sdk/camera/#instance-variables_1","text":"date_enabled Get or set the state of the date overlay Requires Blunux version 1.7.60 or newer. date_format Get or set the format string for the time displayed in the overlay Must be a string containing only ASCII characters, with a max length of 63 characters. The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes. depth_enabled Get or set the state of the depth overlay Requires Blunux version 1.7.60 or newer. depth_unit Get or set the depth unit for the overlay Needs to be set to an instance of the DepthUnitOverlay class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. font_size Get or set the font size for the overlay Needs to be an instance of the FontSizeOverlay class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. heading_enabled Get or set the state of the heading overlay Requires Blunux version 1.7.60 or newer. logo Get or set logo overlay selection Needs to be set to an instance of the LogoOverlay class, if not a RuntimeWarning is raised. Requires Blunux version 1.8.72 or newer. margin_height Get or set the margin height for the overlay The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. margin_width Get or set the margin width for the overlay The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer. Requires Blunux version 1.7.60 or newer. subtitle Get or set the subtitle for the overlay The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable the subtitle. Requires Blunux version 1.7.60 or newer. temperature_enabled Get or set the state of the temperature overlay Requires Blunux version 1.7.60 or newer. temperature_unit Get or set the temperature unit for the overlay Needs to be set to an instance of the TemperatureUnitOverlay class, if not a RuntimeWarning is raised. Requires Blunux version 1.7.60 or newer. tilt_enabled Get or set the state of the tilt overlay Requires Blunux version 1.7.60 or newer. timezone_offset Get or set the timezone offset for the overlay Set to the number of minutes (either positive or negative) the timestamp should be offset. Requires Blunux version 1.7.60 or newer. title Get or set the title for the overlay The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised. Set to an empty string to disable title. Requires Blunux version 1.7.60 or newer.","title":"Instance variables"},{"location":"reference/blueye/sdk/camera/#methods_1","text":"","title":"Methods"},{"location":"reference/blueye/sdk/camera/#delete_logo","text":"def delete_logo ( self ) Delete the user uploaded logo from the drone Exceptions : requests.exceptions.HTTPError : If an error occurs during deletion requests.exceptions.ConnectTimeout : If unable to create a connection within 1s View Source def delete_logo(self): \"\"\"Delete the user uploaded logo from the drone *Exceptions*: * `requests.exceptions.HTTPError` : If an error occurs during deletion * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status()","title":"delete_logo"},{"location":"reference/blueye/sdk/camera/#download_logo","text":"def download_logo ( self , output_directory = '.' ) Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. Exceptions : requests.exceptions.HTTPError : If no custom logo is uploaded. requests.exceptions.ConnectTimeout : If unable to create a connection within 1s View Source def download_logo(self, output_directory=\".\"): \"\"\"Download the original user uploaded logo (PNG or JPG) Select the download directory with the output_directory parameter. *Exceptions*: * `requests.exceptions.HTTPError` : If no custom logo is uploaded. * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=1) response.raise_for_status() filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0] with open(f\"{output_directory}/{filename}\", \"wb\") as f: f.write(response.content)","title":"download_logo"},{"location":"reference/blueye/sdk/camera/#upload_logo","text":"def upload_logo ( self , path_to_logo : 'str' ) Upload user selectable logo for watermarking videos and pictures Set the logo-property to LogoOverlay.CUSTOM to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. Requires Blunux version 1.8.72 or newer. Exceptions : requests.exceptions.HTTPError : Status code 400 for invalid files requests.exceptions.ConnectTimeout : If unable to create a connection within 1s View Source def upload_logo(self, path_to_logo: str): \"\"\"Upload user selectable logo for watermarking videos and pictures Set the logo-property to `LogoOverlay.CUSTOM` to enable this logo. Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB. Requires Blunux version 1.8.72 or newer. *Exceptions*: * `requests.exceptions.HTTPError` : Status code 400 for invalid files * `requests.exceptions.ConnectTimeout` : If unable to create a connection within 1s \"\"\" self._parent_drone._verify_required_blunux_version(\"1.8.72\") with open(path_to_logo, \"rb\") as f: url = f\"http://{self._parent_drone._ip}/asset/logo\" files = {\"image\": f} response = requests.post(url, files=files, timeout=1) response.raise_for_status()","title":"upload_logo"},{"location":"reference/blueye/sdk/camera/#temperatureunitoverlay","text":"class TemperatureUnitOverlay ( / , * args , ** kwargs ) An enumeration. View Source class TemperatureUnitOverlay(Enum): CELSIUS = 0 FAHRENHEIT = 1","title":"TemperatureUnitOverlay"},{"location":"reference/blueye/sdk/camera/#ancestors-in-mro_3","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/camera/#class-variables_3","text":"CELSIUS FAHRENHEIT name value","title":"Class variables"},{"location":"reference/blueye/sdk/camera/#tilt","text":"class Tilt ( parent_drone : 'Drone' ) View Source class Tilt: @staticmethod def _tilt_angle_from_debug_flags(flags: int) -> int: \"\"\"Helper function for decoding tilt angle from debug flags The tilt angle is encoded as an int8, with 0 at 0 degrees, and each increment representing 0.5 degrees in either direction. A positive angle is upwards, and negative is downwards. \"\"\" tilt_angle_array = np.array( np.right_shift(np.bitwise_and(flags, 0x0000FF0000000000), 40), dtype=[(\"tilt_angle\", np.int8)], ).astype([(\"tilt_angle\", float)]) return tilt_angle_array[\"tilt_angle\"] / 2 def __init__(self, parent_drone: Drone): self._parent_drone = parent_drone def set_speed(self, speed: int): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * speed (int): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") self._parent_drone._verify_required_blunux_version(\"1.5\") # The tilt command is grouped together with the thruster commands, so to avoid messing with # the thruster setpoint while tilting we need to get the current setpoint and send it with # the tilt command. with self._parent_drone.motion.thruster_lock: thruster_setpoints = self._parent_drone.motion.current_thruster_setpoints.values() self._parent_drone._tcp_client.motion_input_tilt(*thruster_setpoints, 0, 0, speed) @property def angle(self) -> int: \"\"\"Return the current angle of the camera tilt Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") self._parent_drone._verify_required_blunux_version(\"1.5\") debug_flags = self._parent_drone._state_watcher.general_state[\"debug_flags\"] return self._tilt_angle_from_debug_flags(debug_flags)","title":"Tilt"},{"location":"reference/blueye/sdk/camera/#instance-variables_2","text":"angle Return the current angle of the camera tilt Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met.","title":"Instance variables"},{"location":"reference/blueye/sdk/camera/#methods_2","text":"","title":"Methods"},{"location":"reference/blueye/sdk/camera/#set_speed","text":"def set_speed ( self , speed : 'int' ) Set the speed and direction of the camera tilt Arguments : speed (int): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. View Source def set_speed(self, speed: int): \"\"\"Set the speed and direction of the camera tilt *Arguments*: * speed (int): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down. Requires a drone with the tilt feature, and software version 1.5 or newer. A RuntimeError is raised if either of those requirements are not met. \"\"\" if \"tilt\" not in self._parent_drone.features: raise RuntimeError(\"The connected drone does not support tilting the camera.\") self._parent_drone._verify_required_blunux_version(\"1.5\") # The tilt command is grouped together with the thruster commands, so to avoid messing with # the thruster setpoint while tilting we need to get the current setpoint and send it with # the tilt command. with self._parent_drone.motion.thruster_lock: thruster_setpoints = self._parent_drone.motion.current_thruster_setpoints.values() self._parent_drone._tcp_client.motion_input_tilt(*thruster_setpoints, 0, 0, speed)","title":"set_speed"},{"location":"reference/blueye/sdk/constants/","text":"Module blueye.sdk.constants This file contains constants used by the SDK. View Source \"\"\" This file contains constants used by the SDK. \"\"\" class WaterDensities: \"\"\" Various typical densities for salt water (in grams/liter) \"\"\" fresh = 997 brackish = 1011 salty = 1025 Classes WaterDensities class WaterDensities ( / , * args , ** kwargs ) Various typical densities for salt water (in grams/liter) View Source class WaterDensities: \"\"\" Various typical densities for salt water (in grams/liter) \"\"\" fresh = 997 brackish = 1011 salty = 1025 Class variables brackish fresh salty","title":"Constants"},{"location":"reference/blueye/sdk/constants/#module-blueyesdkconstants","text":"This file contains constants used by the SDK. View Source \"\"\" This file contains constants used by the SDK. \"\"\" class WaterDensities: \"\"\" Various typical densities for salt water (in grams/liter) \"\"\" fresh = 997 brackish = 1011 salty = 1025","title":"Module blueye.sdk.constants"},{"location":"reference/blueye/sdk/constants/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/constants/#waterdensities","text":"class WaterDensities ( / , * args , ** kwargs ) Various typical densities for salt water (in grams/liter) View Source class WaterDensities: \"\"\" Various typical densities for salt water (in grams/liter) \"\"\" fresh = 997 brackish = 1011 salty = 1025","title":"WaterDensities"},{"location":"reference/blueye/sdk/constants/#class-variables","text":"brackish fresh salty","title":"Class variables"},{"location":"reference/blueye/sdk/drone/","text":"Module blueye.sdk.drone View Source #!/usr/bin/env python3 import socket import threading import time import warnings from json import JSONDecodeError import requests from blueye.protocol import TcpClient, UdpClient from blueye.protocol.exceptions import MismatchedReply, NoConnectionToDrone, ResponseTimeout from packaging import version from .camera import Camera from .constants import WaterDensities from .logs import Logs from .motion import Motion class _DroneStateWatcher(threading.Thread): \"\"\"Subscribes to UDP messages from the drone and stores the latest data\"\"\" def __init__(self, ip: str = \"192.168.1.101\", udp_timeout: float = 3): threading.Thread.__init__(self) self._ip = ip self._udp_timeout = udp_timeout self._general_state = None self._general_state_received = threading.Event() self._calibration_state = None self._calibration_state_received = threading.Event() self._udp_client = UdpClient(drone_ip=self._ip) self._exit_flag = threading.Event() self.daemon = True @property def general_state(self) -> dict: if not self._general_state_received.wait(timeout=self._udp_timeout): raise TimeoutError(\"No state message received from drone\") return self._general_state @property def calibration_state(self) -> dict: if not self._calibration_state_received.wait(timeout=self._udp_timeout): raise TimeoutError(\"No state message received from drone\") return self._calibration_state def run(self): while not self._exit_flag.is_set(): data_packet = self._udp_client.get_data_dict() if data_packet[\"command_type\"] == 1: self._general_state = data_packet self._general_state_received.set() elif data_packet[\"command_type\"] == 2: self._calibration_state = data_packet self._calibration_state_received.set() def stop(self): self._exit_flag.set() class SlaveModeWarning(UserWarning): \"\"\"Raised when trying to perform action not possible in slave mode\"\"\" class _SlaveTcpClient: \"\"\"A dummy TCP client that warns you if you use any of its functions\"\"\" def __getattr__(self, name): def method(*args): warnings.warn( f\"Unable to call {name}{args} with client in slave mode\", SlaveModeWarning, stacklevel=2, ) return method class _NoConnectionTcpClient: \"\"\"A TCP client that raises a ConnectionError if you use any of its functions\"\"\" def __getattr__(self, name): def method(*args, **kwargs): raise ConnectionError( \"The connection to the drone is not established, \" \"try calling the connect method before retrying\" ) return method class Config: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone self._water_density = WaterDensities.salty @property def water_density(self): \"\"\"Get or set the current water density for increased pressure sensor accuracy Setting the water density is only supported on drones with software version 1.5 or higher. Older software versions will assume a water density of 1025 grams per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses). \"\"\" return self._water_density @water_density.setter def water_density(self, density: int): self._parent_drone._verify_required_blunux_version(\"1.5\") self._water_density = density self._parent_drone._tcp_client.set_water_density(density) def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._tcp_client.set_system_time(time) class Drone: \"\"\"A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting `autoConnect=False`. The drone only supports one client controlling it at a time, but if you pass `slaveModeEnabled=True` you will still be able to receive data from the drone. \"\"\" def __init__( self, ip=\"192.168.1.101\", tcpPort=2011, autoConnect=True, slaveModeEnabled=False, udpTimeout=3, ): self._ip = ip self._port = tcpPort self._slave_mode_enabled = slaveModeEnabled if slaveModeEnabled: self._tcp_client = _SlaveTcpClient() else: self._tcp_client = _NoConnectionTcpClient() self._state_watcher = _DroneStateWatcher(ip=self._ip, udp_timeout=udpTimeout) self.camera = Camera(self) self.motion = Motion(self) self.logs = Logs(self) self.config = Config(self) if autoConnect is True: self.connect(timeout=3) def _verify_required_blunux_version(self, requirement: str): \"\"\"Verify that Blunux version is higher than requirement requirement needs to be a string that's able to be parsed by version.parse() Raises a RuntimeError if the Blunux version of the connected drone does not match or exceed the requirement. \"\"\" if not self.connection_established: raise ConnectionError( \"The connection to the drone is not established, try calling the connect method \" \"before retrying\" ) if version.parse(self.software_version_short) < version.parse(requirement): raise RuntimeError( f\"Blunux version of connected drone is {self.software_version_short}. Version \" f\"{requirement} or higher is required.\" ) @property def connection_established(self): if isinstance(self._tcp_client, _NoConnectionTcpClient): return False else: return True def _update_drone_info(self): \"\"\"Request and store information about the connected drone\"\"\" try: response = requests.get(f\"http://{self._ip}/diagnostics/drone_info\", timeout=3).json() except ( requests.ConnectTimeout, requests.ReadTimeout, requests.ConnectionError, JSONDecodeError, ): raise ConnectionError(\"Could not establish connection with drone\") try: self.features = list(filter(None, response[\"features\"].split(\",\"))) except KeyError: # Drone versions older than 1.4.7 did not have this field. self.features = [] self.software_version = response[\"sw_version\"] self.software_version_short = self.software_version.split(\"-\")[0] self.serial_number = response[\"serial_number\"] self.uuid = response[\"hardware_id\"] @staticmethod def _wait_for_udp_communication(timeout: float, ip: str = \"192.168.1.101\"): \"\"\"Simple helper for waiting for drone to come online Raises ConnectionError if no connection is established in the specified timeout. \"\"\" temp_udp_client = UdpClient(drone_ip=ip) temp_udp_client._sock.settimeout(timeout) try: temp_udp_client.get_data_dict() except socket.timeout as e: raise ConnectionError(\"Could not establish connection with drone\") from e def _connect_to_tcp_socket(self): try: self._tcp_client.connect() except NoConnectionToDrone: raise ConnectionError(\"Could not establish connection with drone\") def _start_watchdog(self): \"\"\"Starts the thread for petting the watchdog _connect_to_tcp_socket() must be called first\"\"\" try: self._tcp_client.start() except RuntimeError: # Ignore multiple starts pass def _clean_up_tcp_client(self): \"\"\"Stops the watchdog thread and closes the TCP socket\"\"\" self._tcp_client.stop() self._tcp_client._sock.close() self._tcp_client = _NoConnectionTcpClient() def _start_state_watcher_thread(self): try: self._state_watcher.start() except RuntimeError: # Ignore multiple starts pass def connect(self, timeout: float = None): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. - *timeout* (float): Seconds to wait for connection \"\"\" self._wait_for_udp_communication(timeout, self._ip) self._update_drone_info() self._start_state_watcher_thread() if self._slave_mode_enabled: # No need to touch the TCP stuff if we're in slave mode so we return early return if not self.connection_established: self._tcp_client = TcpClient(ip=self._ip, port=self._port, autoConnect=False) self._connect_to_tcp_socket() try: self.ping() self.motion.send_thruster_setpoint(0, 0, 0, 0) # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time self.config.set_drone_time(int(time.time())) self._start_watchdog() except ResponseTimeout as e: self._clean_up_tcp_client() raise ConnectionError( f\"Found drone at {self._ip} but was unable to take control of it. \" \"Is there another client connected?\" ) from e except MismatchedReply: # The connection is out of sync, likely due to a previous connection being # disconnected mid-transfer. Re-instantiating the connection should solve the issue self._clean_up_tcp_client() self.connect(timeout) except BrokenPipeError: # Have lost connection to drone, need to reestablish TCP client self._clean_up_tcp_client() self.connect(timeout) def disconnect(self): \"\"\"Disconnects the TCP connection, allowing another client to take control of the drone\"\"\" if self.connection_established and not self._slave_mode_enabled: self._clean_up_tcp_client() @property def lights(self) -> int: \"\"\"Get or set the brightness of the bottom canister lights *Arguments*: * brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> *Returns*: * brightness (int): The brightness of the bottom canister LED's in the range <0, 255> \"\"\" state = self._state_watcher.general_state return state[\"lights_upper\"] @lights.setter def lights(self, brightness: int): try: self._tcp_client.set_lights(brightness, 0) except ValueError as e: raise ValueError(\"Error occured while trying to set lights to: \" f\"{brightness}\") from e @property def depth(self) -> int: \"\"\"Get the current depth in millimeters *Returns*: * depth (int): The depth in millimeters of water column. \"\"\" return self._state_watcher.general_state[\"depth\"] @property def pose(self) -> dict: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" pose = { \"roll\": (self._state_watcher.general_state[\"roll\"] + 360) % 360, \"pitch\": (self._state_watcher.general_state[\"pitch\"] + 360) % 360, \"yaw\": (self._state_watcher.general_state[\"yaw\"] + 360) % 360, } return pose @property def battery_state_of_charge(self) -> int: \"\"\"Get the battery state of charge *Returns*: * state_of_charge (int): Current state of charge of the drone battery in percent, from 0 to 100 \"\"\" return self._state_watcher.general_state[\"battery_state_of_charge_rel\"] @property def error_flags(self) -> int: \"\"\"Get the error flags *Returns*: * error_flags (int): The error flags as int \"\"\" return self._state_watcher.general_state[\"error_flags\"] def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping() class Pioneer(Drone): def __init__(self, *args, **kwargs): warnings.warn( \"This class has been deprecated and will be removed in the next major version, \" \"please use the Drone class instead.\", DeprecationWarning, stacklevel=2, ) super().__init__(*args, **kwargs) Classes Config class Config ( parent_drone : 'Drone' ) View Source class Config: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone self._water_density = WaterDensities.salty @property def water_density(self): \"\"\"Get or set the current water density for increased pressure sensor accuracy Setting the water density is only supported on drones with software version 1.5 or higher. Older software versions will assume a water density of 1025 grams per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses). \"\"\" return self._water_density @water_density.setter def water_density(self, density: int): self._parent_drone._verify_required_blunux_version(\"1.5\") self._water_density = density self._parent_drone._tcp_client.set_water_density(density) def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._tcp_client.set_system_time(time) Instance variables water_density Get or set the current water density for increased pressure sensor accuracy Setting the water density is only supported on drones with software version 1.5 or higher. Older software versions will assume a water density of 1025 grams per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses). Methods set_drone_time def set_drone_time ( self , time : int ) Set the system for the drone This method is used to set the system time for the drone. The argument time is expected to be a Unix timestamp (ie. the number of seconds since the epoch). View Source def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._tcp_client.set_system_time(time) Drone class Drone ( ip = '192.168.1.101' , tcpPort = 2011 , autoConnect = True , slaveModeEnabled = False , udpTimeout = 3 ) A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting autoConnect=False . The drone only supports one client controlling it at a time, but if you pass slaveModeEnabled=True you will still be able to receive data from the drone. View Source class Drone: \"\"\"A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting `autoConnect=False`. The drone only supports one client controlling it at a time, but if you pass `slaveModeEnabled=True` you will still be able to receive data from the drone. \"\"\" def __init__( self, ip=\"192.168.1.101\", tcpPort=2011, autoConnect=True, slaveModeEnabled=False, udpTimeout=3, ): self._ip = ip self._port = tcpPort self._slave_mode_enabled = slaveModeEnabled if slaveModeEnabled: self._tcp_client = _SlaveTcpClient() else: self._tcp_client = _NoConnectionTcpClient() self._state_watcher = _DroneStateWatcher(ip=self._ip, udp_timeout=udpTimeout) self.camera = Camera(self) self.motion = Motion(self) self.logs = Logs(self) self.config = Config(self) if autoConnect is True: self.connect(timeout=3) def _verify_required_blunux_version(self, requirement: str): \"\"\"Verify that Blunux version is higher than requirement requirement needs to be a string that's able to be parsed by version.parse() Raises a RuntimeError if the Blunux version of the connected drone does not match or exceed the requirement. \"\"\" if not self.connection_established: raise ConnectionError( \"The connection to the drone is not established, try calling the connect method \" \"before retrying\" ) if version.parse(self.software_version_short) < version.parse(requirement): raise RuntimeError( f\"Blunux version of connected drone is {self.software_version_short}. Version \" f\"{requirement} or higher is required.\" ) @property def connection_established(self): if isinstance(self._tcp_client, _NoConnectionTcpClient): return False else: return True def _update_drone_info(self): \"\"\"Request and store information about the connected drone\"\"\" try: response = requests.get(f\"http://{self._ip}/diagnostics/drone_info\", timeout=3).json() except ( requests.ConnectTimeout, requests.ReadTimeout, requests.ConnectionError, JSONDecodeError, ): raise ConnectionError(\"Could not establish connection with drone\") try: self.features = list(filter(None, response[\"features\"].split(\",\"))) except KeyError: # Drone versions older than 1.4.7 did not have this field. self.features = [] self.software_version = response[\"sw_version\"] self.software_version_short = self.software_version.split(\"-\")[0] self.serial_number = response[\"serial_number\"] self.uuid = response[\"hardware_id\"] @staticmethod def _wait_for_udp_communication(timeout: float, ip: str = \"192.168.1.101\"): \"\"\"Simple helper for waiting for drone to come online Raises ConnectionError if no connection is established in the specified timeout. \"\"\" temp_udp_client = UdpClient(drone_ip=ip) temp_udp_client._sock.settimeout(timeout) try: temp_udp_client.get_data_dict() except socket.timeout as e: raise ConnectionError(\"Could not establish connection with drone\") from e def _connect_to_tcp_socket(self): try: self._tcp_client.connect() except NoConnectionToDrone: raise ConnectionError(\"Could not establish connection with drone\") def _start_watchdog(self): \"\"\"Starts the thread for petting the watchdog _connect_to_tcp_socket() must be called first\"\"\" try: self._tcp_client.start() except RuntimeError: # Ignore multiple starts pass def _clean_up_tcp_client(self): \"\"\"Stops the watchdog thread and closes the TCP socket\"\"\" self._tcp_client.stop() self._tcp_client._sock.close() self._tcp_client = _NoConnectionTcpClient() def _start_state_watcher_thread(self): try: self._state_watcher.start() except RuntimeError: # Ignore multiple starts pass def connect(self, timeout: float = None): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. - *timeout* (float): Seconds to wait for connection \"\"\" self._wait_for_udp_communication(timeout, self._ip) self._update_drone_info() self._start_state_watcher_thread() if self._slave_mode_enabled: # No need to touch the TCP stuff if we're in slave mode so we return early return if not self.connection_established: self._tcp_client = TcpClient(ip=self._ip, port=self._port, autoConnect=False) self._connect_to_tcp_socket() try: self.ping() self.motion.send_thruster_setpoint(0, 0, 0, 0) # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time self.config.set_drone_time(int(time.time())) self._start_watchdog() except ResponseTimeout as e: self._clean_up_tcp_client() raise ConnectionError( f\"Found drone at {self._ip} but was unable to take control of it. \" \"Is there another client connected?\" ) from e except MismatchedReply: # The connection is out of sync, likely due to a previous connection being # disconnected mid-transfer. Re-instantiating the connection should solve the issue self._clean_up_tcp_client() self.connect(timeout) except BrokenPipeError: # Have lost connection to drone, need to reestablish TCP client self._clean_up_tcp_client() self.connect(timeout) def disconnect(self): \"\"\"Disconnects the TCP connection, allowing another client to take control of the drone\"\"\" if self.connection_established and not self._slave_mode_enabled: self._clean_up_tcp_client() @property def lights(self) -> int: \"\"\"Get or set the brightness of the bottom canister lights *Arguments*: * brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> *Returns*: * brightness (int): The brightness of the bottom canister LED's in the range <0, 255> \"\"\" state = self._state_watcher.general_state return state[\"lights_upper\"] @lights.setter def lights(self, brightness: int): try: self._tcp_client.set_lights(brightness, 0) except ValueError as e: raise ValueError(\"Error occured while trying to set lights to: \" f\"{brightness}\") from e @property def depth(self) -> int: \"\"\"Get the current depth in millimeters *Returns*: * depth (int): The depth in millimeters of water column. \"\"\" return self._state_watcher.general_state[\"depth\"] @property def pose(self) -> dict: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" pose = { \"roll\": (self._state_watcher.general_state[\"roll\"] + 360) % 360, \"pitch\": (self._state_watcher.general_state[\"pitch\"] + 360) % 360, \"yaw\": (self._state_watcher.general_state[\"yaw\"] + 360) % 360, } return pose @property def battery_state_of_charge(self) -> int: \"\"\"Get the battery state of charge *Returns*: * state_of_charge (int): Current state of charge of the drone battery in percent, from 0 to 100 \"\"\" return self._state_watcher.general_state[\"battery_state_of_charge_rel\"] @property def error_flags(self) -> int: \"\"\"Get the error flags *Returns*: * error_flags (int): The error flags as int \"\"\" return self._state_watcher.general_state[\"error_flags\"] def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping() Descendants blueye.sdk.drone.Pioneer Instance variables battery_state_of_charge Get the battery state of charge Returns : state_of_charge (int): Current state of charge of the drone battery in percent, from 0 to 100 connection_established depth Get the current depth in millimeters Returns : depth (int): The depth in millimeters of water column. error_flags Get the error flags Returns : error_flags (int): The error flags as int lights Get or set the brightness of the bottom canister lights Arguments : brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> Returns : brightness (int): The brightness of the bottom canister LED's in the range <0, 255> pose Get the current orientation of the drone Returns : pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. Methods connect def connect ( self , timeout : float = None ) Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. timeout (float): Seconds to wait for connection View Source def connect(self, timeout: float = None): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. - *timeout* (float): Seconds to wait for connection \"\"\" self._wait_for_udp_communication(timeout, self._ip) self._update_drone_info() self._start_state_watcher_thread() if self._slave_mode_enabled: # No need to touch the TCP stuff if we're in slave mode so we return early return if not self.connection_established: self._tcp_client = TcpClient(ip=self._ip, port=self._port, autoConnect=False) self._connect_to_tcp_socket() try: self.ping() self.motion.send_thruster_setpoint(0, 0, 0, 0) # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time self.config.set_drone_time(int(time.time())) self._start_watchdog() except ResponseTimeout as e: self._clean_up_tcp_client() raise ConnectionError( f\"Found drone at {self._ip} but was unable to take control of it. \" \"Is there another client connected?\" ) from e except MismatchedReply: # The connection is out of sync, likely due to a previous connection being # disconnected mid-transfer. Re-instantiating the connection should solve the issue self._clean_up_tcp_client() self.connect(timeout) except BrokenPipeError: # Have lost connection to drone, need to reestablish TCP client self._clean_up_tcp_client() self.connect(timeout) disconnect def disconnect ( self ) Disconnects the TCP connection, allowing another client to take control of the drone View Source def disconnect(self): \"\"\"Disconnects the TCP connection, allowing another client to take control of the drone\"\"\" if self.connection_established and not self._slave_mode_enabled: self._clean_up_tcp_client() ping def ping ( self ) Ping drone, an exception is thrown by TcpClient if drone does not answer View Source def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping() Pioneer class Pioneer ( * args , ** kwargs ) A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting autoConnect=False . The drone only supports one client controlling it at a time, but if you pass slaveModeEnabled=True you will still be able to receive data from the drone. View Source class Pioneer(Drone): def __init__(self, *args, **kwargs): warnings.warn( \"This class has been deprecated and will be removed in the next major version, \" \"please use the Drone class instead.\", DeprecationWarning, stacklevel=2, ) super().__init__(*args, **kwargs) Ancestors (in MRO) blueye.sdk.drone.Drone Instance variables battery_state_of_charge Get the battery state of charge Returns : state_of_charge (int): Current state of charge of the drone battery in percent, from 0 to 100 connection_established depth Get the current depth in millimeters Returns : depth (int): The depth in millimeters of water column. error_flags Get the error flags Returns : error_flags (int): The error flags as int lights Get or set the brightness of the bottom canister lights Arguments : brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> Returns : brightness (int): The brightness of the bottom canister LED's in the range <0, 255> pose Get the current orientation of the drone Returns : pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. Methods connect def connect ( self , timeout : float = None ) Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. timeout (float): Seconds to wait for connection View Source def connect(self, timeout: float = None): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. - *timeout* (float): Seconds to wait for connection \"\"\" self._wait_for_udp_communication(timeout, self._ip) self._update_drone_info() self._start_state_watcher_thread() if self._slave_mode_enabled: # No need to touch the TCP stuff if we're in slave mode so we return early return if not self.connection_established: self._tcp_client = TcpClient(ip=self._ip, port=self._port, autoConnect=False) self._connect_to_tcp_socket() try: self.ping() self.motion.send_thruster_setpoint(0, 0, 0, 0) # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time self.config.set_drone_time(int(time.time())) self._start_watchdog() except ResponseTimeout as e: self._clean_up_tcp_client() raise ConnectionError( f\"Found drone at {self._ip} but was unable to take control of it. \" \"Is there another client connected?\" ) from e except MismatchedReply: # The connection is out of sync, likely due to a previous connection being # disconnected mid-transfer. Re-instantiating the connection should solve the issue self._clean_up_tcp_client() self.connect(timeout) except BrokenPipeError: # Have lost connection to drone, need to reestablish TCP client self._clean_up_tcp_client() self.connect(timeout) disconnect def disconnect ( self ) Disconnects the TCP connection, allowing another client to take control of the drone View Source def disconnect(self): \"\"\"Disconnects the TCP connection, allowing another client to take control of the drone\"\"\" if self.connection_established and not self._slave_mode_enabled: self._clean_up_tcp_client() ping def ping ( self ) Ping drone, an exception is thrown by TcpClient if drone does not answer View Source def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping() SlaveModeWarning class SlaveModeWarning ( / , * args , ** kwargs ) Raised when trying to perform action not possible in slave mode View Source class SlaveModeWarning(UserWarning): \"\"\"Raised when trying to perform action not possible in slave mode\"\"\" Ancestors (in MRO) builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Drone"},{"location":"reference/blueye/sdk/drone/#module-blueyesdkdrone","text":"View Source #!/usr/bin/env python3 import socket import threading import time import warnings from json import JSONDecodeError import requests from blueye.protocol import TcpClient, UdpClient from blueye.protocol.exceptions import MismatchedReply, NoConnectionToDrone, ResponseTimeout from packaging import version from .camera import Camera from .constants import WaterDensities from .logs import Logs from .motion import Motion class _DroneStateWatcher(threading.Thread): \"\"\"Subscribes to UDP messages from the drone and stores the latest data\"\"\" def __init__(self, ip: str = \"192.168.1.101\", udp_timeout: float = 3): threading.Thread.__init__(self) self._ip = ip self._udp_timeout = udp_timeout self._general_state = None self._general_state_received = threading.Event() self._calibration_state = None self._calibration_state_received = threading.Event() self._udp_client = UdpClient(drone_ip=self._ip) self._exit_flag = threading.Event() self.daemon = True @property def general_state(self) -> dict: if not self._general_state_received.wait(timeout=self._udp_timeout): raise TimeoutError(\"No state message received from drone\") return self._general_state @property def calibration_state(self) -> dict: if not self._calibration_state_received.wait(timeout=self._udp_timeout): raise TimeoutError(\"No state message received from drone\") return self._calibration_state def run(self): while not self._exit_flag.is_set(): data_packet = self._udp_client.get_data_dict() if data_packet[\"command_type\"] == 1: self._general_state = data_packet self._general_state_received.set() elif data_packet[\"command_type\"] == 2: self._calibration_state = data_packet self._calibration_state_received.set() def stop(self): self._exit_flag.set() class SlaveModeWarning(UserWarning): \"\"\"Raised when trying to perform action not possible in slave mode\"\"\" class _SlaveTcpClient: \"\"\"A dummy TCP client that warns you if you use any of its functions\"\"\" def __getattr__(self, name): def method(*args): warnings.warn( f\"Unable to call {name}{args} with client in slave mode\", SlaveModeWarning, stacklevel=2, ) return method class _NoConnectionTcpClient: \"\"\"A TCP client that raises a ConnectionError if you use any of its functions\"\"\" def __getattr__(self, name): def method(*args, **kwargs): raise ConnectionError( \"The connection to the drone is not established, \" \"try calling the connect method before retrying\" ) return method class Config: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone self._water_density = WaterDensities.salty @property def water_density(self): \"\"\"Get or set the current water density for increased pressure sensor accuracy Setting the water density is only supported on drones with software version 1.5 or higher. Older software versions will assume a water density of 1025 grams per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses). \"\"\" return self._water_density @water_density.setter def water_density(self, density: int): self._parent_drone._verify_required_blunux_version(\"1.5\") self._water_density = density self._parent_drone._tcp_client.set_water_density(density) def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._tcp_client.set_system_time(time) class Drone: \"\"\"A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting `autoConnect=False`. The drone only supports one client controlling it at a time, but if you pass `slaveModeEnabled=True` you will still be able to receive data from the drone. \"\"\" def __init__( self, ip=\"192.168.1.101\", tcpPort=2011, autoConnect=True, slaveModeEnabled=False, udpTimeout=3, ): self._ip = ip self._port = tcpPort self._slave_mode_enabled = slaveModeEnabled if slaveModeEnabled: self._tcp_client = _SlaveTcpClient() else: self._tcp_client = _NoConnectionTcpClient() self._state_watcher = _DroneStateWatcher(ip=self._ip, udp_timeout=udpTimeout) self.camera = Camera(self) self.motion = Motion(self) self.logs = Logs(self) self.config = Config(self) if autoConnect is True: self.connect(timeout=3) def _verify_required_blunux_version(self, requirement: str): \"\"\"Verify that Blunux version is higher than requirement requirement needs to be a string that's able to be parsed by version.parse() Raises a RuntimeError if the Blunux version of the connected drone does not match or exceed the requirement. \"\"\" if not self.connection_established: raise ConnectionError( \"The connection to the drone is not established, try calling the connect method \" \"before retrying\" ) if version.parse(self.software_version_short) < version.parse(requirement): raise RuntimeError( f\"Blunux version of connected drone is {self.software_version_short}. Version \" f\"{requirement} or higher is required.\" ) @property def connection_established(self): if isinstance(self._tcp_client, _NoConnectionTcpClient): return False else: return True def _update_drone_info(self): \"\"\"Request and store information about the connected drone\"\"\" try: response = requests.get(f\"http://{self._ip}/diagnostics/drone_info\", timeout=3).json() except ( requests.ConnectTimeout, requests.ReadTimeout, requests.ConnectionError, JSONDecodeError, ): raise ConnectionError(\"Could not establish connection with drone\") try: self.features = list(filter(None, response[\"features\"].split(\",\"))) except KeyError: # Drone versions older than 1.4.7 did not have this field. self.features = [] self.software_version = response[\"sw_version\"] self.software_version_short = self.software_version.split(\"-\")[0] self.serial_number = response[\"serial_number\"] self.uuid = response[\"hardware_id\"] @staticmethod def _wait_for_udp_communication(timeout: float, ip: str = \"192.168.1.101\"): \"\"\"Simple helper for waiting for drone to come online Raises ConnectionError if no connection is established in the specified timeout. \"\"\" temp_udp_client = UdpClient(drone_ip=ip) temp_udp_client._sock.settimeout(timeout) try: temp_udp_client.get_data_dict() except socket.timeout as e: raise ConnectionError(\"Could not establish connection with drone\") from e def _connect_to_tcp_socket(self): try: self._tcp_client.connect() except NoConnectionToDrone: raise ConnectionError(\"Could not establish connection with drone\") def _start_watchdog(self): \"\"\"Starts the thread for petting the watchdog _connect_to_tcp_socket() must be called first\"\"\" try: self._tcp_client.start() except RuntimeError: # Ignore multiple starts pass def _clean_up_tcp_client(self): \"\"\"Stops the watchdog thread and closes the TCP socket\"\"\" self._tcp_client.stop() self._tcp_client._sock.close() self._tcp_client = _NoConnectionTcpClient() def _start_state_watcher_thread(self): try: self._state_watcher.start() except RuntimeError: # Ignore multiple starts pass def connect(self, timeout: float = None): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. - *timeout* (float): Seconds to wait for connection \"\"\" self._wait_for_udp_communication(timeout, self._ip) self._update_drone_info() self._start_state_watcher_thread() if self._slave_mode_enabled: # No need to touch the TCP stuff if we're in slave mode so we return early return if not self.connection_established: self._tcp_client = TcpClient(ip=self._ip, port=self._port, autoConnect=False) self._connect_to_tcp_socket() try: self.ping() self.motion.send_thruster_setpoint(0, 0, 0, 0) # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time self.config.set_drone_time(int(time.time())) self._start_watchdog() except ResponseTimeout as e: self._clean_up_tcp_client() raise ConnectionError( f\"Found drone at {self._ip} but was unable to take control of it. \" \"Is there another client connected?\" ) from e except MismatchedReply: # The connection is out of sync, likely due to a previous connection being # disconnected mid-transfer. Re-instantiating the connection should solve the issue self._clean_up_tcp_client() self.connect(timeout) except BrokenPipeError: # Have lost connection to drone, need to reestablish TCP client self._clean_up_tcp_client() self.connect(timeout) def disconnect(self): \"\"\"Disconnects the TCP connection, allowing another client to take control of the drone\"\"\" if self.connection_established and not self._slave_mode_enabled: self._clean_up_tcp_client() @property def lights(self) -> int: \"\"\"Get or set the brightness of the bottom canister lights *Arguments*: * brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> *Returns*: * brightness (int): The brightness of the bottom canister LED's in the range <0, 255> \"\"\" state = self._state_watcher.general_state return state[\"lights_upper\"] @lights.setter def lights(self, brightness: int): try: self._tcp_client.set_lights(brightness, 0) except ValueError as e: raise ValueError(\"Error occured while trying to set lights to: \" f\"{brightness}\") from e @property def depth(self) -> int: \"\"\"Get the current depth in millimeters *Returns*: * depth (int): The depth in millimeters of water column. \"\"\" return self._state_watcher.general_state[\"depth\"] @property def pose(self) -> dict: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" pose = { \"roll\": (self._state_watcher.general_state[\"roll\"] + 360) % 360, \"pitch\": (self._state_watcher.general_state[\"pitch\"] + 360) % 360, \"yaw\": (self._state_watcher.general_state[\"yaw\"] + 360) % 360, } return pose @property def battery_state_of_charge(self) -> int: \"\"\"Get the battery state of charge *Returns*: * state_of_charge (int): Current state of charge of the drone battery in percent, from 0 to 100 \"\"\" return self._state_watcher.general_state[\"battery_state_of_charge_rel\"] @property def error_flags(self) -> int: \"\"\"Get the error flags *Returns*: * error_flags (int): The error flags as int \"\"\" return self._state_watcher.general_state[\"error_flags\"] def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping() class Pioneer(Drone): def __init__(self, *args, **kwargs): warnings.warn( \"This class has been deprecated and will be removed in the next major version, \" \"please use the Drone class instead.\", DeprecationWarning, stacklevel=2, ) super().__init__(*args, **kwargs)","title":"Module blueye.sdk.drone"},{"location":"reference/blueye/sdk/drone/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/drone/#config","text":"class Config ( parent_drone : 'Drone' ) View Source class Config: def __init__(self, parent_drone: \"Drone\"): self._parent_drone = parent_drone self._water_density = WaterDensities.salty @property def water_density(self): \"\"\"Get or set the current water density for increased pressure sensor accuracy Setting the water density is only supported on drones with software version 1.5 or higher. Older software versions will assume a water density of 1025 grams per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses). \"\"\" return self._water_density @water_density.setter def water_density(self, density: int): self._parent_drone._verify_required_blunux_version(\"1.5\") self._water_density = density self._parent_drone._tcp_client.set_water_density(density) def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._tcp_client.set_system_time(time)","title":"Config"},{"location":"reference/blueye/sdk/drone/#instance-variables","text":"water_density Get or set the current water density for increased pressure sensor accuracy Setting the water density is only supported on drones with software version 1.5 or higher. Older software versions will assume a water density of 1025 grams per liter. The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses).","title":"Instance variables"},{"location":"reference/blueye/sdk/drone/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/drone/#set_drone_time","text":"def set_drone_time ( self , time : int ) Set the system for the drone This method is used to set the system time for the drone. The argument time is expected to be a Unix timestamp (ie. the number of seconds since the epoch). View Source def set_drone_time(self, time: int): \"\"\"Set the system for the drone This method is used to set the system time for the drone. The argument `time` is expected to be a Unix timestamp (ie. the number of seconds since the epoch). \"\"\" self._parent_drone._tcp_client.set_system_time(time)","title":"set_drone_time"},{"location":"reference/blueye/sdk/drone/#drone","text":"class Drone ( ip = '192.168.1.101' , tcpPort = 2011 , autoConnect = True , slaveModeEnabled = False , udpTimeout = 3 ) A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting autoConnect=False . The drone only supports one client controlling it at a time, but if you pass slaveModeEnabled=True you will still be able to receive data from the drone. View Source class Drone: \"\"\"A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting `autoConnect=False`. The drone only supports one client controlling it at a time, but if you pass `slaveModeEnabled=True` you will still be able to receive data from the drone. \"\"\" def __init__( self, ip=\"192.168.1.101\", tcpPort=2011, autoConnect=True, slaveModeEnabled=False, udpTimeout=3, ): self._ip = ip self._port = tcpPort self._slave_mode_enabled = slaveModeEnabled if slaveModeEnabled: self._tcp_client = _SlaveTcpClient() else: self._tcp_client = _NoConnectionTcpClient() self._state_watcher = _DroneStateWatcher(ip=self._ip, udp_timeout=udpTimeout) self.camera = Camera(self) self.motion = Motion(self) self.logs = Logs(self) self.config = Config(self) if autoConnect is True: self.connect(timeout=3) def _verify_required_blunux_version(self, requirement: str): \"\"\"Verify that Blunux version is higher than requirement requirement needs to be a string that's able to be parsed by version.parse() Raises a RuntimeError if the Blunux version of the connected drone does not match or exceed the requirement. \"\"\" if not self.connection_established: raise ConnectionError( \"The connection to the drone is not established, try calling the connect method \" \"before retrying\" ) if version.parse(self.software_version_short) < version.parse(requirement): raise RuntimeError( f\"Blunux version of connected drone is {self.software_version_short}. Version \" f\"{requirement} or higher is required.\" ) @property def connection_established(self): if isinstance(self._tcp_client, _NoConnectionTcpClient): return False else: return True def _update_drone_info(self): \"\"\"Request and store information about the connected drone\"\"\" try: response = requests.get(f\"http://{self._ip}/diagnostics/drone_info\", timeout=3).json() except ( requests.ConnectTimeout, requests.ReadTimeout, requests.ConnectionError, JSONDecodeError, ): raise ConnectionError(\"Could not establish connection with drone\") try: self.features = list(filter(None, response[\"features\"].split(\",\"))) except KeyError: # Drone versions older than 1.4.7 did not have this field. self.features = [] self.software_version = response[\"sw_version\"] self.software_version_short = self.software_version.split(\"-\")[0] self.serial_number = response[\"serial_number\"] self.uuid = response[\"hardware_id\"] @staticmethod def _wait_for_udp_communication(timeout: float, ip: str = \"192.168.1.101\"): \"\"\"Simple helper for waiting for drone to come online Raises ConnectionError if no connection is established in the specified timeout. \"\"\" temp_udp_client = UdpClient(drone_ip=ip) temp_udp_client._sock.settimeout(timeout) try: temp_udp_client.get_data_dict() except socket.timeout as e: raise ConnectionError(\"Could not establish connection with drone\") from e def _connect_to_tcp_socket(self): try: self._tcp_client.connect() except NoConnectionToDrone: raise ConnectionError(\"Could not establish connection with drone\") def _start_watchdog(self): \"\"\"Starts the thread for petting the watchdog _connect_to_tcp_socket() must be called first\"\"\" try: self._tcp_client.start() except RuntimeError: # Ignore multiple starts pass def _clean_up_tcp_client(self): \"\"\"Stops the watchdog thread and closes the TCP socket\"\"\" self._tcp_client.stop() self._tcp_client._sock.close() self._tcp_client = _NoConnectionTcpClient() def _start_state_watcher_thread(self): try: self._state_watcher.start() except RuntimeError: # Ignore multiple starts pass def connect(self, timeout: float = None): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. - *timeout* (float): Seconds to wait for connection \"\"\" self._wait_for_udp_communication(timeout, self._ip) self._update_drone_info() self._start_state_watcher_thread() if self._slave_mode_enabled: # No need to touch the TCP stuff if we're in slave mode so we return early return if not self.connection_established: self._tcp_client = TcpClient(ip=self._ip, port=self._port, autoConnect=False) self._connect_to_tcp_socket() try: self.ping() self.motion.send_thruster_setpoint(0, 0, 0, 0) # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time self.config.set_drone_time(int(time.time())) self._start_watchdog() except ResponseTimeout as e: self._clean_up_tcp_client() raise ConnectionError( f\"Found drone at {self._ip} but was unable to take control of it. \" \"Is there another client connected?\" ) from e except MismatchedReply: # The connection is out of sync, likely due to a previous connection being # disconnected mid-transfer. Re-instantiating the connection should solve the issue self._clean_up_tcp_client() self.connect(timeout) except BrokenPipeError: # Have lost connection to drone, need to reestablish TCP client self._clean_up_tcp_client() self.connect(timeout) def disconnect(self): \"\"\"Disconnects the TCP connection, allowing another client to take control of the drone\"\"\" if self.connection_established and not self._slave_mode_enabled: self._clean_up_tcp_client() @property def lights(self) -> int: \"\"\"Get or set the brightness of the bottom canister lights *Arguments*: * brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> *Returns*: * brightness (int): The brightness of the bottom canister LED's in the range <0, 255> \"\"\" state = self._state_watcher.general_state return state[\"lights_upper\"] @lights.setter def lights(self, brightness: int): try: self._tcp_client.set_lights(brightness, 0) except ValueError as e: raise ValueError(\"Error occured while trying to set lights to: \" f\"{brightness}\") from e @property def depth(self) -> int: \"\"\"Get the current depth in millimeters *Returns*: * depth (int): The depth in millimeters of water column. \"\"\" return self._state_watcher.general_state[\"depth\"] @property def pose(self) -> dict: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" pose = { \"roll\": (self._state_watcher.general_state[\"roll\"] + 360) % 360, \"pitch\": (self._state_watcher.general_state[\"pitch\"] + 360) % 360, \"yaw\": (self._state_watcher.general_state[\"yaw\"] + 360) % 360, } return pose @property def battery_state_of_charge(self) -> int: \"\"\"Get the battery state of charge *Returns*: * state_of_charge (int): Current state of charge of the drone battery in percent, from 0 to 100 \"\"\" return self._state_watcher.general_state[\"battery_state_of_charge_rel\"] @property def error_flags(self) -> int: \"\"\"Get the error flags *Returns*: * error_flags (int): The error flags as int \"\"\" return self._state_watcher.general_state[\"error_flags\"] def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping()","title":"Drone"},{"location":"reference/blueye/sdk/drone/#descendants","text":"blueye.sdk.drone.Pioneer","title":"Descendants"},{"location":"reference/blueye/sdk/drone/#instance-variables_1","text":"battery_state_of_charge Get the battery state of charge Returns : state_of_charge (int): Current state of charge of the drone battery in percent, from 0 to 100 connection_established depth Get the current depth in millimeters Returns : depth (int): The depth in millimeters of water column. error_flags Get the error flags Returns : error_flags (int): The error flags as int lights Get or set the brightness of the bottom canister lights Arguments : brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> Returns : brightness (int): The brightness of the bottom canister LED's in the range <0, 255> pose Get the current orientation of the drone Returns : pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359.","title":"Instance variables"},{"location":"reference/blueye/sdk/drone/#methods_1","text":"","title":"Methods"},{"location":"reference/blueye/sdk/drone/#connect","text":"def connect ( self , timeout : float = None ) Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. timeout (float): Seconds to wait for connection View Source def connect(self, timeout: float = None): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. - *timeout* (float): Seconds to wait for connection \"\"\" self._wait_for_udp_communication(timeout, self._ip) self._update_drone_info() self._start_state_watcher_thread() if self._slave_mode_enabled: # No need to touch the TCP stuff if we're in slave mode so we return early return if not self.connection_established: self._tcp_client = TcpClient(ip=self._ip, port=self._port, autoConnect=False) self._connect_to_tcp_socket() try: self.ping() self.motion.send_thruster_setpoint(0, 0, 0, 0) # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time self.config.set_drone_time(int(time.time())) self._start_watchdog() except ResponseTimeout as e: self._clean_up_tcp_client() raise ConnectionError( f\"Found drone at {self._ip} but was unable to take control of it. \" \"Is there another client connected?\" ) from e except MismatchedReply: # The connection is out of sync, likely due to a previous connection being # disconnected mid-transfer. Re-instantiating the connection should solve the issue self._clean_up_tcp_client() self.connect(timeout) except BrokenPipeError: # Have lost connection to drone, need to reestablish TCP client self._clean_up_tcp_client() self.connect(timeout)","title":"connect"},{"location":"reference/blueye/sdk/drone/#disconnect","text":"def disconnect ( self ) Disconnects the TCP connection, allowing another client to take control of the drone View Source def disconnect(self): \"\"\"Disconnects the TCP connection, allowing another client to take control of the drone\"\"\" if self.connection_established and not self._slave_mode_enabled: self._clean_up_tcp_client()","title":"disconnect"},{"location":"reference/blueye/sdk/drone/#ping","text":"def ping ( self ) Ping drone, an exception is thrown by TcpClient if drone does not answer View Source def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping()","title":"ping"},{"location":"reference/blueye/sdk/drone/#pioneer","text":"class Pioneer ( * args , ** kwargs ) A class providing an interface to a Blueye drone's functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting autoConnect=False . The drone only supports one client controlling it at a time, but if you pass slaveModeEnabled=True you will still be able to receive data from the drone. View Source class Pioneer(Drone): def __init__(self, *args, **kwargs): warnings.warn( \"This class has been deprecated and will be removed in the next major version, \" \"please use the Drone class instead.\", DeprecationWarning, stacklevel=2, ) super().__init__(*args, **kwargs)","title":"Pioneer"},{"location":"reference/blueye/sdk/drone/#ancestors-in-mro","text":"blueye.sdk.drone.Drone","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/drone/#instance-variables_2","text":"battery_state_of_charge Get the battery state of charge Returns : state_of_charge (int): Current state of charge of the drone battery in percent, from 0 to 100 connection_established depth Get the current depth in millimeters Returns : depth (int): The depth in millimeters of water column. error_flags Get the error flags Returns : error_flags (int): The error flags as int lights Get or set the brightness of the bottom canister lights Arguments : brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> Returns : brightness (int): The brightness of the bottom canister LED's in the range <0, 255> pose Get the current orientation of the drone Returns : pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359.","title":"Instance variables"},{"location":"reference/blueye/sdk/drone/#methods_2","text":"","title":"Methods"},{"location":"reference/blueye/sdk/drone/#connect_1","text":"def connect ( self , timeout : float = None ) Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. timeout (float): Seconds to wait for connection View Source def connect(self, timeout: float = None): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. - *timeout* (float): Seconds to wait for connection \"\"\" self._wait_for_udp_communication(timeout, self._ip) self._update_drone_info() self._start_state_watcher_thread() if self._slave_mode_enabled: # No need to touch the TCP stuff if we're in slave mode so we return early return if not self.connection_established: self._tcp_client = TcpClient(ip=self._ip, port=self._port, autoConnect=False) self._connect_to_tcp_socket() try: self.ping() self.motion.send_thruster_setpoint(0, 0, 0, 0) # The drone runs from a read-only filesystem, and as such does not keep any state, # therefore when we connect to it we should send the current time self.config.set_drone_time(int(time.time())) self._start_watchdog() except ResponseTimeout as e: self._clean_up_tcp_client() raise ConnectionError( f\"Found drone at {self._ip} but was unable to take control of it. \" \"Is there another client connected?\" ) from e except MismatchedReply: # The connection is out of sync, likely due to a previous connection being # disconnected mid-transfer. Re-instantiating the connection should solve the issue self._clean_up_tcp_client() self.connect(timeout) except BrokenPipeError: # Have lost connection to drone, need to reestablish TCP client self._clean_up_tcp_client() self.connect(timeout)","title":"connect"},{"location":"reference/blueye/sdk/drone/#disconnect_1","text":"def disconnect ( self ) Disconnects the TCP connection, allowing another client to take control of the drone View Source def disconnect(self): \"\"\"Disconnects the TCP connection, allowing another client to take control of the drone\"\"\" if self.connection_established and not self._slave_mode_enabled: self._clean_up_tcp_client()","title":"disconnect"},{"location":"reference/blueye/sdk/drone/#ping_1","text":"def ping ( self ) Ping drone, an exception is thrown by TcpClient if drone does not answer View Source def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping()","title":"ping"},{"location":"reference/blueye/sdk/drone/#slavemodewarning","text":"class SlaveModeWarning ( / , * args , ** kwargs ) Raised when trying to perform action not possible in slave mode View Source class SlaveModeWarning(UserWarning): \"\"\"Raised when trying to perform action not possible in slave mode\"\"\"","title":"SlaveModeWarning"},{"location":"reference/blueye/sdk/drone/#ancestors-in-mro_1","text":"builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/drone/#class-variables","text":"args","title":"Class variables"},{"location":"reference/blueye/sdk/drone/#methods_3","text":"","title":"Methods"},{"location":"reference/blueye/sdk/drone/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/blueye/sdk/logs/","text":"Module blueye.sdk.logs View Source from datetime import datetime import requests import tabulate class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called `myDrone`: ``` print(myDrone.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{myDrone.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp = datetime.fromisoformat(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item] class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called `myDrone`, you can do: ``` print(myDrone.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `myDrone.logs[0]`, or if you want some particular log you can do `myDrone.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `myDrone.logs[:-10]`. \"\"\" def __init__(self, parent_drone, auto_download_index=False): self.ip = parent_drone._ip self._parent_drone = parent_drone self.index_downloaded = False if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True def __getitem__(self, item): if not self.index_downloaded: self.refresh_log_index() if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) Classes LogFile class LogFile ( maxdepth , name , timestamp , binsize , ip ) This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called myDrone : print(myDrone.logs[0]) or, if you want to display the header you can format the object with with_header : print(f\"{myDrone.logs[0]:with_header}\") Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. View Source class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called `myDrone`: ``` print(myDrone.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{myDrone.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp = datetime.fromisoformat(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item] Methods download def download ( self , output_path = None , output_name = None , downsample_divisor = 10 ) Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. View Source def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) Logs class Logs ( parent_drone , auto_download_index = False ) This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called myDrone , you can do: print(myDrone.logs) This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do myDrone.logs[0] , or if you want some particular log you can do myDrone.logs[\"exampleName0001.csv\"] . You can even give it a slice, so if you want the last 10 logs you can do myDrone.logs[:-10] . View Source class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called `myDrone`, you can do: ``` print(myDrone.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `myDrone.logs[0]`, or if you want some particular log you can do `myDrone.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `myDrone.logs[:-10]`. \"\"\" def __init__(self, parent_drone, auto_download_index=False): self.ip = parent_drone._ip self._parent_drone = parent_drone self.index_downloaded = False if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True def __getitem__(self, item): if not self.index_downloaded: self.refresh_log_index() if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) Methods refresh_log_index def refresh_log_index ( self ) Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. View Source def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True","title":"Logs"},{"location":"reference/blueye/sdk/logs/#module-blueyesdklogs","text":"View Source from datetime import datetime import requests import tabulate class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called `myDrone`: ``` print(myDrone.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{myDrone.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp = datetime.fromisoformat(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item] class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called `myDrone`, you can do: ``` print(myDrone.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `myDrone.logs[0]`, or if you want some particular log you can do `myDrone.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `myDrone.logs[:-10]`. \"\"\" def __init__(self, parent_drone, auto_download_index=False): self.ip = parent_drone._ip self._parent_drone = parent_drone self.index_downloaded = False if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True def __getitem__(self, item): if not self.index_downloaded: self.refresh_log_index() if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" )","title":"Module blueye.sdk.logs"},{"location":"reference/blueye/sdk/logs/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/logs/#logfile","text":"class LogFile ( maxdepth , name , timestamp , binsize , ip ) This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called myDrone : print(myDrone.logs[0]) or, if you want to display the header you can format the object with with_header : print(f\"{myDrone.logs[0]:with_header}\") Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. View Source class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called `myDrone`: ``` print(myDrone.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{myDrone.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp = datetime.fromisoformat(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item]","title":"LogFile"},{"location":"reference/blueye/sdk/logs/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/logs/#download","text":"def download ( self , output_path = None , output_name = None , downsample_divisor = 10 ) Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. View Source def download(self, output_path=None, output_name=None, downsample_divisor=10): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz. \"\"\" log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log)","title":"download"},{"location":"reference/blueye/sdk/logs/#logs","text":"class Logs ( parent_drone , auto_download_index = False ) This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called myDrone , you can do: print(myDrone.logs) This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do myDrone.logs[0] , or if you want some particular log you can do myDrone.logs[\"exampleName0001.csv\"] . You can even give it a slice, so if you want the last 10 logs you can do myDrone.logs[:-10] . View Source class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Drone object is called `myDrone`, you can do: ``` print(myDrone.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `myDrone.logs[0]`, or if you want some particular log you can do `myDrone.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `myDrone.logs[:-10]`. \"\"\" def __init__(self, parent_drone, auto_download_index=False): self.ip = parent_drone._ip self._parent_drone = parent_drone self.index_downloaded = False if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True def __getitem__(self, item): if not self.index_downloaded: self.refresh_log_index() if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" )","title":"Logs"},{"location":"reference/blueye/sdk/logs/#methods_1","text":"","title":"Methods"},{"location":"reference/blueye/sdk/logs/#refresh_log_index","text":"def refresh_log_index ( self ) Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. View Source def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) self.index_downloaded = True","title":"refresh_log_index"},{"location":"reference/blueye/sdk/motion/","text":"Module blueye.sdk.motion View Source import threading class Motion: \"\"\"Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. \"\"\" def __init__(self, parent_drone): self._parent_drone = parent_drone self._state_watcher = parent_drone._state_watcher self.thruster_lock = threading.Lock() self._current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} self._current_boost_setpoints = {\"slow\": 0, \"boost\": 0} @property def current_thruster_setpoints(self): \"\"\"Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone does not report back it's current setpoint. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. \"\"\" return self._current_thruster_setpoints @current_thruster_setpoints.setter def current_thruster_setpoints(self, *args, **kwargs): raise AttributeError( \"Do not set the setpoints directly, use the surge, sway, heave, yaw properties or the \" \"send_thruster_setpoint function for that.\" ) def _send_motion_input_message(self): \"\"\"Small helper function for building argument list to motion_input command\"\"\" thruster_setpoints = self.current_thruster_setpoints.values() boost_setpoints = self._current_boost_setpoints.values() self._parent_drone._tcp_client.motion_input(*thruster_setpoints, *boost_setpoints) @property def surge(self) -> float: \"\"\"Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge_value self._send_motion_input_message() @property def sway(self) -> float: \"\"\"Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"sway\"] = sway_value self._send_motion_input_message() @property def heave(self) -> float: \"\"\"Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"heave\"] = heave_value self._send_motion_input_message() @property def yaw(self) -> float: \"\"\"Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"yaw\"] = yaw_value self._send_motion_input_message() def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message() @property def boost(self) -> float: \"\"\"Get or set the boost gain Arguments: * **boost_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"boost\"] @boost.setter def boost(self, boost_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"boost\"] = boost_gain self._send_motion_input_message() @property def slow(self) -> float: \"\"\"Get or set the \"slow gain\" (inverse of boost) Arguments: * **slow_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"slow\"] @slow.setter def slow(self, slow_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"slow\"] = slow_gain self._send_motion_input_message() @property def auto_depth_active(self) -> bool: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * active (bool): Activate auto depth mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto depth is active, false if it is not active \"\"\" AUTO_DEPTH_MODE = 3 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_DEPTH_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_depth_active.setter def auto_depth_active(self, active: bool): if active: self._parent_drone._tcp_client.auto_depth_on() else: self._parent_drone._tcp_client.auto_depth_off() @property def auto_heading_active(self) -> bool: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * active (bool): Activate auto heading mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto heading mode is active, false if it is not active \"\"\" AUTO_HEADING_MODE = 7 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_HEADING_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_heading_active.setter def auto_heading_active(self, active: bool): if active: self._parent_drone._tcp_client.auto_heading_on() else: self._parent_drone._tcp_client.auto_heading_off() Classes Motion class Motion ( parent_drone ) Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the send_thruster_setpoint method. View Source class Motion: \"\"\"Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. \"\"\" def __init__(self, parent_drone): self._parent_drone = parent_drone self._state_watcher = parent_drone._state_watcher self.thruster_lock = threading.Lock() self._current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} self._current_boost_setpoints = {\"slow\": 0, \"boost\": 0} @property def current_thruster_setpoints(self): \"\"\"Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone does not report back it's current setpoint. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. \"\"\" return self._current_thruster_setpoints @current_thruster_setpoints.setter def current_thruster_setpoints(self, *args, **kwargs): raise AttributeError( \"Do not set the setpoints directly, use the surge, sway, heave, yaw properties or the \" \"send_thruster_setpoint function for that.\" ) def _send_motion_input_message(self): \"\"\"Small helper function for building argument list to motion_input command\"\"\" thruster_setpoints = self.current_thruster_setpoints.values() boost_setpoints = self._current_boost_setpoints.values() self._parent_drone._tcp_client.motion_input(*thruster_setpoints, *boost_setpoints) @property def surge(self) -> float: \"\"\"Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge_value self._send_motion_input_message() @property def sway(self) -> float: \"\"\"Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"sway\"] = sway_value self._send_motion_input_message() @property def heave(self) -> float: \"\"\"Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"heave\"] = heave_value self._send_motion_input_message() @property def yaw(self) -> float: \"\"\"Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"yaw\"] = yaw_value self._send_motion_input_message() def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message() @property def boost(self) -> float: \"\"\"Get or set the boost gain Arguments: * **boost_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"boost\"] @boost.setter def boost(self, boost_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"boost\"] = boost_gain self._send_motion_input_message() @property def slow(self) -> float: \"\"\"Get or set the \"slow gain\" (inverse of boost) Arguments: * **slow_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"slow\"] @slow.setter def slow(self, slow_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"slow\"] = slow_gain self._send_motion_input_message() @property def auto_depth_active(self) -> bool: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * active (bool): Activate auto depth mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto depth is active, false if it is not active \"\"\" AUTO_DEPTH_MODE = 3 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_DEPTH_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_depth_active.setter def auto_depth_active(self, active: bool): if active: self._parent_drone._tcp_client.auto_depth_on() else: self._parent_drone._tcp_client.auto_depth_off() @property def auto_heading_active(self) -> bool: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * active (bool): Activate auto heading mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto heading mode is active, false if it is not active \"\"\" AUTO_HEADING_MODE = 7 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_HEADING_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_heading_active.setter def auto_heading_active(self, active: bool): if active: self._parent_drone._tcp_client.auto_heading_on() else: self._parent_drone._tcp_client.auto_heading_off() Instance variables auto_depth_active Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. Arguments : active (bool): Activate auto depth mode if active is true, de-activate if false Returns : active (bool): Returns true if auto depth is active, false if it is not active auto_heading_active Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. Arguments : active (bool): Activate auto heading mode if active is true, de-activate if false Returns : active (bool): Returns true if auto heading mode is active, false if it is not active boost Get or set the boost gain Arguments: boost_gain (float): Range from 0 to 1. current_thruster_setpoints Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone does not report back it's current setpoint. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. heave Set force reference for the heave direction Arguments: heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards slow Get or set the \"slow gain\" (inverse of boost) Arguments: slow_gain (float): Range from 0 to 1. surge Set force reference for the surge direction Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway Set force reference for the sway direction Arguments: sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right yaw Set force reference for the yaw direction Arguments: yaw (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. Methods send_thruster_setpoint def send_thruster_setpoint ( self , surge , sway , heave , yaw ) Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. yaw (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. View Source def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message()","title":"Motion"},{"location":"reference/blueye/sdk/motion/#module-blueyesdkmotion","text":"View Source import threading class Motion: \"\"\"Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. \"\"\" def __init__(self, parent_drone): self._parent_drone = parent_drone self._state_watcher = parent_drone._state_watcher self.thruster_lock = threading.Lock() self._current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} self._current_boost_setpoints = {\"slow\": 0, \"boost\": 0} @property def current_thruster_setpoints(self): \"\"\"Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone does not report back it's current setpoint. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. \"\"\" return self._current_thruster_setpoints @current_thruster_setpoints.setter def current_thruster_setpoints(self, *args, **kwargs): raise AttributeError( \"Do not set the setpoints directly, use the surge, sway, heave, yaw properties or the \" \"send_thruster_setpoint function for that.\" ) def _send_motion_input_message(self): \"\"\"Small helper function for building argument list to motion_input command\"\"\" thruster_setpoints = self.current_thruster_setpoints.values() boost_setpoints = self._current_boost_setpoints.values() self._parent_drone._tcp_client.motion_input(*thruster_setpoints, *boost_setpoints) @property def surge(self) -> float: \"\"\"Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge_value self._send_motion_input_message() @property def sway(self) -> float: \"\"\"Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"sway\"] = sway_value self._send_motion_input_message() @property def heave(self) -> float: \"\"\"Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"heave\"] = heave_value self._send_motion_input_message() @property def yaw(self) -> float: \"\"\"Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"yaw\"] = yaw_value self._send_motion_input_message() def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message() @property def boost(self) -> float: \"\"\"Get or set the boost gain Arguments: * **boost_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"boost\"] @boost.setter def boost(self, boost_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"boost\"] = boost_gain self._send_motion_input_message() @property def slow(self) -> float: \"\"\"Get or set the \"slow gain\" (inverse of boost) Arguments: * **slow_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"slow\"] @slow.setter def slow(self, slow_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"slow\"] = slow_gain self._send_motion_input_message() @property def auto_depth_active(self) -> bool: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * active (bool): Activate auto depth mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto depth is active, false if it is not active \"\"\" AUTO_DEPTH_MODE = 3 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_DEPTH_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_depth_active.setter def auto_depth_active(self, active: bool): if active: self._parent_drone._tcp_client.auto_depth_on() else: self._parent_drone._tcp_client.auto_depth_off() @property def auto_heading_active(self) -> bool: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * active (bool): Activate auto heading mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto heading mode is active, false if it is not active \"\"\" AUTO_HEADING_MODE = 7 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_HEADING_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_heading_active.setter def auto_heading_active(self, active: bool): if active: self._parent_drone._tcp_client.auto_heading_on() else: self._parent_drone._tcp_client.auto_heading_off()","title":"Module blueye.sdk.motion"},{"location":"reference/blueye/sdk/motion/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/motion/#motion","text":"class Motion ( parent_drone ) Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the send_thruster_setpoint method. View Source class Motion: \"\"\"Control the motion of the drone, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. \"\"\" def __init__(self, parent_drone): self._parent_drone = parent_drone self._state_watcher = parent_drone._state_watcher self.thruster_lock = threading.Lock() self._current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} self._current_boost_setpoints = {\"slow\": 0, \"boost\": 0} @property def current_thruster_setpoints(self): \"\"\"Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone does not report back it's current setpoint. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. \"\"\" return self._current_thruster_setpoints @current_thruster_setpoints.setter def current_thruster_setpoints(self, *args, **kwargs): raise AttributeError( \"Do not set the setpoints directly, use the surge, sway, heave, yaw properties or the \" \"send_thruster_setpoint function for that.\" ) def _send_motion_input_message(self): \"\"\"Small helper function for building argument list to motion_input command\"\"\" thruster_setpoints = self.current_thruster_setpoints.values() boost_setpoints = self._current_boost_setpoints.values() self._parent_drone._tcp_client.motion_input(*thruster_setpoints, *boost_setpoints) @property def surge(self) -> float: \"\"\"Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge_value self._send_motion_input_message() @property def sway(self) -> float: \"\"\"Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"sway\"] = sway_value self._send_motion_input_message() @property def heave(self) -> float: \"\"\"Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"heave\"] = heave_value self._send_motion_input_message() @property def yaw(self) -> float: \"\"\"Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): with self.thruster_lock: self._current_thruster_setpoints[\"yaw\"] = yaw_value self._send_motion_input_message() def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message() @property def boost(self) -> float: \"\"\"Get or set the boost gain Arguments: * **boost_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"boost\"] @boost.setter def boost(self, boost_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"boost\"] = boost_gain self._send_motion_input_message() @property def slow(self) -> float: \"\"\"Get or set the \"slow gain\" (inverse of boost) Arguments: * **slow_gain** (float): Range from 0 to 1. \"\"\" return self._current_boost_setpoints[\"slow\"] @slow.setter def slow(self, slow_gain: float): with self.thruster_lock: self._current_boost_setpoints[\"slow\"] = slow_gain self._send_motion_input_message() @property def auto_depth_active(self) -> bool: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * active (bool): Activate auto depth mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto depth is active, false if it is not active \"\"\" AUTO_DEPTH_MODE = 3 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_DEPTH_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_depth_active.setter def auto_depth_active(self, active: bool): if active: self._parent_drone._tcp_client.auto_depth_on() else: self._parent_drone._tcp_client.auto_depth_off() @property def auto_heading_active(self) -> bool: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * active (bool): Activate auto heading mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto heading mode is active, false if it is not active \"\"\" AUTO_HEADING_MODE = 7 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_HEADING_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_heading_active.setter def auto_heading_active(self, active: bool): if active: self._parent_drone._tcp_client.auto_heading_on() else: self._parent_drone._tcp_client.auto_heading_off()","title":"Motion"},{"location":"reference/blueye/sdk/motion/#instance-variables","text":"auto_depth_active Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. Arguments : active (bool): Activate auto depth mode if active is true, de-activate if false Returns : active (bool): Returns true if auto depth is active, false if it is not active auto_heading_active Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. Arguments : active (bool): Activate auto heading mode if active is true, de-activate if false Returns : active (bool): Returns true if auto heading mode is active, false if it is not active boost Get or set the boost gain Arguments: boost_gain (float): Range from 0 to 1. current_thruster_setpoints Returns the current setpoints for the thrusters We maintain this state in the SDK since the drone does not report back it's current setpoint. For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError. heave Set force reference for the heave direction Arguments: heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards slow Get or set the \"slow gain\" (inverse of boost) Arguments: slow_gain (float): Range from 0 to 1. surge Set force reference for the surge direction Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway Set force reference for the sway direction Arguments: sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right yaw Set force reference for the yaw direction Arguments: yaw (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise.","title":"Instance variables"},{"location":"reference/blueye/sdk/motion/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/motion/#send_thruster_setpoint","text":"def send_thruster_setpoint ( self , surge , sway , heave , yaw ) Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. yaw (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. View Source def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the drone Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the yaw direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" with self.thruster_lock: self._current_thruster_setpoints[\"surge\"] = surge self._current_thruster_setpoints[\"sway\"] = sway self._current_thruster_setpoints[\"heave\"] = heave self._current_thruster_setpoints[\"yaw\"] = yaw self._send_motion_input_message()","title":"send_thruster_setpoint"},{"location":"reference/blueye/sdk/utils/","text":"Module blueye.sdk.utils View Source import webbrowser import os import blueye.sdk def open_local_documentation(): \"\"\"Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. \"\"\" sdk_path = os.path.dirname(blueye.sdk.__file__) # The documentation is located next to the top-level package so we move up a couple of levels documentation_path = os.path.abspath(sdk_path + \"/../../blueye.sdk_docs/README.html\") webbrowser.open(documentation_path) Functions open_local_documentation def open_local_documentation ( ) Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. View Source def open_local_documentation(): \"\"\"Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. \"\"\" sdk_path = os.path.dirname(blueye.sdk.__file__) # The documentation is located next to the top-level package so we move up a couple of levels documentation_path = os.path.abspath(sdk_path + \"/../../blueye.sdk_docs/README.html\") webbrowser.open(documentation_path)","title":"Utils"},{"location":"reference/blueye/sdk/utils/#module-blueyesdkutils","text":"View Source import webbrowser import os import blueye.sdk def open_local_documentation(): \"\"\"Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. \"\"\" sdk_path = os.path.dirname(blueye.sdk.__file__) # The documentation is located next to the top-level package so we move up a couple of levels documentation_path = os.path.abspath(sdk_path + \"/../../blueye.sdk_docs/README.html\") webbrowser.open(documentation_path)","title":"Module blueye.sdk.utils"},{"location":"reference/blueye/sdk/utils/#functions","text":"","title":"Functions"},{"location":"reference/blueye/sdk/utils/#open_local_documentation","text":"def open_local_documentation ( ) Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. View Source def open_local_documentation(): \"\"\"Open a pre-built local version of the SDK documentation Useful when you are connected to the drone wifi, and don't have access to the online version. \"\"\" sdk_path = os.path.dirname(blueye.sdk.__file__) # The documentation is located next to the top-level package so we move up a couple of levels documentation_path = os.path.abspath(sdk_path + \"/../../blueye.sdk_docs/README.html\") webbrowser.open(documentation_path)","title":"open_local_documentation"}]}