{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About the Blueye Drones","text":"<p>Blueye produces and sells three models of underwater drones, the Blueye Pioneer, Blueye Pro, and Blueye X3. The Pioneer and the Pro are drones designed for inspection, while the X3 is extensible with three guest ports that allow attaching for example grippers or sonars. Visit blueyerobotics.com for more information about the Blueye products.</p>"},{"location":"#this-sdk-and-the-blueye-drones","title":"This SDK and the Blueye drones","text":"<p>A Blueye drone is normally controlled via a mobile device through the Blueye App (iOS/Android). The mobile device is connected via Wi-Fi to a surface unit, and the drone is connected to the surface unit via a tether cable.</p> <p>This python SDK exposes the functionality of the Blueye app through a Python object. The SDK enables remote control of a Blueye drone as well as reading telemetry data and viewing video streams. It is not meant for executing code on the drone itself.</p> <p>To control the drone you connect your laptop to the surface unit Wi-Fi and run code that interfaces with the through the Python object.</p> <p>Check out the <code>Quick Start Guide</code> to get started with using the SDK.</p>"},{"location":"configuration/","title":"Configure drone parameters","text":"<p>There are settings on the drone that are remotely configurable from the Blueye mobile app. These can also be set directly from the SDK.</p>"},{"location":"configuration/#configure-time-and-date","title":"Configure time and date","text":"<p>The drone does not keep track of time internally. The SDK sets the time on the drone automatically when you connect initially. But you can also configure time and date manually like this</p> <pre><code>import time\nfrom blueye.sdk import Drone\n\nmyDrone = Drone()\n\ntime_to_set_on_drone = int(time.time()) # Unix Timestamp\nmyDrone.config.set_drone_time(time_to_set_on_drone)\n</code></pre> <p>or if we for example want to offset the drone time 5 hours relative to our current system time we can do something like this:</p> <pre><code>from blueye.sdk import Drone\nfrom datetime import timezone, timedelta, datetime\n\nmyDrone = Drone()\n\noffset_in_hours = timedelta(hours=5)\nequivalent_timezone = timezone(offset_in_hours)\nunix_timestamp = datetime.now(tz=equivalent_timezone).timestamp()\n\nmyDrone.config.set_drone_time(int(unix_timestamp))\n</code></pre>"},{"location":"configuration/#calibrate-pressure-sensor-for-water-density","title":"Calibrate pressure sensor for water density","text":"<p>The water density on the drone default to a reasonable density for salt water: 1025 grams per liter. For more accurate depth readings, the water density can be configured manually to suit your local conditions</p> <pre><code>from blueye.sdk import Drone, WaterDensities\n\nmyDrone = Drone()\n\n# Salt water\nmyDrone.config.water_density = WaterDensities.salty  # 1.025 kg/L\n\n# Brackish water\nmyDrone.config.water_density = WaterDensities.brackish  # 1.011 kg/L\n\n# Fresh water\nmyDrone.config.water_density = WaterDensities.fresh  # 0.997 kg/L\n\n# Can also be set to arbitrary values\nmyDrone.config.water_density = 1.234\n</code></pre>"},{"location":"configuration/#configure-camera-parameters","title":"Configure camera parameters","text":"<p>There are 6 different camera parameters that can be set. For a full list of camera parameters and their possible values see the <code>camera reference</code> section. For example you could set the bit rate like this</p> <pre><code>from blueye.sdk import Drone\n\nmyDrone = Drone()\n\nmyDrone.camera.bitrate = 8_000_000 # 8 Mbit bitrate\n</code></pre> <p>Due to a bug in the camera streaming on the drone a camera stream has to have been opened at least once before camera parameters can be set on the drone, see issue #67. For instructions on how to start a video stream see, the <code>Quick Start Guide</code>.</p>"},{"location":"migrating-to-v2/","title":"Upgrading to v2","text":"<p>Version 2 of the Blueye SDK (unfortunately) introduces a few breaking changes. The following guide outlines what has changed, and what you need to change to be compatible with the new version.</p>"},{"location":"migrating-to-v2/#change-of-underlying-communication-protocol","title":"Change of underlying communication protocol","text":"<p>The underlying communications protocol has been changed from UDP/TCP to protobuf messages sent over ZeroMQ sockets. This means that the drone now supports multiple simultaneous clients, and as such, the 'slave-mode' functionality is no longer necessary and has been removed.</p> <p>Another added benefit is the ability to list and disconnect other clients connected to the drone.</p>"},{"location":"migrating-to-v2/#requirement-on-blunux-v32-or-newer","title":"Requirement on Blunux v3.2 or newer","text":"<p>The SDK now requires v3.2 or newer of the Blunux operating system to be installed on the drone to able to connect to it.</p>"},{"location":"migrating-to-v2/#dropped-support-python-37","title":"Dropped support Python 3.7","text":"<p>One or several of our subdependencies has dropped support for 3.7, and in an effort to reduce the maintenance burden we decided to drop support for 3.7 when adding support for 3.11.</p>"},{"location":"migrating-to-v2/#new-range-for-lights-control","title":"New range for lights control","text":"<p>Previously the valid range for the <code>lights</code> property was an <code>int</code> between 0 and 255, it has now been updated to a <code>float</code> in the range 0 to 1.</p> <pre><code># Previously\nmy_drone.lights = 64\n\n# Updated\nmy_drone.lights = 0.25\n</code></pre>"},{"location":"migrating-to-v2/#error-flags-are-a-dictionary-of-bools","title":"Error flags are a dictionary of bools","text":"<p>Error flags are now represented as a dictionary of bools instead of bitflags in an <code>int</code>. See the ErrorFlags message for an overview of the possible error states.</p> <pre><code># Previously\ndepth_read_error: bool = my_drone.error_flags &amp; (1 &lt;&lt; 2)\n\n# Updated\ndepth_read_error: bool = my_drone.error_flags[\"depth_read\"]\n</code></pre>"},{"location":"migrating-to-v2/#changed-return-type-in-active_video_streams-property","title":"Changed return type in <code>active_video_streams</code> property","text":"<p>The <code>active_video_streams</code> property has been modified to return a dictionary containing <code>\"main\"</code> and <code>\"guestport\"</code> as keys. This change provides the option to be able to read the number of active video streams for both the main camera and (optinally) a guestport camera. <pre><code># Previously\nstreams_on_main_camera = my_drone.active_video_streams\n\n# Updated\nstreams_on_main_camera = my_drone.active_video_streams[\"main\"]\n</code></pre></p>"},{"location":"migrating-to-v2/#water-density-unit-changed-from-gl-to-kgl","title":"Water Density Unit changed from g/L to kg/L","text":"<p>The unit for water density has been updated from grams per liter (g/L) to kilograms per liter (kg/L). Make sure to adjust your calculations or conversions accordingly.</p> <pre><code># Previously\ndensity: int = my_drone.config.water_density\nprint(density) # Will print 1025\n\n# Updated\ndensity: float = my_drone.config.water_density\nprint(density) # Will print 1.025\n</code></pre>"},{"location":"migrating-to-v2/#camera-stabilization-uses-onoff-instead-of-toggle","title":"Camera Stabilization uses on/off instead of toggle","text":"<p>The camera stabilization functionality now uses separate methods for enabling and disabling instead of a single toggle method. Update your code to use the appropriate methods based on the desired behavior.</p> <pre><code># Previously\nmy_drone.camera.toggle_stabilization()\nprint(my_drone.camera.stabilization_enabled)\n\n# Updated\nmy_drone.camera.stabilization_enabled = True\nprint(my_drone.camera.stabilization_enabled)\n</code></pre>"},{"location":"migrating-to-v2/#tilt_speed-has-been-renamed-to-tilt_velocity","title":"<code>tilt_speed</code> has been renamed to <code>tilt_velocity</code>","text":"<p>The function tilt_speed has been renamed to tilt_velocity to better reflect its purpose and usage. Update your code to use the new function name. <pre><code># Previously\nmy_drone.camera.tilt.set_speed(1)\n\n# Updated\nmy_drone.camera.tilt.set_velocity(1)\n</code></pre></p>"},{"location":"migrating-to-v2/#new-subclass-for-battery-data","title":"New subclass for battery data","text":"<p>The <code>battery_state_of_charge</code> property has been moved to a subclass on the <code>Drone</code>-object. In addition the state of charge range for the battery has been adjusted to a scale of 0 to 1, instead of the previous 0 to 100 range.</p> <pre><code># Previously\nstate_of_charge: int = my_drone.battery_state_of_charge\n\n# Updated\nstate_of_charge: float = my_drone.battery.state_of_charge\n</code></pre>"},{"location":"migrating-to-v2/#custom-overlay-classes-replaced-with-enums","title":"Custom Overlay Classes Replaced with Enums","text":"<p>Custom overlay classes have been replaced with enums defined in the <code>blueye.protocol</code> package. Make sure to update your code to use the new enums for overlay functionality.</p> <pre><code># Previously\nfrom blueye.sdk import DepthUnitOverlay, FontSizeOverlay, LogoOverlay, TemperatureUnitOverlay\n\nmy_drone.camera.overlay.depth_unit = DepthUnitOverlay.METERS\nmy_drone.camera.overlay.font_size = FontSizeOverlay.PX15\nmy_drone.camera.overlay.logo = LogoOverlay.BLUEYE\nmy_drone.camera.overlay.temperature_unit = TemperatureUnitOverlay.CELSIUS\n\n# Updated\nimport blueye.protocol as bp\n\nmy_drone.camera.overlay.depth_unit = bp.DepthUnit.DEPTH_UNIT_METERS\nmy_drone.camera.overlay.font_size = bp.FontSize.FONT_SIZE_PX15\nmy_drone.camera.overlay.logo = bp.LogoType.LOGO_TYPE_DEFAULT\nmy_drone.camera.overlay.temperature_unit = bp.TemperatureUnit.TEMPERATURE_UNIT_CELSIUS\n</code></pre>"},{"location":"migrating-to-v2/#telemetry-properties-will-now-return-none-if-no-data-exists","title":"Telemetry properties will now return <code>None</code> if no data exists","text":"<p>Properties that read telemetry data, such as <code>lights</code>, <code>tilt_angle</code>, <code>depth</code>, <code>pose</code>, <code>battery_state_of_charge</code>, <code>error_flags</code>, <code>active_video_streams</code>, <code>auto_depth_active</code>, and <code>auto_heading_active</code>, will now return <code>None</code> if no telemetry message has been received from the drone. Previously if a UDP message had not arrived, a <code>KeyError</code> exception would have been raised.</p> <pre><code># Previously\nprint(my_drone.pose) # If no state message has been received yet this could throw a KeyError\n\n# Updated\nprint(my_drone.pose) # This will now print \"None\" if no AttitudeTel-message has been received.\n</code></pre>"},{"location":"migrating-to-v2/#new-initialization-parameters-to-the-drone-object","title":"New initialization parameters to the <code>Drone</code> object","text":"<p>The <code>AutoConnect</code> parameter has been renamed to <code>auto_connect</code> for consistency and clarity. <pre><code># Previously\nmy_drone = Drone(AutoConnect = False)\n\n# Updated\nmy_drone = Drone(auto_connect = False)\n</code></pre></p> <p>The <code>udpTimeout</code> parameter has been renamed to <code>timeout</code> for consistency and clarity. <pre><code># Previously\nmy_drone = Drone(udpTimeout = 5)\n\n# Updated\nmy_drone = Drone(timeout = 5)\n</code></pre></p>"},{"location":"protobuf-protocol/","title":"Protocol Documentation","text":""},{"location":"protobuf-protocol/#aquatrollproto","title":"aquatroll.proto","text":"<p>Aquatroll</p> <p>These messages are emitted by the In-Situ AquaTroll 500 probe.</p> <p></p>"},{"location":"protobuf-protocol/#aquatrollparameterblock","title":"AquaTrollParameterBlock","text":"<p>In-Situ Parameter Block</p> <p>Up to NUMBER_OF_SENSOR_PARAMETERS blocks may be part of a sensor</p> Field Type Label Description measured_value float parameter_id AquaTrollParameter units_id AquaTrollUnit data_quality_ids AquaTrollQuality repeated off_line_sentinel_value float available_units AquaTrollUnit repeated <p></p>"},{"location":"protobuf-protocol/#aquatrollprobemetadata","title":"AquaTrollProbeMetadata","text":"Field Type Label Description timestamp google.protobuf.Timestamp status bool register_map_template_version uint32 device_id AquaTrollDevice device_serial_number uint32 manufacture_date google.protobuf.Timestamp firmware_version uint32 boot_code_version uint32 hardware_version uint32 max_data_logs uint32 total_data_log_memory uint32 total_battery_ticks uint32 last_battery_change google.protobuf.Timestamp device_name string site_name string latitude_coordinate double longitude_coordinate double altitude_coordinate double current_time_utc google.protobuf.Timestamp device_status_flags AquaTrollDeviceStatus repeated used_battery_ticks uint32 used_data_log_memory uint32 sensors AquaTrollSensor repeated"},{"location":"protobuf-protocol/#aquatrollsensormetadata","title":"AquaTrollSensorMetadata","text":"<p>In-Situ AquaTroll 500 sensor metadata</p> <p>(Mostly) static information about a connected sensor.</p> <p>Refer to Section 7 Sensor Common Registers in the In-Situ Modbus Communication Protocol</p> Field Type Label Description timestamp google.protobuf.Timestamp sensor_id AquaTrollSensor sensor_serial_number uint32 sensor_status_flags AquaTrollSensorStatus repeated last_factory_calibration google.protobuf.Timestamp next_factory_calibration google.protobuf.Timestamp last_user_calibration google.protobuf.Timestamp next_user_calibration google.protobuf.Timestamp warm_up_time_in_milliseconds uint32 fast_sample_rate_in_milliseconds uint32 number_of_sensor_parameters uint32 alarm_and_warning_parameter_number uint32 alarm_and_warning_enable_bits uint32 high_alarm_set_value float high_alarm_clear_value float high_warning_set_value float high_warning_clear_value float low_warning_clear_value float low_warning_set_value float low_alarm_clear_value float low_alarm_set_value float parameter_blocks AquaTrollParameterBlock repeated <p></p>"},{"location":"protobuf-protocol/#aquatrollsensormetadataarray","title":"AquaTrollSensorMetadataArray","text":"Field Type Label Description timestamp google.protobuf.Timestamp sensors AquaTrollSensorMetadata repeated"},{"location":"protobuf-protocol/#aquatrollsensorparameters","title":"AquaTrollSensorParameters","text":"Field Type Label Description sensor_id AquaTrollSensor parameter_blocks AquaTrollParameterBlock repeated"},{"location":"protobuf-protocol/#aquatrollsensorparametersarray","title":"AquaTrollSensorParametersArray","text":"Field Type Label Description timestamp google.protobuf.Timestamp sensors AquaTrollSensorParameters repeated"},{"location":"protobuf-protocol/#setaquatrollconnectionstatus","title":"SetAquaTrollConnectionStatus","text":"<p>Request to change the In-Situ Aqua Troll connection status</p> Field Type Label Description connected bool True to connect, false to disconnect <p></p>"},{"location":"protobuf-protocol/#setaquatrollparameterunit","title":"SetAquaTrollParameterUnit","text":"<p>Request to set an In-Situ Aqua Troll parameter unit</p> Field Type Label Description sensor_id AquaTrollSensor Sensor id, f. ex. \"SENSOR_CONDUCTIVITY_SENSOR\" parameter_id AquaTrollParameter Parameter name, f. ex. \"PARAMETER_TEMPERATURE\" unit_id AquaTrollUnit Unit, f. ex. \"UNIT_TEMP_CELSIUS\" <p></p>"},{"location":"protobuf-protocol/#aquatrolldevice","title":"AquaTrollDevice","text":"<p>Aqua Troll Device IDs</p> Name Number Description AQUA_TROLL_DEVICE_UNSPECIFIED 0 AQUA_TROLL_DEVICE_LEVEL_TROLL_500 1 AQUA_TROLL_DEVICE_LEVEL_TROLL_700 2 AQUA_TROLL_DEVICE_BAROTROLL_500 3 AQUA_TROLL_DEVICE_LEVEL_TROLL_300 4 AQUA_TROLL_DEVICE_AQUA_TROLL_200 5 AQUA_TROLL_DEVICE_AQUA_TROLL_600 7 AQUA_TROLL_DEVICE_AQUA_TROLL_100 10 AQUA_TROLL_DEVICE_FLOW_TROLL_500 11 AQUA_TROLL_DEVICE_RDO_PRO 12 AQUA_TROLL_DEVICE_RUGGED_TROLL_200 16 AQUA_TROLL_DEVICE_RUGGED_BAROTROLL 17 AQUA_TROLL_DEVICE_AQUA_TROLL_400 18 AQUA_TROLL_DEVICE_RDO_TITAN 19 AQUA_TROLL_DEVICE_SMARTROLL 21 AQUA_TROLL_DEVICE_AQUA_TROLL_600_VENTED 26 AQUA_TROLL_DEVICE_LEVEL_TROLL_400 30 AQUA_TROLL_DEVICE_RDO_PRO_X 31 AQUA_TROLL_DEVICE_AQUA_TROLL_500 33 AQUA_TROLL_DEVICE_AQUA_TROLL_500_VENTED 34 <p></p>"},{"location":"protobuf-protocol/#aquatrolldevicestatus","title":"AquaTrollDeviceStatus","text":"<p>Aqua Troll Device Status IDs</p> Name Number Description AQUA_TROLL_DEVICE_STATUS_SENSOR_HIGH_ALARM 0 protolint:disable:this ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH AQUA_TROLL_DEVICE_STATUS_SENSOR_HIGH_WARNING 1 AQUA_TROLL_DEVICE_STATUS_SENSOR_LOW_WARNING 2 AQUA_TROLL_DEVICE_STATUS_SENSOR_LOW_ALARM 3 AQUA_TROLL_DEVICE_STATUS_SENSOR_CALIBRATION_WARNING 4 AQUA_TROLL_DEVICE_STATUS_SENSOR_MALFUNCTION 5 AQUA_TROLL_DEVICE_STATUS_POWER_MANAGEMENT_DISABLED 8 AQUA_TROLL_DEVICE_STATUS_DEVICE_OFF_LINE 9 AQUA_TROLL_DEVICE_STATUS_DEVICE_HARDWARE_RESET_OCCURRED 10 AQUA_TROLL_DEVICE_STATUS_DEVICE_MALFUNCTION 11 AQUA_TROLL_DEVICE_STATUS_NO_EXTERNAL_POWER 12 AQUA_TROLL_DEVICE_STATUS_LOW_BATTERY 13 AQUA_TROLL_DEVICE_STATUS_LOW_MEMORY 14 <p></p>"},{"location":"protobuf-protocol/#aquatrollparameter","title":"AquaTrollParameter","text":"<p>Aqua Troll Parameter IDs</p> Name Number Description AQUA_TROLL_PARAMETER_UNSPECIFIED 0 AQUA_TROLL_PARAMETER_TEMPERATURE 1 AQUA_TROLL_PARAMETER_PRESSURE 2 AQUA_TROLL_PARAMETER_DEPTH 3 AQUA_TROLL_PARAMETER_LEVEL_DEPTH_TO_WATER 4 AQUA_TROLL_PARAMETER_LEVEL_SURFACE_ELEVATION 5 AQUA_TROLL_PARAMETER_LATITUDE 6 AQUA_TROLL_PARAMETER_LONGITUDE 7 AQUA_TROLL_PARAMETER_ELEVATION 8 AQUA_TROLL_PARAMETER_ACTUAL_CONDUCTIVITY 9 AQUA_TROLL_PARAMETER_SPECIFIC_CONDUCTIVITY 10 AQUA_TROLL_PARAMETER_RESISTIVITY 11 AQUA_TROLL_PARAMETER_SALINITY 12 AQUA_TROLL_PARAMETER_TOTAL_DISSOLVED_SOLIDS 13 AQUA_TROLL_PARAMETER_DENSITY_OF_WATER 14 AQUA_TROLL_PARAMETER_SPECIFIC_GRAVITY 15 AQUA_TROLL_PARAMETER_BAROMETRIC_PRESSURE 16 AQUA_TROLL_PARAMETER_PH 17 AQUA_TROLL_PARAMETER_PH_MV 18 AQUA_TROLL_PARAMETER_ORP 19 AQUA_TROLL_PARAMETER_DISSOLVED_OXYGEN_CONCENTRATION 20 AQUA_TROLL_PARAMETER_DISSOLVED_OXYGEN_SATURATION 21 AQUA_TROLL_PARAMETER_NITRATE 22 AQUA_TROLL_PARAMETER_AMMONIUM 23 AQUA_TROLL_PARAMETER_CHLORIDE 24 AQUA_TROLL_PARAMETER_TURBIDITY 25 AQUA_TROLL_PARAMETER_BATTERY_VOLTAGE 26 AQUA_TROLL_PARAMETER_HEAD 27 AQUA_TROLL_PARAMETER_FLOW 28 AQUA_TROLL_PARAMETER_TOTAL_FLOW 29 AQUA_TROLL_PARAMETER_OXYGEN_PARTIAL_PRESSURE 30 AQUA_TROLL_PARAMETER_TOTAL_SUSPENDED_SOLIDS 31 AQUA_TROLL_PARAMETER_EXTERNAL_VOLTAGE 32 AQUA_TROLL_PARAMETER_BATTERY_CAPACITY_REMAINING 33 AQUA_TROLL_PARAMETER_RHODAMINE_WT_CONCENTRATION 34 AQUA_TROLL_PARAMETER_RHODAMINE_WT_FLUORESCENCE_INTENSITY 35 AQUA_TROLL_PARAMETER_CHLORIDE_CL_MV 36 AQUA_TROLL_PARAMETER_NITRATE_AS_NITROGEN_NO3_N_CONCENTRATION 37 AQUA_TROLL_PARAMETER_NITRATE_NO3_MV 38 AQUA_TROLL_PARAMETER_AMMONIUM_AS_NITROGEN_NH4_PLUS_N_CONCENTRATION 39 AQUA_TROLL_PARAMETER_AMMONIUM_NH4_MV 40 AQUA_TROLL_PARAMETER_AMMONIA_AS_NITROGEN_NH3_N_CONCENTRATION 41 AQUA_TROLL_PARAMETER_TOTAL_AMMONIA_AS_NITROGEN_NH3_N_CONCENTRATION 42 AQUA_TROLL_PARAMETER_EH 48 AQUA_TROLL_PARAMETER_VELOCITY 49 AQUA_TROLL_PARAMETER_CHLOROPHYLL_A_CONCENTRATION 50 AQUA_TROLL_PARAMETER_CHLOROPHYLL_A_FLUORESCENCE_INTENSITY 51 AQUA_TROLL_PARAMETER_BLUE_GREEN_ALGAE_PHYCOCYANIN_CONCENTRATION 54 AQUA_TROLL_PARAMETER_BLUE_GREEN_ALGAE_PHYCOCYANIN_FLUORESCENCE_INTENSITY 55 AQUA_TROLL_PARAMETER_BLUE_GREEN_ALGAE_PHYCOERYTHRIN_CONCENTRATION 58 AQUA_TROLL_PARAMETER_BLUE_GREEN_ALGAE_PHYCOERYTHRIN_FLUORESCENCE_INTENSITY 59 AQUA_TROLL_PARAMETER_FLUORESCEIN_WT_CONCENTRATION 67 AQUA_TROLL_PARAMETER_FLUORESCEIN_WT_FLUORESCENCE_INTENSITY 68 AQUA_TROLL_PARAMETER_FLUORESCENT_DISSOLVED_ORGANIC_MATTER_CONCENTRATION 69 AQUA_TROLL_PARAMETER_FLUORESCENT_DISSOLVED_ORGANIC_MATTER_FLUORESCENCE_INTENSITY 70 AQUA_TROLL_PARAMETER_CRUDE_OIL_CONCENTRATION 80 AQUA_TROLL_PARAMETER_CRUDE_OIL_FLUORESCENCE_INTENSITY 81 AQUA_TROLL_PARAMETER_COLORED_DISSOLVED_ORGANIC_MATTER_CONCENTRATION 87 <p></p>"},{"location":"protobuf-protocol/#aquatrollquality","title":"AquaTrollQuality","text":"<p>Aqua Troll Quality IDs</p> Name Number Description AQUA_TROLL_QUALITY_NORMAL 0 protolint:disable:this ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH AQUA_TROLL_QUALITY_USER_CAL_EXPIRED 1 AQUA_TROLL_QUALITY_FACTORY_CAL_EXPIRED 2 AQUA_TROLL_QUALITY_ERROR 3 AQUA_TROLL_QUALITY_WARM_UP 4 AQUA_TROLL_QUALITY_SENSOR_WARNING 5 AQUA_TROLL_QUALITY_CALIBRATING 6 AQUA_TROLL_QUALITY_OFF_LINE 7 <p></p>"},{"location":"protobuf-protocol/#aquatrollsensor","title":"AquaTrollSensor","text":"<p>Aqua Troll Sensor IDs</p> Name Number Description AQUA_TROLL_SENSOR_UNSPECIFIED 0 AQUA_TROLL_SENSOR_TEMPERATURE 1 AQUA_TROLL_SENSOR_S5_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 2 AQUA_TROLL_SENSOR_S15_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 3 AQUA_TROLL_SENSOR_S30_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 4 AQUA_TROLL_SENSOR_S100_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 5 AQUA_TROLL_SENSOR_S300_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 6 AQUA_TROLL_SENSOR_S500_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 7 AQUA_TROLL_SENSOR_S1000_PSI_FULL_SCALE_ABSOLUTE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 8 AQUA_TROLL_SENSOR_S30_PSI_FULL_SCALE_ABSOLUTE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 9 AQUA_TROLL_SENSOR_S100_PSI_FULL_SCALE_ABSOLUTE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 10 AQUA_TROLL_SENSOR_S300_PSI_FULL_SCALE_ABSOLUTE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 11 AQUA_TROLL_SENSOR_S500_PSI_FULL_SCALE_ABSOLUTE_PRESSURE_WITH_LEVEL_AND_TEMPERATURE 12 AQUA_TROLL_SENSOR_S30_PSI_FULL_SCALE_ABSOLUTE_PRESSURE_WITH_TEMPERATURE 13 AQUA_TROLL_SENSOR_S5_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_TEMPERATURE_AND_CONDUCTIVITY 14 AQUA_TROLL_SENSOR_S15_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_TEMPERATURE_AND_CONDUCTIVITY 15 AQUA_TROLL_SENSOR_S30_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_TEMPERATURE_AND_CONDUCTIVITY 16 AQUA_TROLL_SENSOR_S100_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_TEMPERATURE_AND_CONDUCTIVITY 17 AQUA_TROLL_SENSOR_S300_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_TEMPERATURE_AND_CONDUCTIVITY 18 AQUA_TROLL_SENSOR_S500_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_LEVEL_TEMPERATURE_AND_CONDUCTIVITY 19 AQUA_TROLL_SENSOR_NOT_USED 20 AQUA_TROLL_SENSOR_S30_PSI_FULL_SCALE_ABSOLUTE_PRESSURE_WITH_LEVEL_TEMPERATURE_AND_CONDUCTIVITY 21 AQUA_TROLL_SENSOR_S100_PSI_FULL_SCALE_ABSOLUTE_PRESSURE_WITH_LEVEL_TEMPERATURE_AND_CONDUCTIVITY 22 AQUA_TROLL_SENSOR_S300_PSI_FULL_SCALE_ABSOLUTE_PRESSURE_WITH_LEVEL_TEMPERATURE_AND_CONDUCTIVITY 23 AQUA_TROLL_SENSOR_S500_PSI_FULL_SCALE_ABSOLUTE_PRESSURE_WITH_LEVEL_TEMPERATURE_AND_CONDUCTIVITY 24 AQUA_TROLL_SENSOR_S165_PSI_FULL_SCALE_ABSOLUTE_PRESSURE 25 AQUA_TROLL_SENSOR_PH_ANALOG_SENSOR 26 AQUA_TROLL_SENSOR_PH_ORP_ANALOG_SENSOR 27 AQUA_TROLL_SENSOR_DISSOLVED_OXYGEN_CLARK_CELL_ANALOG_SENSOR 28 AQUA_TROLL_SENSOR_NITRATE_ANALOG_SENSOR 29 AQUA_TROLL_SENSOR_AMMONIUM_ANALOG_SENSOR 30 AQUA_TROLL_SENSOR_CHLORIDE_ANALOG_SENSOR 31 AQUA_TROLL_SENSOR_S100_FOOT_FULL_SCALE_LEVEL_WITH_ABSOLUTE_PRESSURE_AND_TEMPERATURE 32 AQUA_TROLL_SENSOR_S250_FOOT_FULL_SCALE_LEVEL_WITH_ABSOLUTE_PRESSURE_AND_TEMPERATURE 33 AQUA_TROLL_SENSOR_S30_FOOT_FULL_SCALE_LEVEL_WITH_ABSOLUTE_PRESSURE_AND_TEMPERATURE 34 AQUA_TROLL_SENSOR_CONDUCTIVITY_AND_TEMPERATURE 35 AQUA_TROLL_SENSOR_S5_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_TEMPERATURE_HEAD_AND_FLOW 36 AQUA_TROLL_SENSOR_S15_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_TEMPERATURE_HEAD_AND_FLOW 37 AQUA_TROLL_SENSOR_S30_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_TEMPERATURE_HEAD_AND_FLOW 38 AQUA_TROLL_SENSOR_S100_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_TEMPERATURE_HEAD_AND_FLOW 39 AQUA_TROLL_SENSOR_S300_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_TEMPERATURE_HEAD_AND_FLOW 40 AQUA_TROLL_SENSOR_S500_PSI_FULL_SCALE_GAUGE_PRESSURE_WITH_TEMPERATURE_HEAD_AND_FLOW 41 AQUA_TROLL_SENSOR_OPTICAL_DISSOLVED_OXYGEN_WITH_TEMPERATURE 42 AQUA_TROLL_SENSOR_S1_BAR 43 AQUA_TROLL_SENSOR_S2_BAR 44 AQUA_TROLL_SENSOR_S5_BAR 45 AQUA_TROLL_SENSOR_TURBIDITY_SENSOR 50 AQUA_TROLL_SENSOR_TEMPERATURE_SENSOR 55 AQUA_TROLL_SENSOR_CONDUCTIVITY_SENSOR 56 AQUA_TROLL_SENSOR_RDO_SENSOR 57 AQUA_TROLL_SENSOR_PH_ORP_SENSOR 58 AQUA_TROLL_SENSOR_RHODAMINE_WT_SENSOR 60 AQUA_TROLL_SENSOR_CHLOROPHYLL_A_SENSOR 62 AQUA_TROLL_SENSOR_BLUE_GREEN_ALGAE_PHYCOCYANIN_SENSOR 64 AQUA_TROLL_SENSOR_BLUE_GREEN_ALGAE_PHYCOERYTHRIN_SENSOR 65 AQUA_TROLL_SENSOR_NITRATE_ISE_SENSOR 70 AQUA_TROLL_SENSOR_AMMONIUM_ISE_SENSOR 71 AQUA_TROLL_SENSOR_CHLORIDE_ISE_SENSOR 72 AQUA_TROLL_SENSOR_PROBE_PARAMETERS 79 <p></p>"},{"location":"protobuf-protocol/#aquatrollsensorstatus","title":"AquaTrollSensorStatus","text":"<p>Aqua Troll Sensor Status IDs</p> Name Number Description AQUA_TROLL_SENSOR_STATUS_SENSOR_HIGH_ALARM 0 protolint:disable:this ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH AQUA_TROLL_SENSOR_STATUS_SENSOR_HIGH_WARNING 1 AQUA_TROLL_SENSOR_STATUS_SENSOR_LOW_WARNING 2 AQUA_TROLL_SENSOR_STATUS_SENSOR_LOW_ALARM 3 AQUA_TROLL_SENSOR_STATUS_SENSOR_CALIBRATION_WARNING 4 AQUA_TROLL_SENSOR_STATUS_SENSOR_MALFUNCTION 5 AQUA_TROLL_SENSOR_STATUS_SENSOR_MODE_BIT_1 8 AQUA_TROLL_SENSOR_STATUS_SENSOR_MODE_BIT_2 9 <p></p>"},{"location":"protobuf-protocol/#aquatrollunit","title":"AquaTrollUnit","text":"<p>Aqua Troll Unit IDs</p> Name Number Description AQUA_TROLL_UNIT_UNSPECIFIED 0 AQUA_TROLL_UNIT_TEMP_CELSIUS 1 AQUA_TROLL_UNIT_TEMP_FARENHEIT 2 AQUA_TROLL_UNIT_TEMP_KELVIN 3 AQUA_TROLL_UNIT_POUNDS_PER_SQUARE_INCH 17 AQUA_TROLL_UNIT_PASCALS 18 AQUA_TROLL_UNIT_KILOPASCALS 19 AQUA_TROLL_UNIT_BARS 20 AQUA_TROLL_UNIT_MILLIBARS 21 AQUA_TROLL_UNIT_MILLIMETERS_OF_MERCURY 22 AQUA_TROLL_UNIT_INCHES_OF_MERCURY 23 AQUA_TROLL_UNIT_CENTIMETERS_OF_WATER 24 AQUA_TROLL_UNIT_INCHES_OF_WATER 25 AQUA_TROLL_UNIT_TORR 26 AQUA_TROLL_UNIT_STANDARD_ATMOSPHERE 27 AQUA_TROLL_UNIT_MILLIMETERS 33 AQUA_TROLL_UNIT_CENTIMETERS 34 AQUA_TROLL_UNIT_METERS 35 AQUA_TROLL_UNIT_KILOMETER 36 AQUA_TROLL_UNIT_INCHES 37 AQUA_TROLL_UNIT_FEET 38 AQUA_TROLL_UNIT_DEGREES 49 AQUA_TROLL_UNIT_MINUTES 50 AQUA_TROLL_UNIT_SECONDS 51 AQUA_TROLL_UNIT_MICROSIEMENS_PER_CENTIMETER 65 AQUA_TROLL_UNIT_MILLISIEMENS_PER_CENTIMETER 66 AQUA_TROLL_UNIT_OHM_CENTIMETERS 81 AQUA_TROLL_UNIT_PRACTICAL_SALINITY_UNITS 97 AQUA_TROLL_UNIT_PARTS_PER_THOUSAND_SALINITY 98 AQUA_TROLL_UNIT_PARTS_PER_MILLION 113 AQUA_TROLL_UNIT_PARTS_PER_THOUSAND 114 AQUA_TROLL_UNIT_PARTS_PER_MILLION_NITROGEN 115 AQUA_TROLL_UNIT_PARTS_PER_MILLION_CHLORIDE 116 AQUA_TROLL_UNIT_MILLIGRAMS_PER_LITER 117 AQUA_TROLL_UNIT_MICROGRAMS_PER_LITER 118 AQUA_TROLL_UNIT_MICROMOLES_PER_LITER_DEPRECATED 119 AQUA_TROLL_UNIT_GRAMS_PER_LITER 120 AQUA_TROLL_UNIT_PARTS_PER_BILLION 121 AQUA_TROLL_UNIT_GRAMS_PER_CUBIC_CENTIMETER 129 AQUA_TROLL_UNIT_PH 145 AQUA_TROLL_UNIT_MICRO_VOLTS 161 AQUA_TROLL_UNIT_MILLI_VOLTS 162 AQUA_TROLL_UNIT_VOLTS 163 AQUA_TROLL_UNIT_PERCENT_SATURATION 177 AQUA_TROLL_UNIT_FORMAZIN_NEPHELOMETRIC_UNITS 193 AQUA_TROLL_UNIT_NEPHELOMETRIC_TURBIDITY_UNITS 194 AQUA_TROLL_UNIT_FORMAZIN_TURBIDITY_UNITS 195 AQUA_TROLL_UNIT_CUBIC_FEET_PER_SECOND 209 AQUA_TROLL_UNIT_CUBIC_FEET_PER_MINUTE 210 AQUA_TROLL_UNIT_CUBIC_FEET_PER_HOUR 211 AQUA_TROLL_UNIT_CUBIC_FEET_PER_DAY 212 AQUA_TROLL_UNIT_GALLONS_PER_SECOND 213 AQUA_TROLL_UNIT_GALLONS_PER_MINUTE 214 AQUA_TROLL_UNIT_GALLONS_PER_HOUR 215 AQUA_TROLL_UNIT_MILLIONS_OF_GALLONS_PER_DAY 216 AQUA_TROLL_UNIT_CUBIC_METERS_PER_SECOND 217 AQUA_TROLL_UNIT_CUBIC_METERS_PER_MINUTE 218 AQUA_TROLL_UNIT_CUBIC_METERS_PER_HOUR 219 AQUA_TROLL_UNIT_CUBIC_METERS_PER_DAY 220 AQUA_TROLL_UNIT_LITERS_PER_SECOND 221 AQUA_TROLL_UNIT_MILLIONS_OF_LITERS_PER_DAY 222 AQUA_TROLL_UNIT_MILLILITERS_PER_MINUTE 223 AQUA_TROLL_UNIT_THOUSANDS_OF_LITERS_PER_DAY 224 AQUA_TROLL_UNIT_CUBIC_FEET 225 AQUA_TROLL_UNIT_GALLONS 226 AQUA_TROLL_UNIT_MILLIONS_OF_GALLONS 227 AQUA_TROLL_UNIT_CUBIC_METERS 228 AQUA_TROLL_UNIT_LITERS 229 AQUA_TROLL_UNIT_ACRE_FEET 230 AQUA_TROLL_UNIT_MILLILITERS 231 AQUA_TROLL_UNIT_MILLIONS_OF_LITERS 232 AQUA_TROLL_UNIT_THOUSANDS_OF_LITERS 233 AQUA_TROLL_UNIT_ACRE_INCHES 234 AQUA_TROLL_UNIT_PERCENT 241 AQUA_TROLL_UNIT_RELATIVE_FLUORESCENCE_UNITS 257 AQUA_TROLL_UNIT_MILLILITERS_PER_SECOND 273 AQUA_TROLL_UNIT_MILLILITERS_PER_HOUR 274 AQUA_TROLL_UNIT_LITERS_PER_MINUTE 275 AQUA_TROLL_UNIT_LITERS_PER_HOUR 276 AQUA_TROLL_UNIT_MICROAMPS 289 AQUA_TROLL_UNIT_MILLIAMPS 290 AQUA_TROLL_UNIT_AMPS 291 AQUA_TROLL_UNIT_FEET_PER_SECOND 305 AQUA_TROLL_UNIT_METERS_PER_SECOND 306 <p></p>"},{"location":"protobuf-protocol/#type","title":"Type","text":"<p>Type IDs</p> Name Number Description TYPE_UNSPECIFIED 0 TYPE_SHORT 1 TYPE_UNSIGNED_SHORT 2 TYPE_LONG 3 TYPE_UNSIGNED_LONG 4 TYPE_FLOAT 5 TYPE_DOUBLE 6 TYPE_CHARACTER 7 TYPE_STRING 8 TYPE_TIME 9"},{"location":"protobuf-protocol/#controlproto","title":"control.proto","text":"<p>Control</p> <p>These messages define control messages accepted by the Blueye drone.</p> <p></p>"},{"location":"protobuf-protocol/#activateguestportsctrl","title":"ActivateGuestPortsCtrl","text":"<p>Activated the guest port power</p> <p></p>"},{"location":"protobuf-protocol/#autoaltitudectrl","title":"AutoAltitudeCtrl","text":"<p>Issue a command to set auto altitude to a desired state.</p> Field Type Label Description state AutoAltitudeState State of the altitude controller <p></p>"},{"location":"protobuf-protocol/#autodepthctrl","title":"AutoDepthCtrl","text":"<p>Issue a command to set auto depth to a desired state.</p> Field Type Label Description state AutoDepthState State of the depth controller <p></p>"},{"location":"protobuf-protocol/#autoheadingctrl","title":"AutoHeadingCtrl","text":"<p>Issue a command to set auto heading to a desired state.</p> Field Type Label Description state AutoHeadingState State of the heading controller <p></p>"},{"location":"protobuf-protocol/#cancelcalibrationctrl","title":"CancelCalibrationCtrl","text":"<p>Issue a command to cancel compass calibration.</p> <p></p>"},{"location":"protobuf-protocol/#deactivateguestportsctrl","title":"DeactivateGuestPortsCtrl","text":"<p>Deactivate the guest port power</p> <p></p>"},{"location":"protobuf-protocol/#finishcalibrationctrl","title":"FinishCalibrationCtrl","text":"<p>Issue a command to finish compass calibration.</p> <p></p>"},{"location":"protobuf-protocol/#genericservoctrl","title":"GenericServoCtrl","text":"<p>Issue a command to set a generic servo value.</p> Field Type Label Description servo GenericServo Message with the desired servo value. <p></p>"},{"location":"protobuf-protocol/#gripperctrl","title":"GripperCtrl","text":"<p>Issue a command to control the gripper.</p> Field Type Label Description gripper_velocities GripperVelocities The desired gripping and rotation velocity. <p></p>"},{"location":"protobuf-protocol/#guestportlightsctrl","title":"GuestportLightsCtrl","text":"<p>Issue a command to set the guest port light intensity.</p> Field Type Label Description lights Lights Message with the desired light intensity. <p></p>"},{"location":"protobuf-protocol/#laserctrl","title":"LaserCtrl","text":"<p>Issue a command to set the laser intensity.</p> Field Type Label Description laser Laser Message with the desired laser intensity. <p></p>"},{"location":"protobuf-protocol/#lightsctrl","title":"LightsCtrl","text":"<p>Issue a command to set the main light intensity.</p> Field Type Label Description lights Lights Message with the desired light intensity. <p></p>"},{"location":"protobuf-protocol/#motioninputctrl","title":"MotionInputCtrl","text":"<p>Issue a command to move the drone in the surge, sway, heave, or yaw direction.</p> Field Type Label Description motion_input MotionInput Message with the desired movement in each direction. <p></p>"},{"location":"protobuf-protocol/#multibeamservoctrl","title":"MultibeamServoCtrl","text":"<p>Issue a command to set multibeam servo angle.</p> Field Type Label Description servo MultibeamServo Message with the desired servo angle. <p></p>"},{"location":"protobuf-protocol/#pilotgpspositionctrl","title":"PilotGPSPositionCtrl","text":"<p>Issue a command with the GPS position of the pilot.</p> Field Type Label Description position LatLongPosition The GPS position of the pilot. <p></p>"},{"location":"protobuf-protocol/#pingerconfigurationctrl","title":"PingerConfigurationCtrl","text":"<p>Issue a command to set the pinger configuration.</p> Field Type Label Description configuration PingerConfiguration Message with the pinger configuration to set. <p></p>"},{"location":"protobuf-protocol/#recordctrl","title":"RecordCtrl","text":"<p>Issue a command to start video recording.</p> Field Type Label Description record_on RecordOn Message specifying which cameras to record. <p></p>"},{"location":"protobuf-protocol/#resetodometerctrl","title":"ResetOdometerCtrl","text":"<p>Issue a command to reset the odometer.</p> <p></p>"},{"location":"protobuf-protocol/#resetpositionctrl","title":"ResetPositionCtrl","text":"<p>Issue a command to reset the position estimate.</p> Field Type Label Description settings ResetPositionSettings Reset settings. <p></p>"},{"location":"protobuf-protocol/#restartguestportsctrl","title":"RestartGuestPortsCtrl","text":"<p>Restart the guest ports by turning power on and off</p> Field Type Label Description restart_info GuestPortRestartInfo Message with information about how long to keep the guest ports off. <p></p>"},{"location":"protobuf-protocol/#setaquatrollconnectionstatusctrl","title":"SetAquaTrollConnectionStatusCtrl","text":"<p>Request to change the In-Situ Aqua Troll connection status</p> Field Type Label Description connection_status SetAquaTrollConnectionStatus Message with information about which parameter to set and the unit to set it to. <p></p>"},{"location":"protobuf-protocol/#setaquatrollparameterunitctrl","title":"SetAquaTrollParameterUnitCtrl","text":"<p>Request to set an In-Situ Aqua Troll parameter unit</p> Field Type Label Description parameter_info SetAquaTrollParameterUnit Message with information about which parameter to set and the unit to set it to. <p></p> <p></p> <p>Top</p>"},{"location":"protobuf-protocol/#startcalibrationctrl","title":"StartCalibrationCtrl","text":"<p>Issue a command to start compass calibration.</p> <p></p>"},{"location":"protobuf-protocol/#stationkeepingctrl","title":"StationKeepingCtrl","text":"<p>Issue a command to set station keeping to a desired state.</p> Field Type Label Description state StationKeepingState State of the station keeping controller <p></p>"},{"location":"protobuf-protocol/#systemtimectrl","title":"SystemTimeCtrl","text":"<p>Issue a command to set the system time on the drone.</p> Field Type Label Description system_time SystemTime Message with the system time to set. <p></p>"},{"location":"protobuf-protocol/#takepicturectrl","title":"TakePictureCtrl","text":"<p>Issue a command to take a picture.</p> <p></p>"},{"location":"protobuf-protocol/#tiltstabilizationctrl","title":"TiltStabilizationCtrl","text":"<p>Issue a command to enable or disable tilt stabilization.</p> Field Type Label Description state TiltStabilizationState Message with the tilt stabilization state to set. <p></p>"},{"location":"protobuf-protocol/#tiltvelocityctrl","title":"TiltVelocityCtrl","text":"<p>Issue a command to tilt the drone camera.</p> Field Type Label Description velocity TiltVelocity Message with the desired tilt velocity (direction and speed). <p></p>"},{"location":"protobuf-protocol/#watchdogctrl","title":"WatchdogCtrl","text":"<p>Issue a watchdog message to indicate that the remote client is connected and working as expected.</p> <p>If a watchdog message is not received every second, the drone will turn off lights and other auto functions to indicate that connection with the client has been lost.</p> Field Type Label Description connection_duration ConnectionDuration Message with the number of seconds the client has been connected. client_id uint32 The ID of the client, received in the ConnectClientRep response. <p></p>"},{"location":"protobuf-protocol/#waterdensityctrl","title":"WaterDensityCtrl","text":"<p>Issue a command to set the water density.</p> Field Type Label Description density WaterDensity Message with the water density to set. <p></p>"},{"location":"protobuf-protocol/#weathervaningctrl","title":"WeatherVaningCtrl","text":"<p>Issue a command to set station keeping with weather vaning to a desired state.</p> Field Type Label Description state WeatherVaningState State of the weather vaning controller <p></p> <p>Top</p>"},{"location":"protobuf-protocol/#message_formatsproto","title":"message_formats.proto","text":"<p>Common messages</p> <p>These are used for logging as well as building requests and responses.</p> <p></p>"},{"location":"protobuf-protocol/#altitude","title":"Altitude","text":"<p>Drone altitude over seabed, typically obtained from a DVL.</p> Field Type Label Description value float Drone altitude over seabed (m) is_valid bool If altitude is valid or not <p></p>"},{"location":"protobuf-protocol/#attitude","title":"Attitude","text":"<p>The attitude of the drone.</p> Field Type Label Description roll float Roll angle (-180\u00b0..180\u00b0) pitch float Pitch angle (-180\u00b0..180\u00b0) yaw float Yaw angle (-180\u00b0..180\u00b0) <p></p>"},{"location":"protobuf-protocol/#autoaltitudestate","title":"AutoAltitudeState","text":"<p>Auto altitude state.</p> Field Type Label Description enabled bool If auto altitude is enabled <p></p>"},{"location":"protobuf-protocol/#autodepthstate","title":"AutoDepthState","text":"<p>Auto depth state.</p> Field Type Label Description enabled bool If auto depth is enabled <p></p>"},{"location":"protobuf-protocol/#autoheadingstate","title":"AutoHeadingState","text":"<p>Auto heading state.</p> Field Type Label Description enabled bool If auto heading is enabled <p></p>"},{"location":"protobuf-protocol/#battery","title":"Battery","text":"<p>Essential battery information.</p> Field Type Label Description voltage float Battery voltage (V) level float Battery level (0..1) temperature float Battery temperature (\u00b0C) <p></p>"},{"location":"protobuf-protocol/#batterybq40z50","title":"BatteryBQ40Z50","text":"<p>Battery information message.</p> <p>Detailed information about all aspects of the connected Blueye Smart Battery, using the BQ40Z50 BMS.</p> Field Type Label Description voltage BatteryBQ40Z50.Voltage Voltage of the battery cells temperature BatteryBQ40Z50.Temperature Temperature of the battery cells status BatteryBQ40Z50.BatteryStatus Battery status flags current float Current (A) average_current float Average current (A) relative_state_of_charge float Relative state of charge (0..1) absolute_state_of_charge float Absolute state of charge (0..1) calculated_state_of_charge float Calculated state of charge (0..1) remaining_capacity float Remaining capacity (Ah) full_charge_capacity float Full charge capacity (Ah) runtime_to_empty uint32 Runtime to empty (s) average_time_to_empty uint32 Average time to empty (s) average_time_to_full uint32 Average time to full (s) charging_current float Charging current (A) charging_voltage float Charging voltage (V) cycle_count uint32 Number of charging cycles design_capacity float Design capacity (Ah) manufacture_date google.protobuf.Timestamp Manufacture date serial_number uint32 Serial number manufacturer_name string Manufacturer name device_name string Device name device_chemistry string Battery chemistry <p></p>"},{"location":"protobuf-protocol/#batterybq40z50batterystatus","title":"BatteryBQ40Z50.BatteryStatus","text":"<p>Battery status from BQ40Z50 ref data sheet 0x16.</p> Field Type Label Description overcharged_alarm bool terminate_charge_alarm bool over_temperature_alarm bool terminate_discharge_alarm bool remaining_capacity_alarm bool remaining_time_alarm bool initialization bool discharging_or_relax bool fully_charged bool fully_discharged bool error BatteryBQ40Z50.BatteryStatus.BatteryError Battery error codes <p></p>"},{"location":"protobuf-protocol/#batterybq40z50temperature","title":"BatteryBQ40Z50.Temperature","text":"<p>Battery temperature.</p> Field Type Label Description average float Average temperature accross cells (\u00b0C) cell_1 float Cell 1 temperature (\u00b0C) cell_2 float Cell 2 temperature (\u00b0C) cell_3 float Cell 3 temperature (\u00b0C) cell_4 float Cell 4 temperature (\u00b0C) <p></p>"},{"location":"protobuf-protocol/#batterybq40z50voltage","title":"BatteryBQ40Z50.Voltage","text":"<p>Battery voltage levels.</p> Field Type Label Description total float Battery pack voltage level (V) cell_1 float Cell 1 voltage level (V) cell_2 float Vell 2 voltage level (V) cell_3 float Cell 3 voltage level (V) cell_4 float Cell 4 voltage level (V) <p></p>"},{"location":"protobuf-protocol/#binlogrecord","title":"BinlogRecord","text":"<p>Wrapper message for each entry in the drone telemetry logfile.</p> <p>Each entry contains the unix timestamp in UTC, the monotonic timestamp (time since boot), and an Any message wrapping the custom Blueye message.</p> <p>See separate documentation for the logfile format for more details.</p> Field Type Label Description payload google.protobuf.Any The log entry payload. unix_timestamp google.protobuf.Timestamp Unix timestamp in UTC. clock_monotonic google.protobuf.Timestamp Posix CLOCK_MONOTONIC timestamp. <p></p>"},{"location":"protobuf-protocol/#cputemperature","title":"CPUTemperature","text":"<p>CPU temperature.</p> Field Type Label Description value float CPU temperature (\u00b0C) <p></p>"},{"location":"protobuf-protocol/#calibrationstate","title":"CalibrationState","text":"<p>Compass calibration state.</p> Field Type Label Description status CalibrationState.Status Current calibration status progress_x_positive float Progress for the positive X axis (0..1) progress_x_negative float Progress for the negative X axis (0..1) progress_y_positive float Progress for the positive Y axis (0..1) progress_y_negative float Progress for the negative X axis (0..1) progress_z_positive float Progress for the positive Z axis (0..1) progress_z_negative float Progress for the negative Z axis (0..1) progress_thruster float Progress for the thruster calibration (0..1) <p></p>"},{"location":"protobuf-protocol/#cameraparameters","title":"CameraParameters","text":"<p>Camera parameters.</p> Field Type Label Description h264_bitrate int32 Bitrate of the h264 stream (bit/sec) mjpg_bitrate int32 Bitrate of the MJPG stream used for still pictures (bit/sec) exposure int32 Shutter speed (1/10000 * s), -1 for automatic exposure white_balance int32 White balance temperature (2800..9300), -1 for automatic white balance hue int32 Hue (-40..40), 0 as default gain float Iso gain (0..1) resolution Resolution Stream, recording and image resolution framerate Framerate Stream and recording framerate camera Camera Which camera the parameters belong to. <p></p>"},{"location":"protobuf-protocol/#canisterhumidity","title":"CanisterHumidity","text":"<p>Canister humidity.</p> <p>Humidity measured in the top or bottom canister of the drone.</p> Field Type Label Description humidity float Air humidity (%) <p></p>"},{"location":"protobuf-protocol/#canistertemperature","title":"CanisterTemperature","text":"<p>Canister temperature.</p> <p>Temperature measured in the top or bottom canister of the drone.</p> Field Type Label Description temperature float Temperature (\u00b0C) <p></p>"},{"location":"protobuf-protocol/#clientinfo","title":"ClientInfo","text":"<p>Information about a remote client.</p> Field Type Label Description type string The type of client (such as Blueye App, Observer App, SDK, etc) version string Client software version string device_type string Device type, such as mobile, tablet, or computer platform string Platform, such as iOS, Android, Linux, etc platform_version string Platform software version string name string Name of the client <p></p>"},{"location":"protobuf-protocol/#connectedclient","title":"ConnectedClient","text":"<p>Information about a connected client with an id assigned by the drone.</p> Field Type Label Description client_id uint32 The assigned client id client_info ClientInfo Client information. <p></p>"},{"location":"protobuf-protocol/#connectionduration","title":"ConnectionDuration","text":"<p>Connection duration of a remote client.</p> Field Type Label Description value int32 time since connected to drone (s) <p></p>"},{"location":"protobuf-protocol/#controlforce","title":"ControlForce","text":"<p>Control Force is used for showing the requested control force in each direction in Newtons.</p> Field Type Label Description surge float Force in surge (N) sway float Force in sway (N) heave float Force in heave (N) yaw float Moment in yaw (Nm) <p></p>"},{"location":"protobuf-protocol/#controlmode","title":"ControlMode","text":"<p>Control mode from drone supervisor</p> Field Type Label Description auto_depth bool If auto depth is enabled auto_heading bool If auto heading is enabled auto_altitude bool If auto altitude is enabled station_keeping bool If station keeping is enabled weather_vaning bool If weather vaning is enabled <p></p>"},{"location":"protobuf-protocol/#controllerhealth","title":"ControllerHealth","text":"<p>Controller health is used for showing the state of the controller with an relative error and load from 0 to 1.</p> Field Type Label Description depth_error float Depth error in meters (m) depth_health float Depth controller load (0..1) heading_error float Heading error in degrees (\u00b0) heading_health float Heading controller load (0..1) <p></p>"},{"location":"protobuf-protocol/#cpprobe","title":"CpProbe","text":"<p>Reading from a Cathodic Protection Potential probe.</p> Field Type Label Description measurement float Potential measurement (V) is_measurement_valid bool Indicating if the measurement is valid <p></p>"},{"location":"protobuf-protocol/#depth","title":"Depth","text":"<p>Water depth of the drone.</p> Field Type Label Description value float Drone depth below surface (m) <p></p>"},{"location":"protobuf-protocol/#divetime","title":"DiveTime","text":"<p>Amount of time the drone has been submerged.</p> <p>The drone starts incrementing this value when the depth is above 250 mm.</p> Field Type Label Description value int32 Number of seconds the drone has been submerged <p></p>"},{"location":"protobuf-protocol/#droneinfo","title":"DroneInfo","text":"<p>Information about the drone.</p> <p>This message contains serial numbers and version information for internal components in the drone. Primarily used for diagnostics, or to determine the origin of a logfile.</p> Field Type Label Description blunux_version string Blunux version string serial_number bytes Drone serial number hardware_id bytes Main computer unique identifier model Model Drone model mb_serial bytes Motherboard serial number bb_serial bytes Backbone serial number ds_serial bytes Drone stack serial number mb_uid bytes Motherboard unique identifier bb_uid bytes Backbone unique identifier gp GuestPortInfo GuestPortInfo depth_sensor PressureSensorType Type of depth sensor that is connected to the drone <p></p>"},{"location":"protobuf-protocol/#errorflags","title":"ErrorFlags","text":"<p>Known error states for the drone.</p> Field Type Label Description pmu_comm_ack bool Acknowledge message not received for a message published to internal micro controller pmu_comm_stream bool Error in communication with internal micro controller depth_read bool Error reading depth sensor value depth_spike bool Sudden spike in value read from depth sensor inner_pressure_read bool Error reading inner pressure of the drone inner_pressure_spike bool Sudden spike in inner preassure compass_calibration bool Compass needs calibration tilt_calibration bool Error during calibration of tilt endpoints gp1_read bool Guest port 1 read error gp2_read bool Guest port 2 read error gp3_read bool Guest port 3 read error gp1_not_flashed bool Guest port 1 not flashed gp2_not_flashed bool Guest port 2 not flashed gp3_not_flashed bool Guest port 3 not flashed gp1_unknown_device bool Unknown device on guest port 1 gp2_unknown_device bool Unknown device on guest port 2 gp3_unknown_device bool Unknown device on guest port 3 gp1_device_connection bool Guest port 1 connection error gp2_device_connection bool Guest port 2 connection error gp3_device_connection bool Guest port 3 connection error gp1_device bool Guest port 1 device error gp2_device bool Guest port 2 device error gp3_device bool Guest port 3 device error drone_serial_not_set bool Drone serial number not set drone_serial bool Drone serial number error mb_eeprom_read bool MB eeprom read error bb_eeprom_read bool BB eeprom read error mb_eeprom_not_flashed bool MB eeprom not flashed bb_eeprom_not_flashed bool BB eeprom not flashed main_camera_connection bool We don't get buffers from the main camera main_camera_firmware bool The main camera firmware is wrong guestport_camera_connection bool We don't get buffers from the guestport camera guestport_camera_firmware bool The guestport camera firmware is wrong mb_serial bool MB serial number error bb_serial bool BB serial number error ds_serial bool DS serial number error gp_current_read bool Error reading GP current gp_current bool Max GP current exceeded gp1_bat_current bool Max battery current exceeded on GP1 gp2_bat_current bool Max battery current exceeded on GP2 gp3_bat_current bool Max battery current exceeded on GP3 gp_20v_current bool Max 20V current exceeded on GP <p></p>"},{"location":"protobuf-protocol/#forwarddistance","title":"ForwardDistance","text":"<p>Distance to an object infront of the drone, typically obtained from an 1D pinger.</p> Field Type Label Description value float Distance in front of drone (m) is_valid bool If distance reading is valid or not <p></p>"},{"location":"protobuf-protocol/#genericservo","title":"GenericServo","text":"<p>Servo message used to represent the angle of the servo.</p> Field Type Label Description value float Servo value (0..1) guest_port_number GuestPortNumber Guest port the servo is on <p></p>"},{"location":"protobuf-protocol/#grippervelocities","title":"GripperVelocities","text":"<p>Gripper velocity values.</p> Field Type Label Description grip_velocity float The gripping velocity (-1.0..1.0) rotate_velocity float The rotating velocity (-1.0..1.0) <p></p>"},{"location":"protobuf-protocol/#guestportconnectorinfo","title":"GuestPortConnectorInfo","text":"<p>GuestPort connector information.</p> Field Type Label Description device_list GuestPortDeviceList List of devices on this connector error GuestPortError Guest port error guest_port_number GuestPortNumber Guest port the connector is connected to <p></p>"},{"location":"protobuf-protocol/#guestportcurrent","title":"GuestPortCurrent","text":"<p>GuestPort current readings.</p> Field Type Label Description gp1_bat double Current on GP1 battery voltage (A) gp2_bat double Current on GP2 battery voltage (A) gp3_bat double Current on GP3 battery voltage (A) gp_20v double Current on common 20V supply (A) <p></p>"},{"location":"protobuf-protocol/#guestportdevice","title":"GuestPortDevice","text":"<p>GuestPort device.</p> Field Type Label Description device_id GuestPortDeviceID Blueye device identifier manufacturer string Manufacturer name name string Device name serial_number string Serial number depth_rating float Depth rating (m) required_blunux_version string Required Blunux version (x.y.z) <p></p>"},{"location":"protobuf-protocol/#guestportdevicelist","title":"GuestPortDeviceList","text":"<p>List of guest port devices.</p> Field Type Label Description devices GuestPortDevice repeated List of guest port devices <p></p>"},{"location":"protobuf-protocol/#guestportinfo","title":"GuestPortInfo","text":"<p>GuestPort information.</p> Field Type Label Description gp1 GuestPortConnectorInfo GuestPortConnectorInfo 1 gp2 GuestPortConnectorInfo GuestPortConnectorInfo 2 gp3 GuestPortConnectorInfo GuestPortConnectorInfo 3 <p></p>"},{"location":"protobuf-protocol/#guestportrestartinfo","title":"GuestPortRestartInfo","text":"<p>GuestPort restart information.</p> Field Type Label Description power_off_duration double Duration to keep the guest ports off (s) <p></p>"},{"location":"protobuf-protocol/#imu","title":"Imu","text":"<p>Imu data in drone body frame</p> <p>x - forward y - right z - down</p> Field Type Label Description accelerometer Vector3 Acceleration (g) gyroscope Vector3 Angular velocity (rad/s) magnetometer Vector3 Magnetic field (\u03bcT) temperature float Temperature (\u00b0C) <p></p>"},{"location":"protobuf-protocol/#iperfstatus","title":"IperfStatus","text":"<p>Connection speed between drone and Surface Unit.</p> Field Type Label Description sent float Transfer rate from drone to Surface Unit (Mbit/s) received float Transfer rate from Surface Unit to drone (Mbit/s) <p></p>"},{"location":"protobuf-protocol/#laser","title":"Laser","text":"<p>Laser message used to represent the intensity of connected laser.</p> <p>If the laser does not support dimming but only on and off, a value of 0 turns the laser off, and any value above 0 turns the laser on.</p> Field Type Label Description value float Laser intensity, any value above 0 turns the laser on (0..1) <p></p>"},{"location":"protobuf-protocol/#latlongposition","title":"LatLongPosition","text":"<p>Latitude and longitude position in WGS 84 decimal degrees format.</p> Field Type Label Description latitude double Latitude (\u00b0) longitude double Longitude (\u00b0) <p></p>"},{"location":"protobuf-protocol/#lights","title":"Lights","text":"<p>Lights message used to represent the intensity of the main light or external lights.</p> Field Type Label Description value float Light intensity (0..1) <p></p>"},{"location":"protobuf-protocol/#medusaspectrometerdata","title":"MedusaSpectrometerData","text":"<p>Medusa gamma ray sensor spectrometer data</p> Field Type Label Description drone_time google.protobuf.Timestamp Time stamp when the data is received sensor_time google.protobuf.Timestamp Time stamp the sensor reports realtime float Time the sensor actually measured (s) livetime float Time the measurement took (s) total uint32 Total counts inside the spectrum countrate uint32 Counts per second inside the spectrum (rounded) cosmics uint32 Detected counts above the last channel <p></p>"},{"location":"protobuf-protocol/#motioninput","title":"MotionInput","text":"<p>Motion input from client.</p> <p>Used to indicate the desired motion in each direction. Typically these values map to the left and right joystick for motion, and the left and right trigger for the slow and boost modifiers.</p> Field Type Label Description surge float Forward (positive) and backwards (negative) movement. (-1..1) sway float Right (positive) and left (negative) lateral movement (-1..1) heave float Descend (positive) and ascend (negative) movement (-1..1) yaw float Left (positive) and right (negative) movement (-1..1) slow float Multiplier used to reduce the speed of the motion (0..1) boost float Multiplier used to increase the speed of the motion (0..1) <p></p>"},{"location":"protobuf-protocol/#multibeamservo","title":"MultibeamServo","text":"<p>Servo message used to represent the angle of the servo.</p> Field Type Label Description angle float Servo degrees (-30..30) <p></p>"},{"location":"protobuf-protocol/#nstreamers","title":"NStreamers","text":"<p>Number of spectators connected to video stream.</p> Field Type Label Description main int32 The number of clients to the main camera stream guestport int32 The number of clients to the guestport camera stream <p></p>"},{"location":"protobuf-protocol/#navigationsensorstatus","title":"NavigationSensorStatus","text":"<p>Navigation sensor used in the position observer with validity state</p> Field Type Label Description sensor_id NavigationSensorID Sensor id is_valid bool Sensor validity <p></p>"},{"location":"protobuf-protocol/#overlayparameters","title":"OverlayParameters","text":"<p>Overlay parameters.</p> <p>All available parameters that can be used to configure telemetry overlay on video recordings.</p> Field Type Label Description temperature_enabled bool If temperature should be included depth_enabled bool If depth should be included heading_enabled bool If heading should be included tilt_enabled bool If camera tilt angle should be included thickness_enabled bool If camera tilt angle should be included date_enabled bool If date should be included distance_enabled bool If distance should be included altitude_enabled bool If altitude should be included cp_probe_enabled bool If cp-probe should be included medusa_enabled bool If medusa measurement should be included drone_location_enabled bool If the drone location coordinates should be included logo_type LogoType Which logo should be used depth_unit DepthUnit Which unit should be used for depth: Meter, Feet or None temperature_unit TemperatureUnit Which unit should be used for temperature: Celcius or Fahrenheit thickness_unit ThicknessUnit Which unit should be used for thickness: Millimeters or Inches timezone_offset int32 Timezone offset from UTC (min) margin_width int32 Horizontal margins of text elements (px) margin_height int32 Vertical margins of text elements (px) font_size FontSize Font size of text elements title string Optional title subtitle string Optional subtitle date_format string Posix strftime format string for time stamp shading float Pixel intensity to subtract from text background (0..1), 0: transparent, 1: black <p></p>"},{"location":"protobuf-protocol/#pingerconfiguration","title":"PingerConfiguration","text":"<p>Pinger configuration.</p> <p>Used to specify the configuration the BR 1D-Pinger.</p> Field Type Label Description mounting_direction PingerConfiguration.MountingDirection Mounting direction of the pinger <p></p>"},{"location":"protobuf-protocol/#positionestimate","title":"PositionEstimate","text":"<p>Position estimate from the Extended Kalman filter based observer if a DVL is connected.</p> Field Type Label Description northing float Position from reset point (m) easting float Position from reset point (m) heading float Gyro based heading estimate (continous radians) surge_rate float Velocity in surge (m/s) sway_rate float Velocity in sway (m/s) yaw_rate float Rotaion rate in yaw (rad/s) ocean_current float Estimated ocean current (m/s) odometer float Travelled distance since reset (m) is_valid bool If the estimate can be trusted global_position LatLongPosition Best estimate of the global position in decimal degrees navigation_sensors NavigationSensorStatus repeated List of available sensors with status <p></p>"},{"location":"protobuf-protocol/#recordon","title":"RecordOn","text":"<p>Which cameras are supposed to be recording</p> Field Type Label Description main bool Record the main camera guestport bool Record external camera <p></p>"},{"location":"protobuf-protocol/#recordstate","title":"RecordState","text":"<p>Camera recording state.</p> Field Type Label Description main_is_recording bool If the main camera is recording main_seconds int32 Main record time (s) guestport_is_recording bool If the guestport camera is recording guestport_seconds int32 Guestport record time (s) <p></p>"},{"location":"protobuf-protocol/#reference","title":"Reference","text":"<p>Reference for the control system. Note that the internal heading referece is not relative to North. Use (ControlHealth.heading_error + pose.yaw) instead.</p> Field Type Label Description surge float Reference from joystick surge input (0..1) sway float Reference from joystick sway input (0..1) heave float Reference from joystick heave input (0..1) yaw float Reference from joystick yaw input (0..1) depth float Reference drone depth below surface (m) heading float Reference used in auto heading mode, gyro based (\u00b0) altitude float Reference used in auto altitude mode (m) <p></p>"},{"location":"protobuf-protocol/#resetpositionsettings","title":"ResetPositionSettings","text":"<p>ResetPositionSettings used during reset of the position estimate.</p> Field Type Label Description heading_source_during_reset HeadingSource Option to use the drone compass or due North as heading during reset manual_heading float Heading in degrees (0-359) reset_coordinate_source ResetCoordinateSource Option to use the device GPS or a manual coordinate. reset_coordinate LatLongPosition Reset coordinate in decimal degrees <p></p>"},{"location":"protobuf-protocol/#stationkeepingstate","title":"StationKeepingState","text":"<p>Station keeping state.</p> Field Type Label Description enabled bool If station keeping is enabled <p></p>"},{"location":"protobuf-protocol/#storagespace","title":"StorageSpace","text":"<p>Storage space.</p> Field Type Label Description total_space int64 Total bytes of storage space (B) free_space int64 Available bytes of storage space (B) <p></p>"},{"location":"protobuf-protocol/#systemtime","title":"SystemTime","text":"<p>System time.</p> Field Type Label Description unix_timestamp google.protobuf.Timestamp Unix timestamp <p></p>"},{"location":"protobuf-protocol/#thicknessgauge","title":"ThicknessGauge","text":"<p>Thickness measurement data from a Cygnus Thickness Gauge.</p> Field Type Label Description thickness_measurement float Thickness measurement of a steel plate echo_count uint32 Indicating the quality of the reading when invalid (0-3) sound_velocity uint32 Speed of sound in the steel member (m/s) is_measurement_valid bool Indicating if the measurement is valid <p></p>"},{"location":"protobuf-protocol/#tiltangle","title":"TiltAngle","text":"<p>Angle of tilt camera in degrees.</p> Field Type Label Description value float Tilt angle (\u00b0) <p></p>"},{"location":"protobuf-protocol/#tiltstabilizationstate","title":"TiltStabilizationState","text":"<p>Tilt stabilization state.</p> <p>Blueye drones with mechanical tilt has the ability to enable camera stabilization.</p> Field Type Label Description enabled bool If tilt stabilization is enabled <p></p>"},{"location":"protobuf-protocol/#tiltvelocity","title":"TiltVelocity","text":"<p>Relative velocity of tilt</p> Field Type Label Description value float Relative angular velocity of tilt (-1..1), negative means down and positive means up <p></p>"},{"location":"protobuf-protocol/#vector3","title":"Vector3","text":"<p>Vector with 3 elements</p> Field Type Label Description x double x-component y double y-component z double z-component <p></p>"},{"location":"protobuf-protocol/#waterdensity","title":"WaterDensity","text":"<p>Water density.</p> <p>Used to specify the water density the drone is operating in, to achieve more accruate depth measurements.</p> Field Type Label Description value float Salinity (kg/l) <p></p>"},{"location":"protobuf-protocol/#watertemperature","title":"WaterTemperature","text":"<p>Water temperature measured by the drone's combined depth and temperature sensor.</p> Field Type Label Description value float Water temperature (\u00b0C) <p></p>"},{"location":"protobuf-protocol/#weathervaningstate","title":"WeatherVaningState","text":"<p>Weather vaning state.</p> Field Type Label Description enabled bool If weather vaning is enabled <p></p>"},{"location":"protobuf-protocol/#batterybq40z50batterystatusbatteryerror","title":"BatteryBQ40Z50.BatteryStatus.BatteryError","text":"<p>Battery errror code from BQ40Z50 BMS data sheet.</p> Name Number Description BATTERY_ERROR_UNSPECIFIED 0 BATTERY_ERROR_OK 1 BATTERY_ERROR_BUSY 2 BATTERY_ERROR_RESERVED_COMMAND 3 BATTERY_ERROR_UNSUPPORTED_COMMAND 4 BATTERY_ERROR_ACCESS_DENIED 5 BATTERY_ERROR_OVERFLOW_UNDERFLOW 6 BATTERY_ERROR_BAD_SIZE 7 BATTERY_ERROR_UNKNOWN_ERROR 8 <p></p>"},{"location":"protobuf-protocol/#calibrationstatestatus","title":"CalibrationState.Status","text":"<p>Status of the compass calibration procedure.</p> <p>When calibration is started, the status will indicate the active (upfacing) axis.</p> Name Number Description STATUS_UNSPECIFIED 0 Unspecified status STATUS_NOT_CALIBRATING 1 Compass is not currently calibrating STATUS_CALIBRATING_NO_AXIS 2 Compass is calibrating but active calibration axis cannot be determined STATUS_CALIBRATING_X_POSITIVE 3 Compass is calibrating and the positive X axis is active STATUS_CALIBRATING_X_NEGATIVE 4 Compass is calibrating and the negative X axis is active STATUS_CALIBRATING_Y_POSITIVE 5 Compass is calibrating and the positive Y axis is active STATUS_CALIBRATING_Y_NEGATIVE 6 Compass is calibrating and the negative Y axis is active STATUS_CALIBRATING_Z_POSITIVE 7 Compass is calibrating and the positive Z axis is active STATUS_CALIBRATING_Z_NEGATIVE 8 Compass is calibrating and the negative Z axis is active STATUS_CALIBRATING_THRUSTER 9 Compass is calibrating for thruster interferance <p></p>"},{"location":"protobuf-protocol/#camera","title":"Camera","text":"<p>Which camera to control.</p> Name Number Description CAMERA_UNSPECIFIED 0 Camera not specified CAMERA_MAIN 1 Main camera CAMERA_GUESTPORT 2 Guestport camera <p></p>"},{"location":"protobuf-protocol/#depthunit","title":"DepthUnit","text":"<p>Available depth units.</p> Name Number Description DEPTH_UNIT_UNSPECIFIED 0 Depth unit not specified DEPTH_UNIT_METERS 1 Depth should be displayed as meters DEPTH_UNIT_FEET 2 Depth should be displayed as feet <p></p>"},{"location":"protobuf-protocol/#fontsize","title":"FontSize","text":"<p>Available font sizes for overlay text elements.</p> Name Number Description FONT_SIZE_UNSPECIFIED 0 Font size not specified FONT_SIZE_PX15 1 15 px FONT_SIZE_PX20 2 20 px FONT_SIZE_PX25 3 25 px FONT_SIZE_PX30 4 30 px FONT_SIZE_PX35 5 35 px FONT_SIZE_PX40 6 40 px <p></p>"},{"location":"protobuf-protocol/#framerate","title":"Framerate","text":"<p>Available camera framerates.</p> Name Number Description FRAMERATE_UNSPECIFIED 0 Framerate not specified FRAMERATE_FPS_30 1 30 frames per second FRAMERATE_FPS_25 2 25 frames per second <p></p>"},{"location":"protobuf-protocol/#guestportdeviceid","title":"GuestPortDeviceID","text":"<p>GuestPort device ID.</p> Name Number Description GUEST_PORT_DEVICE_ID_UNSPECIFIED 0 Unspecified GUEST_PORT_DEVICE_ID_BLIND_PLUG 1 Blueye blind plug GUEST_PORT_DEVICE_ID_TEST_STATION 2 Blueye test station GUEST_PORT_DEVICE_ID_DEBUG_SERIAL 3 Blueye debug serial GUEST_PORT_DEVICE_ID_BLUEYE_LIGHT 4 Blueye Light GUEST_PORT_DEVICE_ID_BLUEYE_CAM 5 Blueye Cam GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_LUMEN 6 Blue Robotics Lumen GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_NEWTON 7 Blue Robotics Newton GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_PING_SONAR 8 Blue Robotics Ping Sonar GUEST_PORT_DEVICE_ID_BLUEPRINT_LAB_REACH_ALPHA 9 Blueprint Lab Reach Alpha GUEST_PORT_DEVICE_ID_WATERLINKED_DVL_A50 10 Waterlinked DVL A50 GUEST_PORT_DEVICE_ID_IMPACT_SUBSEA_ISS360 11 Impact Subsea ISS360 Sonar GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_SEATRAC_X010 12 Blueprint Subsea Seatrac X110 GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_OCULUS_M750D 13 Blueprint Subsea Oculus M750d GUEST_PORT_DEVICE_ID_CYGNUS_MINI_ROV_THICKNESS_GAUGE 14 Cygnus Mini ROV Thickness Gauge GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_PING360_SONAR 15 Blue Robotics Ping360 Scanning Imaging Sonar GUEST_PORT_DEVICE_ID_TRITECH_GEMINI_720IM 16 Tritech Gemini 720im Multibeam Sonar GUEST_PORT_DEVICE_ID_BLUEYE_LIGHT_PAIR 17 Blueye Light Pair GUEST_PORT_DEVICE_ID_TRITECH_GEMINI_MICRON 18 Tritech Micron Gemini GUEST_PORT_DEVICE_ID_OCEAN_TOOLS_DIGICP 19 Ocean Tools DigiCP GUEST_PORT_DEVICE_ID_TRITECH_GEMINI_720IK 20 Tritech Gemini 720ik Multibeam Sonar GUEST_PORT_DEVICE_ID_NORTEK_NUCLEUS_1000 21 Nortek Nucleus 1000 DVL GUEST_PORT_DEVICE_ID_BLUEYE_GENERIC_SERVO 22 Blueye Generic Servo GUEST_PORT_DEVICE_ID_BLUEYE_MULTIBEAM_SERVO 23 Blueye Multibeam Servo GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_DETACHABLE_NEWTON 24 Detachable Blue Robotics Newton GUEST_PORT_DEVICE_ID_INSITU_AQUA_TROLL_500 25 In-Situ Aqua TROLL 500 GUEST_PORT_DEVICE_ID_MEDUSA_RADIOMETRICS_MS100 26 Medusa Radiometrics Gamma Ray Sensor GUEST_PORT_DEVICE_ID_LASER_TOOLS_SEA_BEAM 27 Laser Tools Sea Beam Underwater Laser GUEST_PORT_DEVICE_ID_SPOT_X_LASER_SCALERS 28 Spot X Laser Scalers GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_OCULUS_M1200D 29 Blueprint Subsea Oculus M1200d GUEST_PORT_DEVICE_ID_BLUEPRINT_SUBSEA_OCULUS_M3000D 30 Blueprint Subsea Oculus M3000d <p></p>"},{"location":"protobuf-protocol/#guestporterror","title":"GuestPortError","text":"<p>GuestPort error.</p> Name Number Description GUEST_PORT_ERROR_UNSPECIFIED 0 Unspecified value GUEST_PORT_ERROR_NOT_CONNECTED 1 Device not connected GUEST_PORT_ERROR_READ_ERROR 2 EEPROM read error GUEST_PORT_ERROR_NOT_FLASHED 3 Connector not flashed GUEST_PORT_ERROR_CRC_ERROR 4 Wrong CRC for protobuf message GUEST_PORT_ERROR_PARSE_ERROR 5 Protobuf message cannot be parsed <p></p>"},{"location":"protobuf-protocol/#guestportnumber","title":"GuestPortNumber","text":"<p>GuestPort number.</p> Name Number Description GUEST_PORT_NUMBER_UNSPECIFIED 0 Unspecified GUEST_PORT_NUMBER_PORT_1 1 Guest port 1 GUEST_PORT_NUMBER_PORT_2 2 Guest port 2 GUEST_PORT_NUMBER_PORT_3 3 Guest port 3 <p></p>"},{"location":"protobuf-protocol/#headingsource","title":"HeadingSource","text":"<p>Heading source used during reset of the position estimate.</p> Name Number Description HEADING_SOURCE_UNSPECIFIED 0 Unspecified HEADING_SOURCE_DRONE_COMPASS 1 Uses the drone compass to set the heading HEADING_SOURCE_MANUAL_INPUT 2 Used when the user sets the heading manually <p></p>"},{"location":"protobuf-protocol/#logotype","title":"LogoType","text":"<p>Available logo types.</p> Name Number Description LOGO_TYPE_UNSPECIFIED 0 Logo type not specified LOGO_TYPE_NONE 1 Do not add any logo LOGO_TYPE_DEFAULT 2 Add default logo LOGO_TYPE_CUSTOM 3 Add user defined logo <p></p>"},{"location":"protobuf-protocol/#model","title":"Model","text":"<p>Drone models produced by Blueye</p> Name Number Description MODEL_UNSPECIFIED 0 ModelName not specified MODEL_PIONEER 1 Blueye Pioneer, the first model MODEL_PRO 2 Blueye Pro, features camera tilt MODEL_PRO2 4 Blueye Pro, features camera tilt and one guest port MODEL_X3 3 Blueye X3, features support for peripherals <p></p>"},{"location":"protobuf-protocol/#navigationsensorid","title":"NavigationSensorID","text":"<p>List of navigation sensors that can be used by the position observer</p> Name Number Description NAVIGATION_SENSOR_ID_UNSPECIFIED 0 Unspecified NAVIGATION_SENSOR_ID_WATERLINKED_DVL_A50 1 Water Linked DVL A50 NAVIGATION_SENSOR_ID_WATERLINKED_UGPS_G2 2 Water Linked UGPS G2 NAVIGATION_SENSOR_ID_NMEA 3 NMEA stream from external positioning system <p></p>"},{"location":"protobuf-protocol/#pingerconfigurationmountingdirection","title":"PingerConfiguration.MountingDirection","text":"Name Number Description MOUNTING_DIRECTION_UNSPECIFIED 0 Mounting direction is unspecified MOUNTING_DIRECTION_FORWARDS 1 Pointing forwards from the drones perspective MOUNTING_DIRECTION_DOWNWARDS 2 Pointing downwards from the drones perspective"},{"location":"protobuf-protocol/#pressuresensortype","title":"PressureSensorType","text":"<p>Depth sensors used by the drone.</p> Name Number Description PRESSURE_SENSOR_TYPE_UNSPECIFIED 0 Depth sensor type not specified PRESSURE_SENSOR_TYPE_NOT_CONNECTED 1 No se PRESSURE_SENSOR_TYPE_MS5837_30BA26 2 Thh MS5837 30BA26 pressure sensor PRESSURE_SENSOR_TYPE_KELLER_PA7LD 3 The extended depth sensor using the Keller PA7LD pressure sensor PRESSURE_SENSOR_TYPE_MS5637_02BA03 4 The internal pressure sensor using the MS5637 02BA03 pressure sensor <p></p>"},{"location":"protobuf-protocol/#resetcoordinatesource","title":"ResetCoordinateSource","text":"Name Number Description RESET_COORDINATE_SOURCE_UNSPECIFIED 0 Unspecified, fallback to device GPS RESET_COORDINATE_SOURCE_DEVICE_GPS 1 Uses the device GPS to set the reset point RESET_COORDINATE_SOURCE_MANUAL 2 Uses a coordinate in decimal degrees to set the reset point"},{"location":"protobuf-protocol/#resolution","title":"Resolution","text":"<p>Available camera resolutions.</p> Name Number Description RESOLUTION_UNSPECIFIED 0 Resolution not specified RESOLUTION_FULLHD_1080P 1 1080p Full HD resolution RESOLUTION_HD_720P 2 720p HD resolution <p></p>"},{"location":"protobuf-protocol/#temperatureunit","title":"TemperatureUnit","text":"<p>Available temperature units.</p> Name Number Description TEMPERATURE_UNIT_UNSPECIFIED 0 Temperature unit not specfied TEMPERATURE_UNIT_CELSIUS 1 Temperature should be displayed as Celcius TEMPERATURE_UNIT_FAHRENHEIT 2 Temperature should be displayed as Fahrenheit <p></p>"},{"location":"protobuf-protocol/#thicknessunit","title":"ThicknessUnit","text":"<p>Available thickness units.</p> Name Number Description THICKNESS_UNIT_UNSPECIFIED 0 Thickness unit not specified THICKNESS_UNIT_MILLIMETERS 1 Thickness should be displayed as millimeters THICKNESS_UNIT_INCHES 2 Thickness should be displayed as inches <p></p> <p>Top</p>"},{"location":"protobuf-protocol/#req_repproto","title":"req_rep.proto","text":"<p>Request reply</p> <p>These messages define request / reply messages for the Blueye drone.</p> <p></p>"},{"location":"protobuf-protocol/#connectclientrep","title":"ConnectClientRep","text":"<p>Response after connecting a client to the drone.</p> <p>Contains information about which client is in control, and a list of all connected clients.</p> Field Type Label Description client_id uint32 The assigned ID of this client. client_id_in_control uint32 The ID of the client in control of the drone. connected_clients ConnectedClient repeated List of connected clients. <p></p>"},{"location":"protobuf-protocol/#connectclientreq","title":"ConnectClientReq","text":"<p>Connect a new client to the drone.</p> Field Type Label Description client_info ClientInfo Information about the client connecting to the drone. <p></p>"},{"location":"protobuf-protocol/#disconnectclientrep","title":"DisconnectClientRep","text":"<p>Response after disconnecting a client from the drone.</p> <p>Contains information about which clients are connected and in control.</p> Field Type Label Description client_id_in_control uint32 The ID of the client in control of the drone. connected_clients ConnectedClient repeated List of connected clients. <p></p>"},{"location":"protobuf-protocol/#disconnectclientreq","title":"DisconnectClientReq","text":"<p>Disconnect a client from the drone.</p> <p>This request will remove the client from the list of connected clients. It allows clients to disconnect instantly, without waiting for a watchdog to clear the client in control, or promote a new client to be in control.</p> Field Type Label Description client_id uint32 The assigned ID of the client to disconnect. <p></p>"},{"location":"protobuf-protocol/#getbatteryrep","title":"GetBatteryRep","text":"<p>Response with essential battery information.</p> Field Type Label Description battery Battery Essential battery information. <p></p>"},{"location":"protobuf-protocol/#getbatteryreq","title":"GetBatteryReq","text":"<p>Request essential battery information.</p> <p>Can be used to instantly get battery information, instead of having to wait for the BatteryTel message to be received.</p> <p></p>"},{"location":"protobuf-protocol/#getcameraparametersrep","title":"GetCameraParametersRep","text":"<p>Response with the currently set camera parameters.</p> Field Type Label Description camera_parameters CameraParameters The currently set camera parameters. <p></p>"},{"location":"protobuf-protocol/#getcameraparametersreq","title":"GetCameraParametersReq","text":"<p>Request to get the currently set camera parameters.</p> Field Type Label Description camera Camera Which camera to read camera parameters from. <p></p>"},{"location":"protobuf-protocol/#getoverlayparametersrep","title":"GetOverlayParametersRep","text":"<p>Response with the currently set video overlay parameters.</p> Field Type Label Description overlay_parameters OverlayParameters The currently set overlay parameters. <p></p>"},{"location":"protobuf-protocol/#getoverlayparametersreq","title":"GetOverlayParametersReq","text":"<p>Request to get currently set video overlay parameters.</p> <p></p>"},{"location":"protobuf-protocol/#gettelemetryrep","title":"GetTelemetryRep","text":"<p>Response with latest telemetry</p> Field Type Label Description payload google.protobuf.Any The latest telemetry data, empty if no data available. <p></p>"},{"location":"protobuf-protocol/#gettelemetryreq","title":"GetTelemetryReq","text":"<p>Request to get latest telemetry data</p> Field Type Label Description message_type string Message name, f. ex. \"AttitudeTel\" <p></p>"},{"location":"protobuf-protocol/#pingrep","title":"PingRep","text":"<p>Response message from a PingReq request.</p> <p></p>"},{"location":"protobuf-protocol/#pingreq","title":"PingReq","text":"<p>The simplest message to use to test request/reply communication with the drone.</p> <p>The drone replies with a PingRep message immediately after receiving the PingReq.</p> <p></p>"},{"location":"protobuf-protocol/#setcameraparametersrep","title":"SetCameraParametersRep","text":"<p>Response after setting the camera parameters.</p> <p></p>"},{"location":"protobuf-protocol/#setcameraparametersreq","title":"SetCameraParametersReq","text":"<p>Request to set camera parameters.</p> Field Type Label Description camera_parameters CameraParameters The camera parameters to apply. <p></p>"},{"location":"protobuf-protocol/#setoverlayparametersrep","title":"SetOverlayParametersRep","text":"<p>Response after setting video overlay parameters.</p> <p></p>"},{"location":"protobuf-protocol/#setoverlayparametersreq","title":"SetOverlayParametersReq","text":"<p>Request to set video overlay parameters.</p> Field Type Label Description overlay_parameters OverlayParameters The video overlay parameters to apply. <p></p>"},{"location":"protobuf-protocol/#setpubfrequencyrep","title":"SetPubFrequencyRep","text":"<p>Response after updating publish frequency</p> Field Type Label Description success bool True if message name valid and frequency successfully updated. <p></p>"},{"location":"protobuf-protocol/#setpubfrequencyreq","title":"SetPubFrequencyReq","text":"<p>Request to update the publish frequency</p> Field Type Label Description message_type string Message name, f. ex. \"AttitudeTel\" frequency float Publish frequency (max 100 Hz). <p></p>"},{"location":"protobuf-protocol/#setthicknessgaugeparametersrep","title":"SetThicknessGaugeParametersRep","text":"<p>Response after setting thicknes gauge parameters.</p> <p></p>"},{"location":"protobuf-protocol/#setthicknessgaugeparametersreq","title":"SetThicknessGaugeParametersReq","text":"<p>Request to set parameters for ultrasonic thickness gauge.</p> <p>The sound velocity is used to calculate the thickness of the material being measured.</p> Field Type Label Description sound_velocity uint32 Sound velocity in m/s <p></p>"},{"location":"protobuf-protocol/#synctimerep","title":"SyncTimeRep","text":"<p>Response after setting the system time on the drone.</p> Field Type Label Description success bool If the time was set successfully. <p></p>"},{"location":"protobuf-protocol/#synctimereq","title":"SyncTimeReq","text":"<p>Request to set the system time on the drone.</p> Field Type Label Description time SystemTime The time to set on the drone. <p></p> <p>Top</p>"},{"location":"protobuf-protocol/#telemetryproto","title":"telemetry.proto","text":"<p>Telemetry</p> <p>These messages define telemetry messages from the Blueye drone.</p> <p></p>"},{"location":"protobuf-protocol/#altitudetel","title":"AltitudeTel","text":"<p>Receive the current altitude of the drone.</p> Field Type Label Description altitude Altitude The altitude of the drone. <p></p>"},{"location":"protobuf-protocol/#aquatrollprobemetadatatel","title":"AquaTrollProbeMetadataTel","text":"<p>Metadata from the In-Situ Aqua Troll probe's common registers</p> Field Type Label Description probe AquaTrollProbeMetadata AquaTroll message containing sensor array. <p></p>"},{"location":"protobuf-protocol/#aquatrollsensormetadatatel","title":"AquaTrollSensorMetadataTel","text":"<p>Metadata from a single sensor from In-Situ Aqua Troll probe</p> Field Type Label Description sensors AquaTrollSensorMetadataArray AquaTroll message containing sensor array. <p></p>"},{"location":"protobuf-protocol/#aquatrollsensorparameterstel","title":"AquaTrollSensorParametersTel","text":"<p>Single sensor from In-Situ Aqua Troll probe</p> Field Type Label Description sensors AquaTrollSensorParametersArray AquaTroll message containing parameter array. <p></p>"},{"location":"protobuf-protocol/#attitudetel","title":"AttitudeTel","text":"<p>Receive the current attitude of the drone.</p> Field Type Label Description attitude Attitude The attitude of the drone. <p></p>"},{"location":"protobuf-protocol/#batterybq40z50tel","title":"BatteryBQ40Z50Tel","text":"<p>Receive detailed information about a battery using the BQ40Z50 battery management system.</p> Field Type Label Description battery BatteryBQ40Z50 Detailed battery information. <p></p>"},{"location":"protobuf-protocol/#batterytel","title":"BatteryTel","text":"<p>Receive essential information about the battery status.</p> Field Type Label Description battery Battery Essential battery information. <p></p>"},{"location":"protobuf-protocol/#cputemperaturetel","title":"CPUTemperatureTel","text":"Field Type Label Description temperature CPUTemperature"},{"location":"protobuf-protocol/#calibratedimutel","title":"CalibratedImuTel","text":"<p>Calibrated IMU data</p> Field Type Label Description imu Imu <p></p>"},{"location":"protobuf-protocol/#calibrationstatetel","title":"CalibrationStateTel","text":"Field Type Label Description calibration_state CalibrationState"},{"location":"protobuf-protocol/#canisterbottomhumiditytel","title":"CanisterBottomHumidityTel","text":"<p>Receive humidity information from the bottom canister.</p> Field Type Label Description humidity CanisterHumidity Humidity information <p></p>"},{"location":"protobuf-protocol/#canisterbottomtemperaturetel","title":"CanisterBottomTemperatureTel","text":"<p>Receive temperature information from the bottom canister.</p> Field Type Label Description temperature CanisterTemperature Temperature information. <p></p>"},{"location":"protobuf-protocol/#canistertophumiditytel","title":"CanisterTopHumidityTel","text":"<p>Receive humidity information from the top canister.</p> Field Type Label Description humidity CanisterHumidity Humidity information <p></p>"},{"location":"protobuf-protocol/#canistertoptemperaturetel","title":"CanisterTopTemperatureTel","text":"<p>Receive temperature information from the top canister.</p> Field Type Label Description temperature CanisterTemperature Temperature information. <p></p>"},{"location":"protobuf-protocol/#connectedclientstel","title":"ConnectedClientsTel","text":"<p>List of connected clients telemetry message.</p> Field Type Label Description client_id_in_control uint32 The client id of the client in control. connected_clients ConnectedClient repeated List of connected clients. <p></p>"},{"location":"protobuf-protocol/#controlforcetel","title":"ControlForceTel","text":"Field Type Label Description control_force ControlForce"},{"location":"protobuf-protocol/#controlmodetel","title":"ControlModeTel","text":"<p>Receive the current state of the control system.</p> Field Type Label Description state ControlMode State of the control system. <p></p>"},{"location":"protobuf-protocol/#controllerhealthtel","title":"ControllerHealthTel","text":"Field Type Label Description controller_health ControllerHealth"},{"location":"protobuf-protocol/#cpprobetel","title":"CpProbeTel","text":"<p>Cathodic Protection Potential probe telemetry message</p> Field Type Label Description cp_probe CpProbe Reading from cp probe. <p></p>"},{"location":"protobuf-protocol/#datastoragespacetel","title":"DataStorageSpaceTel","text":"Field Type Label Description storage_space StorageSpace"},{"location":"protobuf-protocol/#depthtel","title":"DepthTel","text":"Field Type Label Description depth Depth"},{"location":"protobuf-protocol/#divetimetel","title":"DiveTimeTel","text":"<p>Receive the dive time of the drone.</p> Field Type Label Description dive_time DiveTime The current dive time of the drone. <p></p>"},{"location":"protobuf-protocol/#droneinfotel","title":"DroneInfoTel","text":"<p>Receive metadata and information about the connected drone.</p> Field Type Label Description drone_info DroneInfo Various metadata such as software versions and serial number. <p></p>"},{"location":"protobuf-protocol/#dronetimetel","title":"DroneTimeTel","text":"<p>Receive time information from the drone.</p> Field Type Label Description real_time_clock SystemTime The real-time clock of the drone. monotonic_clock SystemTime The monotonic clock of the drone (time since power on). <p></p>"},{"location":"protobuf-protocol/#errorflagstel","title":"ErrorFlagsTel","text":"<p>Receive currently set error flags.</p> Field Type Label Description error_flags ErrorFlags Currently set error flags on the drone. <p></p>"},{"location":"protobuf-protocol/#forwarddistancetel","title":"ForwardDistanceTel","text":"Field Type Label Description forward_distance ForwardDistance"},{"location":"protobuf-protocol/#genericservotel","title":"GenericServoTel","text":"<p>State of a generic servo</p> Field Type Label Description servo GenericServo Servo state <p></p>"},{"location":"protobuf-protocol/#guestportcurrenttel","title":"GuestPortCurrentTel","text":"<p>GuestPort current readings</p> Field Type Label Description current GuestPortCurrent <p></p>"},{"location":"protobuf-protocol/#guestportlightstel","title":"GuestPortLightsTel","text":"<p>Receive the status of any guest port lights connected to the drone.</p> Field Type Label Description lights Lights <p></p>"},{"location":"protobuf-protocol/#imu1tel","title":"Imu1Tel","text":"<p>Raw IMU data from IMU 1</p> Field Type Label Description imu Imu <p></p>"},{"location":"protobuf-protocol/#imu2tel","title":"Imu2Tel","text":"<p>Raw IMU data from IMU 2</p> Field Type Label Description imu Imu <p></p>"},{"location":"protobuf-protocol/#iperftel","title":"IperfTel","text":"Field Type Label Description status IperfStatus"},{"location":"protobuf-protocol/#lasertel","title":"LaserTel","text":"<p>Receive the status of any lasers connected to the drone.</p> Field Type Label Description laser Laser <p></p>"},{"location":"protobuf-protocol/#lightstel","title":"LightsTel","text":"<p>Receive the status of the main lights of the drone.</p> Field Type Label Description lights Lights <p></p>"},{"location":"protobuf-protocol/#medusaspectrometerdatatel","title":"MedusaSpectrometerDataTel","text":"<p>Medusa gamma ray sensor spectrometer data</p> Field Type Label Description data MedusaSpectrometerData <p></p>"},{"location":"protobuf-protocol/#multibeamservotel","title":"MultibeamServoTel","text":"<p>State of the servo installed in the multibeam</p> Field Type Label Description servo MultibeamServo Multibeam servo state <p></p>"},{"location":"protobuf-protocol/#nstreamerstel","title":"NStreamersTel","text":"Field Type Label Description n_streamers NStreamers"},{"location":"protobuf-protocol/#pilotgpspositiontel","title":"PilotGPSPositionTel","text":"Field Type Label Description position LatLongPosition"},{"location":"protobuf-protocol/#positionestimatetel","title":"PositionEstimateTel","text":"Field Type Label Description position_estimate PositionEstimate"},{"location":"protobuf-protocol/#recordstatetel","title":"RecordStateTel","text":"Field Type Label Description record_state RecordState"},{"location":"protobuf-protocol/#referencetel","title":"ReferenceTel","text":"Field Type Label Description reference Reference"},{"location":"protobuf-protocol/#thicknessgaugetel","title":"ThicknessGaugeTel","text":"<p>Thickness gauge measurement telemetry message.</p> Field Type Label Description thickness_gauge ThicknessGauge Tickness measurement with a cygnus gauge. <p></p>"},{"location":"protobuf-protocol/#tiltangletel","title":"TiltAngleTel","text":"Field Type Label Description angle TiltAngle"},{"location":"protobuf-protocol/#tiltstabilizationtel","title":"TiltStabilizationTel","text":"Field Type Label Description state TiltStabilizationState"},{"location":"protobuf-protocol/#videostoragespacetel","title":"VideoStorageSpaceTel","text":"Field Type Label Description storage_space StorageSpace"},{"location":"protobuf-protocol/#watertemperaturetel","title":"WaterTemperatureTel","text":"Field Type Label Description temperature WaterTemperature"},{"location":"protobuf-protocol/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"quick_start/","title":"Quick Start","text":""},{"location":"quick_start/#installation","title":"Installation","text":"<p>The SDK requires Python 3.8 or higher. Since many operating systems do not package the newest version of Python we recommend using <code>pyenv</code> or something similar for configuring multiple python versions on the same system. Pyenv also has the added benefit of managing your virtual environments for you, though you are of course free to use other tools for that as well.</p> <p>The instructions below show the necessary steps to get started with the SDK on a fresh install:</p> Windows <p>Install Python</p> <p>Install Python 3.8 or higher, you can find the latest python versions here. Remember to check the option \"Add Python to path\" when installing.</p> <p>Install virtualenv for managing Python versions (optional)</p> <p>Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. <pre><code># Upgrade pip version\npython -m pip install --upgrade pip\npip install virtualenv\n</code></pre></p> <p>Next, we create a virtual environment</p> <p><pre><code>cd .\\Desktop\nmkdir drone_project\ncd .\\drone_project\n# Replace \"C:\\Program Files\\Python310\\python.exe\" with the path\n# to the python version you want to use in the line below\nvirtualenv blueye_sdk_env -p \"C:\\Program Files\\Python310\\python.exe\"\n</code></pre> activate the virtual environment <pre><code>.\\blueye_sdk_env\\Scripts\\activate.bat\n</code></pre> if you are not allowed to activate the virtual environment, you might have to allow running unsigned scripts, see this link for instructions.</p> <p>Install the SDK</p> <p>Now we're ready to install the SDK, which should be as simple as</p> <pre><code>pip install blueye.sdk\n</code></pre> <p>or, if you want to include the dependencies required for running the examples shown in this documentation you should run</p> <pre><code>pip install \"blueye.sdk[examples]\"\n</code></pre> Mac OS <p>** Install the necessary Python version**</p> <p>Install pyenv, for more instructions see the pyenv-installer</p> <pre><code>curl https://pyenv.run | bash\npyenv update\n</code></pre> <p>If you want pyenv to be loaded each time you open a new terminal you can add this to your .zshrc or the equivalent for your terminal <pre><code>export PATH=\"$HOME/.pyenv/bin:$PATH\"\neval \"$(pyenv init -)\"\neval \"$(pyenv virtualenv-init -)\"\n</code></pre></p> <p>The Pyenv wiki recommends installing some additional dependencies before building Python.</p> <pre><code># optional, but recommended:\nbrew install openssl readline sqlite3 xz zlib\n</code></pre> <p>When running Mojave or higher (10.14+) you will also need to install the additional SDK headers: <pre><code>sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target /\n</code></pre> Then build Python with pyenv</p> <pre><code>pyenv install 3.10.1\n</code></pre> <p>Create a virtual environment</p> <p>Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages.</p> <p>Since we already have pyenv installed we'll use it to create a virtual environment,</p> <pre><code>pyenv virtualenv 3.10.1 blueye.sdk\npyenv activate blueye.sdk\n</code></pre> <p>Install the SDK</p> <p>Now we're ready to install the SDK, which should be as simple as.</p> <pre><code>pip install blueye.sdk\n</code></pre> <p>or, if you want to include the dependencies required for running the examples shown in this documentation you should run</p> <pre><code>pip install \"blueye.sdk[examples]\"\n</code></pre> Linux <p>These instructions are directed at Ubuntu, but the process should be similar for other distributions.</p> <p>Install the necessary Python version</p> <p>Install pyenv, for more instructions see the pyenv-installer</p> <pre><code>curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash\npyenv update\n</code></pre> <p>Install the needed dependencies for building python 3.10.1</p> <p><pre><code>apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\\nlibreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\\nxz-utils tk-dev libffi-dev liblzma-dev python-openssl\n</code></pre> Then build python with pyenv <pre><code>pyenv install 3.10.1\n</code></pre></p> <p>Create a virtual environment</p> <p>Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages.</p> <p>Since we already have pyenv installed we'll use it to create a virtual environment,</p> <pre><code>pyenv virtualenv 3.10.1 blueye.sdk\npyenv activate blueye.sdk\n</code></pre> <p>Install the SDK</p> <p>Now we're ready to install the SDK, which should be as simple as</p> <pre><code>pip install blueye.sdk\n</code></pre> <p>or, if you want to include the dependencies required for running the examples shown in this documentation you should run</p> <pre><code>pip install \"blueye.sdk[examples]\"\n</code></pre>"},{"location":"quick_start/#connect-to-the-drone","title":"Connect to the drone","text":"<p>To use the SDK your computer must be connected to the drone via the surface unit WiFi. For a how-to on turning on the drone and surface unit you can watch the quick start video.</p>"},{"location":"quick_start/#control-the-drone","title":"Control the drone","text":"<p>Most of the functionality is controlled using Python properties and we will illustrate the use of properties by showing how to control the lights:</p> <p><pre><code>import time\nfrom blueye.sdk import Drone\n\n# When the Drone object is instantiatied a connection to the drone is established\nmyDrone = Drone()\n\n# Setting the lights property to 0.1 (10 %)\nmyDrone.lights = 0.1\n\ntime.sleep(2)\n\n# We can also get the current brightness of the lights through the lights property\nprint(f\"Current light intensity: {myDrone.lights}\")\nmyDrone.lights = 0\n\n# Properties can also be used for reading telemetry data from the drone\nprint(f\"Current depth in meters: {myDrone.depth}\")\n</code></pre> For an overview of the properties that are available for controlling and reading data from the drone, go to the <code>Reference section</code> of the documentation. The valid input ranges and descriptions of the different properties can also be found there.</p> <p>Tip</p> <p>You can explore the properties of the drone interactively using an interactive python interpreter like <code>iPython</code>, install it with: <pre><code>pip install ipython\n</code></pre> By instantiating a Drone object and using the completion key (normally the <code>tab-key \u21b9</code>) you can get a interactive list of the available properties on the drone, it is then easy to try setting and getting the different properties. </p>"},{"location":"quick_start/#watching-the-video-stream","title":"Watching the video stream","text":"<p>The easiest way to open the  RTSP video stream is using <code>VLC media player</code>. Once VLC is downloaded you can start the stream like this, the RTSP URL is: <code>rtsp://192.168.1.101:8554/test</code> </p> <p>For lower latency streaming (on a PC) you can see the instructions on using <code>Gstreamer</code>, or if you just want to watch a low latency stream you can download the Blueye Observer app. (iOS / Android)</p> <p>The normal Blueye app can not be used to spectate when controlling the drone from the SDK because it will interfere with the commands sent from the SDK. The Observer app, however, is only a spectator and can be used together with the SDK.</p>"},{"location":"quick_start/#explore-the-examples","title":"Explore the examples","text":"<p>For further examples on how to use the SDK to control the drone have a look at the motion examples.</p> <p>Remember to install the example dependencies before running the examples.</p> <pre><code>pip install \"blueye.sdk[examples]\"\n</code></pre>"},{"location":"quick_start/#local-documentation","title":"Local documentation","text":"<p>Since the drone surface unit (usually) does not have internet access it can be a bit tricky to reference this documentation while developing on the drone. Luckily when you install the SDK from PyPI it includes a pre-built, local copy of this documentation. This documentation can be viewed by executing the following Python snippet:</p> <pre><code>import blueye.sdk\n\nblueye.sdk.open_local_documentation()\n</code></pre>"},{"location":"telemetry-callback/","title":"Subscribing to a telemetry message","text":"<p>The drone publishes all of its telemetry data as protobuf encoded messages transmitted via a ZeroMQ socket. You can find the protobuf message definitions in the Protocol Definitions repository, and the generated python definitions are located in the blueye.protocol repository.</p>"},{"location":"telemetry-callback/#adding-a-callback","title":"Adding a callback","text":"<p>To add a callback we need to use the <code>add_msg_callback</code> function, and provide it with a list of telemetry messages types we want it to trigger on, as well as a function handle to call. All available telemetry messages can be found in telemetry.proto</p>"},{"location":"telemetry-callback/#removing-a-callback","title":"Removing a callback","text":"<p>A callback is removed with <code>remove_msg_callback</code> using the ID returned when creating the callback.</p>"},{"location":"telemetry-callback/#adjusting-the-publishing-frequency-of-a-telemetry-message","title":"Adjusting the publishing frequency of a telemetry message","text":"<p>By using the <code>set_msg_publish_frequency</code> function we can alter how often the drone should publish the specified telemetry message. The valid frequency range is 0 to 100 Hz.</p>"},{"location":"telemetry-callback/#example","title":"Example","text":"<p>The following example illustrates how can use a callback to print the depth reported by the drone.</p> <pre><code>\"\"\"print_depth.py\n\nThis example program demonstrates how one can add a callback function to a telemetry message, as\nwell as how to adjust the frequency of that telemetry message, and how to remove the callback.\n\"\"\"\nimport time\n\nimport blueye.protocol as bp\n\nfrom blueye.sdk import Drone\n\n\ndef callback_depth(msg_type: str, msg: bp.DepthTel):\n\"\"\"Callback for the depth telemetry message\n\n    This function is called once for every DepthTel message received by the telemetry watcher\n    \"\"\"\n    print(f\"Got a {msg_type} message with depth: {msg.depth.value:.3f}\")\n\n\nif __name__ == \"__main__\":\n    # Instantiate a drone object\n    my_drone = Drone()\n\n    # Add a callback for the DepthTel message, storing the ID for later use\n    callback_id = my_drone.telemetry.add_msg_callback([bp.DepthTel], callback_depth)\n\n    # Adjust the publishing frequency to 5 Hz\n    my_drone.telemetry.set_msg_publish_frequency(bp.DepthTel, 5)\n\n    # Callback is triggered by a separate thread while we sleep here\n    time.sleep(5)\n\n    # Remove the callback using the ID we stored when it was created (not really necessary here\n    # since the my_drone object goes out of scope immediately afterwards)\n    my_drone.telemetry.remove_msg_callback(callback_id)\n</code></pre>"},{"location":"logs/legacy-log-file-format/","title":"Legacy log file format","text":"<p>This page describes the legacy log file format. Blunux v3.0 introduced a new logfile format, and no longer logs telemetry in this format. See Plotting for an example on how to use the new format.</p> <p>The log files from the Blueye drones are in essence a recording of the data that is published over UDP stored as a comma-separated-value (CSV) file.</p> <p>The rest of this page documents the most useful fields of the log files. The column indices listed are zero-based. If you feel that some fields need more documentation, feel free to open an issue on Github, and we'll happily supply the requested information.</p>"},{"location":"logs/legacy-log-file-format/#time","title":"Time","text":"Column Type Unit Description 2 Integer Milliseconds The elapsed time since the start of the log 3 Float Unix timestamp Global time"},{"location":"logs/legacy-log-file-format/#position","title":"Position","text":"<p>The position is based on the user's phone's GPS at the start of the dive.</p> Column Type Unit Description 6 Float Degrees Latitude 7 Float Degrees Longitude"},{"location":"logs/legacy-log-file-format/#file-storage","title":"File storage","text":"Column Type Unit Description 8 Integer Bytes Total file storage on the drone 9 Integer Bytes Available free space"},{"location":"logs/legacy-log-file-format/#temperature","title":"Temperature","text":"<p>Note: All temperatures are in \"deci-degrees Celsius\", ie. to get \u00b0C you need to divide the value by 10.</p> Column Type Unit Description 11 Integer Deci-Celsius Bottom canister temperature 12 Integer Deci-Celsius Water temperature 13 Integer Deci-Celsius Top canister temperature 14 Integer Deci-Celsius CPU temperature"},{"location":"logs/legacy-log-file-format/#internal-humidity","title":"Internal humidity","text":"<p>Note: The unit is in deci-percent (ie. divide by 10 to get percent).</p> Column Type Unit Description 15 Integer Deci-percent Humidity in the top canister. 16 Integer Deci-percent Humidity in the bottom canister."},{"location":"logs/legacy-log-file-format/#lights","title":"Lights","text":"Column Type Unit Description 17 Integer - State of the on-board light. Range is 0 to 255."},{"location":"logs/legacy-log-file-format/#depth","title":"Depth","text":"Column Type Unit Description 22 Integer Milli-meters Depth below water surface. Positive values are below the surface, negative are above."},{"location":"logs/legacy-log-file-format/#control-force","title":"Control force","text":"<p>Control force is the force exerted on the drone by the control system.</p> Column Type Unit Description 29 Float Newton Force in the surge direction. 30 Float Newton Force in the sway direction. 31 Float Newton Force in the heave direction. 32 Float Newton-meters Moment in the yaw direction."},{"location":"logs/legacy-log-file-format/#orientation-pose","title":"Orientation (pose)","text":"Column Type Unit Description 32 Float Degrees Roll angle. Range from -180\u00b0 - 180\u00b0 33 Float Degrees Pitch angle. Range from -180\u00b0 - 180\u00b0 34 Float Degrees Yaw angle. Range from -180\u00b0 - 180\u00b0"},{"location":"logs/legacy-log-file-format/#battery","title":"Battery","text":"Column Type Unit Description 38 Integer Milli-volts Battery voltage 39 Integer Milli-amperes Battery current. Negative values are drained from the battery, positive are charged. 41 Integer Percent Relative state of charge. Range from 0 - 100 %"},{"location":"logs/listing-and-downloading/","title":"Logs from the drone","text":"<p>When the drone is powered on a new log file is created, where it stores telemetry data such as depth, temperature, and more, is created. The drone will log data as long as it is powered on. These files can be downloaded to your local system where you can plot them or use them however you see fit.</p> <p>Blunux v3.0 introduced a a modern binary log format to replace the older CSV-based logs. This updated format employs gzip compression and Google's Protocol Buffers (Protobuf) for serialization. Gzip compression reduces log file sizes, optimizing storage and data transfer. The integration of Protobuf streamlines log parsing and analysis, offering more efficient data handling.</p> <p>Every entry in the binary log is a BinlogRecord Protobuf message, which in turn contains a unix timestamp in UTC, the monotonic timestamp (time since boot), and an Any message wrapping the Blueye telemetry message. The telemetry messages are documented in the telemetry proto.</p>"},{"location":"logs/listing-and-downloading/#listing-the-log-files","title":"Listing the log files","text":"<p>If your drone has completed 5 dives and you do</p> Binary logsLegacy logs <pre><code>from blueye.sdk import Drone\nmyDrone = Drone()\nprint(myDrone.logs)\n</code></pre> <pre><code>from blueye.sdk import Drone\nmyDrone = Drone()\nprint(myDrone.legacy_logs)\n</code></pre> <p>you should see something like the following lines be printed</p> Binary logsLegacy logs <p><pre><code>Name                                Time                Max depth    Size\nBYEDP000000_ea9ac92e1817a1d4_00000  07. Aug 2023 12:10  7 m          217.1 KiB\nBYEDP000000_ea9ac92e1817a1d4_00001  08. Aug 2023 12:35  20 m         1.6 MiB\nBYEDP000000_ea9ac92e1817a1d4_00002  09. Aug 2023 14:20  100 m        3.8 MiB\nBYEDP000000_ea9ac92e1817a1d4_00003  10. Aug 2023 09:15  200 m        6.5 MiB\nBYEDP000000_ea9ac92e1817a1d4_00004  11. Aug 2023 15:01  300 m        10.2 MiB\n</code></pre> The first part of the filename (the part before the _) is the serial number of your drone, the second part is the unique ID of the drone, and the third part is the dive number. In addition we see the start time of the dive, the maximum depth reached, as well as the size of the log file.</p> <p>Max depth is rounded down to the nearest meter for dives up to 10 meters, rounded down to the nearest 10 meters for dives up to 100 meters, and rounded down to the nearest 100 meters for deeper dives.</p> <pre><code>Name                        Time                Max depth  Size\nea9add4d40f69d4-00000.csv   24. Oct 2018 09:40  21.05 m    6.3 MiB\nea9add4d40f69d4-00001.csv   25. Oct 2018 10:29  21.06 m    879.2 KiB\nea9add4d40f69d4-00002.csv   31. Oct 2018 10:05  60.69 m    8.5 MiB\nea9add4d40f69d4-00003.csv   31. Oct 2018 12:13  41.68 m    8.4 MiB\nea9add4d40f69d4-00004.csv   02. Nov 2018 08:59  52.52 m    7.8 MiB\n</code></pre> <p>The first part of the filename (the part before the -) is the unique ID of your drone and second part is the dive number. In addition we see the start time of the dive, the maximum depth reached, as well as the size of the log file.</p> <p>The drone will by default filter out logs with a max depth below 20 cm. If you wish to list all logs you can do so by manually refreshing the log index with the <code>get_all_logs</code> parameter set to to <code>True</code>.</p> <pre><code>myDrone.legacy_logs.refresh_log_index(get_all_logs=True)\n</code></pre>"},{"location":"logs/listing-and-downloading/#selecting-a-log-file","title":"Selecting a log file","text":"<p>There are multiple ways to select a log file from the logs index, here are some examples showing how to select by index, by name, and by slice.</p> <p>By index</p> Binary logsLegacy logs <pre><code>first_log: LogFile = myDrone.logs[0]\nlast_log: LogFile = myDrone.logs[-1]\n</code></pre> <pre><code>first_log: LegacyLogFile = myDrone.legacy_logs[0]\nlast_log: LegacyLogFile = myDrone.legacy_logs[-1]\n</code></pre> <p>By name</p> Binary logsLegacy logs <pre><code>log: LogFile = myDrone.logs[\"BYEDP000000_ea9ac92e1817a1d4_00000\"]\n</code></pre> <pre><code>log: LegacyLogFile = myDrone.legacy_logs[\"ea9add4d40f69d4-00000.csv\"]\n</code></pre> <p>By slice</p> Binary logsLegacy logs <pre><code>first_three_logs: Logs = myDrone.logs[:3]\nevery_other_log: Logs = myDrone.logs[::2]\n</code></pre> <pre><code>first_three_logs: List[LegacyLogFile] = myDrone.legacy_logs[:3]\nevery_other_log: List[LegacyLogFile] = myDrone.legacy_logs[::2]\n</code></pre>"},{"location":"logs/listing-and-downloading/#downloading-a-log-file-to-your-computer","title":"Downloading a log file to your computer","text":"<p>When you want to download a log file all you have to do is to call the <code>download()</code> method on the desired log and the file will be downloaded to your current folder.</p> <p>Following are some examples of how one can download log files.</p> <p>Downloading a single log file</p> Binary logsLegacy logs <p>The following will download the first log with its default name to the current folder: <pre><code>myDrone.logs[0].download()\n</code></pre></p> <p>If we wish to specify the name/path of the log file we can use the optional <code>output_path</code> parameter: <pre><code>myDrone.logs[0].download(output_path=\"/tmp/my_log.bez\")\n</code></pre></p> <p><pre><code>myDrone.legacy_logs[0].download()\n</code></pre> The <code>download()</code> method takes two optional parameters, <code>output_path</code> and <code>output_name</code>. These specify, respectively, which folder the log is downloaded to and what name it's stored with. So if we want to download the first log to the folder <code>/tmp</code> and name it <code>my_log</code> we can do</p> <pre><code>myDrone.legacy_logs[0].download(output_path=\"/tmp\", output_name=\"my_log\")\n</code></pre> <p>Downloading multiple log files</p> <p>Downloading multiple log files is solved by a simple Python for-loop. The example below shows how one can download the last 3 logs to the current folder:</p> Binary logsLegacy logs <pre><code>for log in myDrone.logs[:-3]:\n    log.download()\n</code></pre> <pre><code>for log in myDrone.legacy_logs[:-3]:\n    log.download()\n</code></pre> <p>Adding a prefix to log names</p> <p>The example code below shows how one can add a simple prefix to all log files when downloading:</p> Binary logsLegacy logs <pre><code>prefix = \"pre_\"\nfor log in myDrone.logs:\n    log.download(output_path=prefix+log.name+\".bez\")\n</code></pre> <pre><code>prefix = \"pre_\"\nfor log in myDrone.logs:\n    log.download(output_name=prefix+log.name)\n</code></pre>"},{"location":"logs/plotting/","title":"Plotting","text":"<p>This example shows how one can pull a log file from the drone and use pandas and matplotlib to plot it.</p> Binary logsLegacy Logs <p>We'll start by downloading a log file from the drone</p> <pre><code>from blueye.sdk import Drone\n\nmyDrone = Drone()\nlog = myDrone.logs[0]\n</code></pre> <p>Next we'll parse the log to a stream and create a pandas dataframe from the records. We'll also specify the column names to make it easier to work with the dataframe later.</p> <pre><code>import pandas as pd\nimport blueye.protocol as bp\n\ncolumns = [\"rt\", \"delta\", \"meta\", \"message\"]\nlog_stream = log.parse_to_stream()\ndivelog = pd.DataFrame.from_records(log_stream, columns=columns)\n</code></pre> <p>We'll now filter out all entries that are not depth telemetry messages and messages that were logged before the start of the dive.</p> <pre><code>depth_log = divelog[divelog.meta == bp.DepthTel]\ndepth_log = depth_log[depth_log.rt &gt; log.start_time]\n</code></pre> <p>We can now extract the depth value from the remaining entries</p> <pre><code>depth_log[\"depth\"] = depth_log[\"message\"].apply(lambda x: x.depth.value)\n</code></pre> <p>We'll prepare our axes for plotting</p> <pre><code>x = depth_log[\"rt\"]\ny = depth_log[\"depth\"]\n</code></pre> <p>We'll start by downloading a log file from the drone</p> <pre><code>from blueye.sdk import Drone\n\nmyDrone = Drone()\nmyDrone.legacy_logs[0].download(output_name=\"log0.csv\")\n</code></pre> <p>We can now read the csv-file into a pandas object for easy manipulation</p> <pre><code>import pandas as pd\n\ndivelog = pd.read_csv(\"log0.csv\")\n</code></pre> <p>and then we'll convert the unix timestamp in <code>rt_clock</code> into a more readable format:</p> <pre><code>divelog[\"rt_clock\"] = pandas.to_datetime(divelog[\"rt_clock\"], unit=\"s\")\n</code></pre> <p>We'll prepare our axes for plotting</p> <pre><code>x = divelog[\"rt_clock\"]\ny = divelog[\"depth\"] / 1000  # Dividing by 1000 to get depth in meters\n</code></pre> <p>Next we will plot depth vs time with matplotlib: <pre><code>import matplotlib.pyplot as plt\n\n# Instantiate our figure and axes to plot on\nfigure, axes = plt.subplots()\n\n# Plot the depth values against time\naxes.plot(x, y, label=\"depth\")\n\n# Set title, labels, and legend\nplt.title(\"Depth chart\")\nplt.xlabel(\"Time\")\nplt.ylabel(\"Depth [m]\")\nplt.legend()\n\n# Save the figure\nfigure.savefig(\"depth_plot.svg\")\n</code></pre></p> <p>This should yield us a plot that looks something like this: </p> <p>See the matplotlib documentation for more ways to plot your data.</p>"},{"location":"logs/runtime-logs/","title":"Log statements from the blueye.sdk","text":"<p>The <code>blueye.sdk</code> package uses the standard Python logging module to log information about the SDK's operation. The log statements are useful for debugging and troubleshooting, and can be used to get a better understanding of what is happening inside the SDK.</p> <p>Note: These logs must not be confused with the divelogs that are generated and stored on the drone. See Listing and downloading logfiles for instructions on how to get the divelogs.</p> <p>Events with severity <code>WARNING</code> or greater are printed to <code>sys.stderr</code> by default, but can be configured to be written to a file or sent to a remote server. See the Python logging documentation for more information about how to configure the logging module.</p>"},{"location":"logs/runtime-logs/#enabling-logging-with-lower-severity","title":"Enabling logging with lower severity","text":"<p>By default, the events with severity lower than <code>WARNING</code> are muted. To enable them, you need to configure the logger to capture the logs. Here's an example of how to enable debug logs:</p> <pre><code>import logging\nimport blueye.sdk\n\ndef enable_debug_logs():\n    # Set the logger configuration\n    logger = logging.getLogger(blueye.sdk.__name__)\n    logger.setLevel(logging.DEBUG)\n\n    # Define the log handler\n    handler = logging.StreamHandler()\n    handler.setLevel(logging.DEBUG)\n\n    # Define the log format\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n    handler.setFormatter(formatter)\n\n    # Add the log handler to the logger\n    logger.addHandler(handler)\n</code></pre> <p>In the example above, we import the necessary modules and create a function <code>enable_runtime_logs()</code> to enable the runtime logs. We configure the logger to capture logs with the <code>logging.getLogger(blueye.sdk.__name__)</code> statement and set the log level to <code>DEBUG</code> to capture all logs.</p> <p>We also define a log handler to determine where the logs should be outputted. In this example, we use a <code>logging.StreamHandler()</code> to print the logs to the console. You can customize the log handler based on your requirements, such as writing logs to a file or sending them to a remote server.</p> <p>Finally, we set the log format using <code>logging.Formatter()</code> and add the log handler to the logger using <code>logger.addHandler(handler)</code>.</p>"},{"location":"logs/runtime-logs/#disabling-logging","title":"Disabling Logging","text":"<p>If you want to completely disable logging and prevent any logs from being captured, you can use a <code>NullHandler</code>. Here's an example:</p> <pre><code>import logging\nimport blueye.sdk\n\ndef disable_logging():\n    # Disable all logging\n    logger = logging.getLogger(blueye.sdk.__name__)\n    logger.addHandler(logging.NullHandler())\n</code></pre> <p>In the example above, we define a function <code>disable_logging()</code> that sets a <code>NullHandler</code> to the logger. The <code>NullHandler</code> is a special handler that essentially discards all log records, effectively disabling logging.</p>"},{"location":"movement/from-the-CLI/","title":"Controlling from the Command Line Interface","text":"<p>This is a super simple example showing how you make the drone move from the command line interface:</p> <pre><code>import time\nfrom blueye.sdk import Drone\nmyDrone = Drone()\nmyDrone.motion.surge = 0.4\ntime.sleep(1)\nmyDrone.motion.surge = 0\n</code></pre>"},{"location":"movement/with-a-gamepad/","title":"Controlling the drone from a gamepad","text":"<p>To run the example remember to first install the optional dependencies needed for running the examples <pre><code>pip install \"blueye.sdk[examples]\"\n</code></pre></p> <p>The example below illustrates how one could use an Xbox controller and the SDK to control the drone.</p> <p>The inputs library supports many other gamepads, so using a different controller should be as simple as looking up the event codes for the buttons/axes and mapping them to the functions you want.</p> <pre><code>import inputs\n\nfrom blueye.sdk import Drone\n\n\nclass JoystickHandler:\n\"\"\"Maps drone functions to joystick events\"\"\"\n\n    def __init__(self, drone):\n        self.drone = drone\n        self.event_to_function_map = {\n            \"BTN_NORTH\": self.handle_x_button,\n            \"BTN_WEST\": self.handle_y_button,\n            \"BTN_EAST\": self.handle_b_button,\n            \"BTN_SOUTH\": self.handle_a_button,\n            \"ABS_X\": self.handle_left_x_axis,\n            \"ABS_Y\": self.handle_left_y_axis,\n            \"ABS_Z\": self.handle_left_trigger,\n            \"ABS_RX\": self.handle_right_x_axis,\n            \"ABS_RY\": self.handle_right_y_axis,\n            \"ABS_RZ\": self.handle_right_trigger,\n        }\n\n    def handle_x_button(self, value):\n\"\"\"Starts/stops the video recording\"\"\"\n        self.drone.camera.is_recording = value\n\n    def handle_y_button(self, value):\n\"\"\"Turns lights on or off\"\"\"\n        if value:\n            if self.drone.lights &gt; 0:\n                self.drone.lights = 0\n            else:\n                self.drone.lights = 0.1\n\n    def handle_b_button(self, value):\n\"\"\"Toggles autoheading\"\"\"\n        if value:\n            self.drone.motion.auto_heading_active = not self.drone.motion.auto_heading_active\n\n    def handle_a_button(self, value):\n\"\"\"Toggles autodepth\"\"\"\n        if value:\n            self.drone.motion.auto_depth_active = not self.drone.motion.auto_depth_active\n\n    def filter_and_normalize(self, value, lower=5000, upper=32768):\n\"\"\"Normalizing the joystick axis range from (default) -32768&lt;-&gt;32678 to -1&lt;-&gt;1\n\n        The sticks also tend to not stop at 0 when you let them go but rather some\n        low value, so we'll filter those out as well.\n        \"\"\"\n        if -lower &lt; value &lt; lower:\n            return 0\n        elif lower &lt;= value &lt;= upper:\n            return (value - lower) / (upper - lower)\n        elif -upper &lt;= value &lt;= -lower:\n            return (value + lower) / (upper - lower)\n        else:\n            return 0\n\n    def handle_left_x_axis(self, value):\n        self.drone.motion.yaw = self.filter_and_normalize(value)\n\n    def handle_left_y_axis(self, value):\n        self.drone.motion.heave = self.filter_and_normalize(value)\n\n    def handle_right_x_axis(self, value):\n        self.drone.motion.sway = self.filter_and_normalize(value)\n\n    def handle_right_y_axis(self, value):\n        self.drone.motion.surge = -self.filter_and_normalize(value)\n\n    def handle_left_trigger(self, value):\n        self.drone.motion.slow = self.filter_and_normalize(value, lower=0, upper=255)\n\n    def handle_right_trigger(self, value):\n        self.drone.motion.boost = self.filter_and_normalize(value, lower=0, upper=255)\n\n\nif __name__ == \"__main__\":\n    try:\n        myDrone = Drone()\n        handler = JoystickHandler(myDrone)\n        while True:\n            events = inputs.get_gamepad()\n            for event in events:\n                if event.code in handler.event_to_function_map:\n                    handler.event_to_function_map[event.code](event.state)\n\n    except KeyboardInterrupt:\n        pass\n</code></pre>"},{"location":"reference/blueye/sdk/battery/","title":"Module blueye.sdk.battery","text":"View Source <pre><code>from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Optional\n\nimport blueye.protocol\n\n# Necessary to avoid cyclic imports\n\nif TYPE_CHECKING:\n\n    from .drone import Drone\n\nclass Battery:\n\n    def __init__(self, parent_drone: Drone):\n\n        self._parent_drone = parent_drone\n\n    @property\n\n    def state_of_charge(self) -&gt; Optional[float]:\n\n        \"\"\"Get the battery state of charge\n\n        *Returns*:\n\n        * Current state of charge of the drone battery (0..1)\n\n        \"\"\"\n\n        battery_tel = self._parent_drone.telemetry.get(blueye.protocol.BatteryTel)\n\n        if battery_tel is not None:\n\n            return battery_tel.battery.level\n\n        else:\n\n            return None\n</code></pre>"},{"location":"reference/blueye/sdk/battery/#variables","title":"Variables","text":"<pre><code>TYPE_CHECKING\n</code></pre>"},{"location":"reference/blueye/sdk/battery/#classes","title":"Classes","text":""},{"location":"reference/blueye/sdk/battery/#battery","title":"Battery","text":"<pre><code>class Battery(\n    parent_drone: 'Drone'\n)\n</code></pre> View Source <pre><code>class Battery:\n\n    def __init__(self, parent_drone: Drone):\n\n        self._parent_drone = parent_drone\n\n    @property\n\n    def state_of_charge(self) -&gt; Optional[float]:\n\n        \"\"\"Get the battery state of charge\n\n        *Returns*:\n\n        * Current state of charge of the drone battery (0..1)\n\n        \"\"\"\n\n        battery_tel = self._parent_drone.telemetry.get(blueye.protocol.BatteryTel)\n\n        if battery_tel is not None:\n\n            return battery_tel.battery.level\n\n        else:\n\n            return None\n</code></pre>"},{"location":"reference/blueye/sdk/battery/#instance-variables","title":"Instance variables","text":"<pre><code>state_of_charge\n</code></pre> <p>Get the battery state of charge</p> <p>Returns:</p> <ul> <li>Current state of charge of the drone battery (0..1)</li> </ul>"},{"location":"reference/blueye/sdk/camera/","title":"Module blueye.sdk.camera","text":"View Source <pre><code>from __future__ import annotations\n\nimport logging\n\nimport re\n\nimport warnings\n\nfrom typing import TYPE_CHECKING, Optional\n\nimport blueye.protocol\n\nimport requests\n\n# Necessary to avoid cyclic imports\n\nif TYPE_CHECKING:\n\n    from .drone import Drone\n\nlogger = logging.getLogger(__name__)\n\nclass Tilt:\n\n    def __init__(self, parent_drone: Drone):\n\n        self._parent_drone = parent_drone\n\n    def _verify_tilt_in_features(self):\n\n        \"\"\"Checks that the connected drone has the tilt feature\n\n        Raises a RuntimeError if it does not.\n\n        \"\"\"\n\n        if \"tilt\" not in self._parent_drone.features:\n\n            raise RuntimeError(\"The connected drone does not support tilting the camera.\")\n\n    def set_velocity(self, velocity: float):\n\n        \"\"\"Set the speed and direction of the camera tilt\n\n        *Arguments*:\n\n        * velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down.\n\n        Raises a RuntimeError if the connected drone does not have the tilt option\n\n        \"\"\"\n\n        self._verify_tilt_in_features()\n\n        self._parent_drone._ctrl_client.set_tilt_velocity(velocity)\n\n    @property\n\n    def angle(self) -&gt; Optional[float]:\n\n        \"\"\"Return the current angle of the camera tilt\n\n        Raises a RuntimeError if the connected drone does not have the tilt option\n\n        \"\"\"\n\n        self._verify_tilt_in_features()\n\n        tilt_angle_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltAngleTel)\n\n        if tilt_angle_tel is not None:\n\n            return tilt_angle_tel.angle.value\n\n        else:\n\n            return None\n\n    @property\n\n    def stabilization_enabled(self) -&gt; Optional[bool]:\n\n        \"\"\"Get or set the state of active camera stabilization\n\n        *Arguments*:\n\n        * enabled (bool): True to turn stabilization on, False to turn it off\n\n        *Returns*:\n\n        * enabled (bool): Current state of active camera stabilization\n\n        \"\"\"\n\n        self._verify_tilt_in_features()\n\n        tilt_stab_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltStabilizationTel)\n\n        if tilt_stab_tel is not None:\n\n            return tilt_stab_tel.state.enabled\n\n        else:\n\n            return None\n\n    @stabilization_enabled.setter\n\n    def stabilization_enabled(self, enabled: bool):\n\n        self._verify_tilt_in_features()\n\n        self._parent_drone._ctrl_client.set_tilt_stabilization(enabled)\n\nclass Overlay:\n\n    \"\"\"Control the overlay on videos and pictures\"\"\"\n\n    def __init__(self, parent_drone: Drone):\n\n        self._parent_drone = parent_drone\n\n        self._overlay_parametres = None\n\n    def _update_overlay_parameters(self):\n\n        self._overlay_parametres = self._parent_drone._req_rep_client.get_overlay_parameters()\n\n    @property\n\n    def temperature_enabled(self) -&gt; bool:\n\n        \"\"\"Get or set the state of the temperature overlay\"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.temperature_enabled\n\n    @temperature_enabled.setter\n\n    def temperature_enabled(self, enable_temperature: bool):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.temperature_enabled = enable_temperature\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def depth_enabled(self) -&gt; bool:\n\n        \"\"\"Get or set the state of the depth overlay\"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.depth_enabled\n\n    @depth_enabled.setter\n\n    def depth_enabled(self, enable_depth: bool):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.depth_enabled = enable_depth\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def heading_enabled(self) -&gt; bool:\n\n        \"\"\"Get or set the state of the heading overlay\"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.heading_enabled\n\n    @heading_enabled.setter\n\n    def heading_enabled(self, enable_heading: bool):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.heading_enabled = enable_heading\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def tilt_enabled(self) -&gt; bool:\n\n        \"\"\"Get or set the state of the tilt overlay\"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.tilt_enabled\n\n    @tilt_enabled.setter\n\n    def tilt_enabled(self, enable_tilt: bool):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.tilt_enabled = enable_tilt\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def date_enabled(self) -&gt; bool:\n\n        \"\"\"Get or set the state of the date overlay\"\"\"\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        return self._overlay_parametres.date_enabled\n\n    @date_enabled.setter\n\n    def date_enabled(self, enable_date: bool):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.date_enabled = enable_date\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def logo(self) -&gt; blueye.protcol.LogoType:\n\n        \"\"\"Get or set logo overlay selection\n\n        Needs to be set to an instance of the `blueye.protocol.LogoType` enum, if not a\n\n        RuntimeWarning is raised.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.logo_type\n\n    @logo.setter\n\n    def logo(self, logo_type: blueye.protocol.LogoType):\n\n        if not isinstance(logo_type, blueye.protocol.LogoType):\n\n            warnings.warn(\"Invalid logo type, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.logo_type = logo_type\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def depth_unit(self) -&gt; blueye.protocol.DepthUnit:\n\n        \"\"\"Get or set the depth unit for the overlay\n\n        Needs to be set to an instance of the `blueye.protocol.DepthUnit` enum, if not a\n\n        RuntimeWarning is raised.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.depth_unit\n\n    @depth_unit.setter\n\n    def depth_unit(self, unit: blueye.protocol.DepthUnit):\n\n        if not isinstance(unit, blueye.protocol.DepthUnit):\n\n            warnings.warn(\"Invalid depth unit, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.depth_unit = unit\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def temperature_unit(self) -&gt; blueye.protocol.TemperatureUnit:\n\n        \"\"\"Get or set the temperature unit for the overlay\n\n        Needs to be set to an instance of the `blueye.protocol.TemperatureUnit` enum, if not a\n\n        RuntimeWarning is raised.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.temperature_unit\n\n    @temperature_unit.setter\n\n    def temperature_unit(self, unit: blueye.protocol.TemperatureUnit):\n\n        if not isinstance(unit, blueye.protocol.TemperatureUnit):\n\n            warnings.warn(\"Invalid temperature unit, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.temperature_unit = unit\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def timezone_offset(self) -&gt; int:\n\n        \"\"\"Get or set the timezone offset for the overlay\n\n        Set to the number of minutes (either positive or negative) the timestamp should be offset.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.timezone_offset\n\n    @timezone_offset.setter\n\n    def timezone_offset(self, offset: int):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.timezone_offset = offset\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def margin_width(self) -&gt; int:\n\n        \"\"\"Get or set the margin width for the overlay\n\n        The amount of pixels to use as margin on the right and left side of the overlay. Needs to\n\n        be a positive integer.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.margin_width\n\n    @margin_width.setter\n\n    def margin_width(self, width: int):\n\n        if width &lt; 0:\n\n            warnings.warn(\"Invalid margin width, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.margin_width = width\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def margin_height(self) -&gt; int:\n\n        \"\"\"Get or set the margin height for the overlay\n\n        The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be\n\n        a positive integer.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.margin_height\n\n    @margin_height.setter\n\n    def margin_height(self, height: int):\n\n        if height &lt; 0:\n\n            warnings.warn(\"Invalid margin height, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.margin_height = height\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def font_size(self) -&gt; blueye.protocol.FontSize:\n\n        \"\"\"Get or set the font size for the overlay\n\n        Needs to be an instance of the `blueye.protocol.Fontsize` enum, if not a RuntimeWarning is\n\n        raised.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.font_size\n\n    @font_size.setter\n\n    def font_size(self, size: blueye.protocol.FontSize):\n\n        if not isinstance(size, blueye.protocol.FontSize):\n\n            warnings.warn(\"Invalid font size, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.font_size = size\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def title(self) -&gt; str:\n\n        \"\"\"Get or set the title for the overlay\n\n        The title needs to be a string of only ASCII characters with a maximum length of 63\n\n        characters. If a longer title is passed it will be truncated, and a RuntimeWarning is\n\n        raised.\n\n        Set to an empty string to disable title.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.title\n\n    @title.setter\n\n    def title(self, input_title: str):\n\n        new_title = input_title\n\n        if len(input_title) &gt; 63:\n\n            warnings.warn(\"Too long title, truncating to 63 characters\", RuntimeWarning)\n\n            new_title = new_title[:63]\n\n        try:\n\n            bytes(new_title, \"ascii\")\n\n        except UnicodeEncodeError:\n\n            warnings.warn(\"Title can only contain ASCII characters, ignoring\", RuntimeWarning)\n\n            return\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.title = new_title\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def subtitle(self) -&gt; str:\n\n        \"\"\"Get or set the subtitle for the overlay\n\n        The subtitle needs to be a string of only ASCII characters with a maximum length of 63\n\n        characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is\n\n        raised.\n\n        Set to an empty string to disable the subtitle.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.subtitle\n\n    @subtitle.setter\n\n    def subtitle(self, input_subtitle: str):\n\n        new_subtitle = input_subtitle\n\n        if len(input_subtitle) &gt; 63:\n\n            warnings.warn(\"Too long subtitle, truncating to 63 characters\", RuntimeWarning)\n\n            new_subtitle = new_subtitle[:63]\n\n        try:\n\n            bytes(new_subtitle, \"ascii\")\n\n        except UnicodeEncodeError:\n\n            warnings.warn(\"Subtitle can only contain ASCII characters, ignoring\", RuntimeWarning)\n\n            return\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.subtitle = new_subtitle\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def date_format(self) -&gt; str:\n\n        \"\"\"Get or set the format string for the time displayed in the overlay\n\n        Must be a string containing only ASCII characters, with a max length of 63 characters.\n\n        The format codes are defined by the C89 standard, see\n\n        https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\n\n        for an overview of the available codes.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.date_format\n\n    @date_format.setter\n\n    def date_format(self, input_format_str: str):\n\n        format_str = input_format_str\n\n        if len(format_str) &gt; 63:\n\n            warnings.warn(\n\n                \"Too long date format string, truncating to 63 characters\", RuntimeWarning\n\n            )\n\n            format_str = format_str[:63]\n\n        try:\n\n            bytes(format_str, \"ascii\")\n\n        except UnicodeEncodeError:\n\n            warnings.warn(\n\n                \"Date format string can only contain ASCII characters, ignoring\", RuntimeWarning\n\n            )\n\n            return\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.date_format = format_str\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    def upload_logo(self, path_to_logo: str, timeout: float = 1.0):\n\n        \"\"\"Upload user selectable logo for watermarking videos and pictures\n\n        Set the logo-property to `blueye.protocol.LogoType.LOG_TYPE_CUSTOM` to enable this logo.\n\n        Allowed filetype: JPG or PNG.\n\n        Max resolution: 2000 px.\n\n        Max file size: 5 MB.\n\n        *Exceptions*:\n\n        * `requests.exceptions.HTTPError` : Status code 400 for invalid files\n\n        * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified\n\n                                                 timeout (default 1s)\n\n        \"\"\"\n\n        with open(path_to_logo, \"rb\") as f:\n\n            url = f\"http://{self._parent_drone._ip}/asset/logo\"\n\n            files = {\"image\": f}\n\n            response = requests.post(url, files=files, timeout=timeout)\n\n        response.raise_for_status()\n\n    def download_logo(self, output_directory=\".\", timeout: float = 1.0):\n\n        \"\"\"Download the original user uploaded logo (PNG or JPG)\n\n        Select the download directory with the output_directory parameter.\n\n        *Exceptions*:\n\n        * `requests.exceptions.HTTPError` : If no custom logo is uploaded.\n\n        * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified\n\n                                                 timeout (default 1s)\n\n        \"\"\"\n\n        response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout)\n\n        response.raise_for_status()\n\n        filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0]\n\n        with open(f\"{output_directory}/{filename}\", \"wb\") as f:\n\n            f.write(response.content)\n\n    def delete_logo(self, timeout: float = 1.0):\n\n        \"\"\"Delete the user uploaded logo from the drone\n\n        *Exceptions*:\n\n        * `requests.exceptions.HTTPError` : If an error occurs during deletion\n\n        * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified\n\n                                                 timeout (default 1s)\n\n        \"\"\"\n\n        response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout)\n\n        response.raise_for_status()\n\nclass Camera:\n\n    def __init__(self, parent_drone: Drone, is_guestport_camera: bool = False):\n\n        self._parent_drone = parent_drone\n\n        self._is_guestport_camera = is_guestport_camera\n\n        self._camera_type = (\n\n            blueye.protocol.Camera.CAMERA_GUESTPORT\n\n            if is_guestport_camera\n\n            else blueye.protocol.Camera.CAMERA_MAIN\n\n        )\n\n        if not self._is_guestport_camera:\n\n            self.tilt = Tilt(parent_drone)\n\n            self.overlay = Overlay(parent_drone)\n\n        self._camera_parameters = None\n\n    def _get_record_state(self) -&gt; Optional[blueye.protocol.RecordState]:\n\n        record_state_tel = self._parent_drone.telemetry.get(blueye.protocol.RecordStateTel)\n\n        if record_state_tel is not None:\n\n            return record_state_tel.record_state\n\n        else:\n\n            return None\n\n    def _update_camera_parameters(self):\n\n        self._camera_parameters = self._parent_drone._req_rep_client.get_camera_parameters(\n\n            camera=self._camera_type\n\n        )\n\n    @property\n\n    def is_recording(self) -&gt; Optional[bool]:\n\n        \"\"\"Get or set the camera recording state\n\n        *Arguments*:\n\n        * start_recording (bool): Set to True to start a recording, set to False to stop the current\n\n                                  recording.\n\n        *Returns*:\n\n        * Recording state (bool): True if the camera is currently recording, False if not\n\n        \"\"\"\n\n        record_state = self._get_record_state()\n\n        if record_state is None:\n\n            return None\n\n        if self._is_guestport_camera:\n\n            return record_state.guestport_is_recording\n\n        else:\n\n            return record_state.main_is_recording\n\n    @is_recording.setter\n\n    def is_recording(self, start_recording: bool):\n\n        record_state = self._get_record_state()\n\n        if record_state is None:\n\n            logger.warning(\"Unable to set recording state, no record state telemetry received\")\n\n            return\n\n        if self._is_guestport_camera:\n\n            self._parent_drone._ctrl_client.set_recording_state(\n\n                record_state.main_is_recording, start_recording\n\n            )\n\n        else:\n\n            self._parent_drone._ctrl_client.set_recording_state(\n\n                start_recording, record_state.guestport_is_recording\n\n            )\n\n    @property\n\n    def bitrate(self) -&gt; int:\n\n        \"\"\"Set or get the video stream bitrate\n\n        *Arguments*:\n\n        * bitrate (int): Set the video stream bitrate in bits, valid values are in range\n\n                         (1 000 000..16 000 000)\n\n        *Returns*:\n\n        * bitrate (int): The H264 video stream bitrate\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        return self._camera_parameters.h264_bitrate\n\n    @bitrate.setter\n\n    def bitrate(self, bitrate: int):\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        self._camera_parameters.h264_bitrate = bitrate\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def bitrate_still_picture(self) -&gt; int:\n\n        \"\"\"Set or get the bitrate for the still picture stream\n\n        *Arguments*:\n\n        * bitrate (int): Set the still picture stream bitrate in bits, valid values are in range\n\n                         (1 000 000 .. 300 000 000). Default value is 100 000 000.\n\n        *Returns*:\n\n        * bitrate (int): The still picture stream bitrate\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        return self._camera_parameters.mjpg_bitrate\n\n    @bitrate_still_picture.setter\n\n    def bitrate_still_picture(self, bitrate: int):\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        self._camera_parameters.mjpg_bitrate = bitrate\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def exposure(self) -&gt; int:\n\n        \"\"\"Set or get the camera exposure\n\n        *Arguments*:\n\n        * exposure (int): Set the camera exposure time. Unit is thousandths of a second, ie.\n\n                          5 = 5s/1000. Valid values are in the range (1 .. 5000) or -1 for auto\n\n                          exposure\n\n        *Returns*:\n\n        * exposure (int): Get the camera exposure\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        return self._camera_parameters.exposure\n\n    @exposure.setter\n\n    def exposure(self, exposure: int):\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        self._camera_parameters.exposure = exposure\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def whitebalance(self) -&gt; int:\n\n        \"\"\"Set or get the camera white balance\n\n        *Arguments*:\n\n        * white_balance (int): Set the camera white balance. Valid values are in the range\n\n                               (2800..9300) or -1 for auto white balance\n\n        *Returns*:\n\n        * white_balance (int): Get the camera white balance\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        return self._camera_parameters.white_balance\n\n    @whitebalance.setter\n\n    def whitebalance(self, white_balance: int):\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        self._camera_parameters.white_balance = white_balance\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def hue(self) -&gt; int:\n\n        \"\"\"Set or get the camera hue\n\n        *Arguments*:\n\n        * hue (int): Set the camera hue. Valid values are in the range (-40..40)\n\n        *Returns*:\n\n        * hue (int): Get the camera hue\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        return self._camera_parameters.hue\n\n    @hue.setter\n\n    def hue(self, hue: int):\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        self._camera_parameters.hue = hue\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def resolution(self) -&gt; int:\n\n        \"\"\"Set or get the camera resolution\n\n        *Arguments*:\n\n        * resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080\n\n        *Returns*:\n\n        * resolution (int): Get the camera resolution\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        if self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_HD_720P:\n\n            return 720\n\n        elif (\n\n            self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P\n\n        ):\n\n            return 1080\n\n    @resolution.setter\n\n    def resolution(self, resolution: int):\n\n        if resolution not in (720, 1080):\n\n            raise ValueError(\n\n                f\"{resolution} is not a valid resolution. Valid values are 720 or 1080\"\n\n            )\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        if resolution == 720:\n\n            self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_HD_720P\n\n        elif resolution == 1080:\n\n            self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def framerate(self) -&gt; int:\n\n        \"\"\"Set or get the camera frame rate\n\n        *Arguments*:\n\n        * framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30\n\n        *Returns*:\n\n        * framerate (int): Get the camera frame rate\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        if self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_25:\n\n            return 25\n\n        elif self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_30:\n\n            return 30\n\n    @framerate.setter\n\n    def framerate(self, framerate: int):\n\n        if framerate not in (25, 30):\n\n            raise ValueError(f\"{framerate} is not a valid framerate. Valid values are 25 or 30\")\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        if framerate == 25:\n\n            self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_25\n\n        elif framerate == 30:\n\n            self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_30\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def record_time(self) -&gt; Optional[int]:\n\n        \"\"\"Set or get the duration of the current camera recording\n\n        *Returns*:\n\n        * record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording\n\n        \"\"\"\n\n        record_state = self._get_record_state()\n\n        if record_state is None:\n\n            return None\n\n        if self._is_guestport_camera:\n\n            return record_state.guestport_seconds\n\n        else:\n\n            return record_state.main_seconds\n\n    def take_picture(self):\n\n        \"\"\"Takes a still picture and stores it locally on the drone\n\n        These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client.\n\n        \"\"\"\n\n        self._parent_drone._ctrl_client.take_still_picture()\n</code></pre>"},{"location":"reference/blueye/sdk/camera/#variables","title":"Variables","text":"<pre><code>TYPE_CHECKING\n</code></pre> <pre><code>logger\n</code></pre>"},{"location":"reference/blueye/sdk/camera/#classes","title":"Classes","text":""},{"location":"reference/blueye/sdk/camera/#camera","title":"Camera","text":"<pre><code>class Camera(\n    parent_drone: 'Drone',\n    is_guestport_camera: 'bool' = False\n)\n</code></pre> View Source <pre><code>class Camera:\n\n    def __init__(self, parent_drone: Drone, is_guestport_camera: bool = False):\n\n        self._parent_drone = parent_drone\n\n        self._is_guestport_camera = is_guestport_camera\n\n        self._camera_type = (\n\n            blueye.protocol.Camera.CAMERA_GUESTPORT\n\n            if is_guestport_camera\n\n            else blueye.protocol.Camera.CAMERA_MAIN\n\n        )\n\n        if not self._is_guestport_camera:\n\n            self.tilt = Tilt(parent_drone)\n\n            self.overlay = Overlay(parent_drone)\n\n        self._camera_parameters = None\n\n    def _get_record_state(self) -&gt; Optional[blueye.protocol.RecordState]:\n\n        record_state_tel = self._parent_drone.telemetry.get(blueye.protocol.RecordStateTel)\n\n        if record_state_tel is not None:\n\n            return record_state_tel.record_state\n\n        else:\n\n            return None\n\n    def _update_camera_parameters(self):\n\n        self._camera_parameters = self._parent_drone._req_rep_client.get_camera_parameters(\n\n            camera=self._camera_type\n\n        )\n\n    @property\n\n    def is_recording(self) -&gt; Optional[bool]:\n\n        \"\"\"Get or set the camera recording state\n\n        *Arguments*:\n\n        * start_recording (bool): Set to True to start a recording, set to False to stop the current\n\n                                  recording.\n\n        *Returns*:\n\n        * Recording state (bool): True if the camera is currently recording, False if not\n\n        \"\"\"\n\n        record_state = self._get_record_state()\n\n        if record_state is None:\n\n            return None\n\n        if self._is_guestport_camera:\n\n            return record_state.guestport_is_recording\n\n        else:\n\n            return record_state.main_is_recording\n\n    @is_recording.setter\n\n    def is_recording(self, start_recording: bool):\n\n        record_state = self._get_record_state()\n\n        if record_state is None:\n\n            logger.warning(\"Unable to set recording state, no record state telemetry received\")\n\n            return\n\n        if self._is_guestport_camera:\n\n            self._parent_drone._ctrl_client.set_recording_state(\n\n                record_state.main_is_recording, start_recording\n\n            )\n\n        else:\n\n            self._parent_drone._ctrl_client.set_recording_state(\n\n                start_recording, record_state.guestport_is_recording\n\n            )\n\n    @property\n\n    def bitrate(self) -&gt; int:\n\n        \"\"\"Set or get the video stream bitrate\n\n        *Arguments*:\n\n        * bitrate (int): Set the video stream bitrate in bits, valid values are in range\n\n                         (1 000 000..16 000 000)\n\n        *Returns*:\n\n        * bitrate (int): The H264 video stream bitrate\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        return self._camera_parameters.h264_bitrate\n\n    @bitrate.setter\n\n    def bitrate(self, bitrate: int):\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        self._camera_parameters.h264_bitrate = bitrate\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def bitrate_still_picture(self) -&gt; int:\n\n        \"\"\"Set or get the bitrate for the still picture stream\n\n        *Arguments*:\n\n        * bitrate (int): Set the still picture stream bitrate in bits, valid values are in range\n\n                         (1 000 000 .. 300 000 000). Default value is 100 000 000.\n\n        *Returns*:\n\n        * bitrate (int): The still picture stream bitrate\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        return self._camera_parameters.mjpg_bitrate\n\n    @bitrate_still_picture.setter\n\n    def bitrate_still_picture(self, bitrate: int):\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        self._camera_parameters.mjpg_bitrate = bitrate\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def exposure(self) -&gt; int:\n\n        \"\"\"Set or get the camera exposure\n\n        *Arguments*:\n\n        * exposure (int): Set the camera exposure time. Unit is thousandths of a second, ie.\n\n                          5 = 5s/1000. Valid values are in the range (1 .. 5000) or -1 for auto\n\n                          exposure\n\n        *Returns*:\n\n        * exposure (int): Get the camera exposure\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        return self._camera_parameters.exposure\n\n    @exposure.setter\n\n    def exposure(self, exposure: int):\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        self._camera_parameters.exposure = exposure\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def whitebalance(self) -&gt; int:\n\n        \"\"\"Set or get the camera white balance\n\n        *Arguments*:\n\n        * white_balance (int): Set the camera white balance. Valid values are in the range\n\n                               (2800..9300) or -1 for auto white balance\n\n        *Returns*:\n\n        * white_balance (int): Get the camera white balance\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        return self._camera_parameters.white_balance\n\n    @whitebalance.setter\n\n    def whitebalance(self, white_balance: int):\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        self._camera_parameters.white_balance = white_balance\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def hue(self) -&gt; int:\n\n        \"\"\"Set or get the camera hue\n\n        *Arguments*:\n\n        * hue (int): Set the camera hue. Valid values are in the range (-40..40)\n\n        *Returns*:\n\n        * hue (int): Get the camera hue\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        return self._camera_parameters.hue\n\n    @hue.setter\n\n    def hue(self, hue: int):\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        self._camera_parameters.hue = hue\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def resolution(self) -&gt; int:\n\n        \"\"\"Set or get the camera resolution\n\n        *Arguments*:\n\n        * resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080\n\n        *Returns*:\n\n        * resolution (int): Get the camera resolution\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        if self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_HD_720P:\n\n            return 720\n\n        elif (\n\n            self._camera_parameters.resolution == blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P\n\n        ):\n\n            return 1080\n\n    @resolution.setter\n\n    def resolution(self, resolution: int):\n\n        if resolution not in (720, 1080):\n\n            raise ValueError(\n\n                f\"{resolution} is not a valid resolution. Valid values are 720 or 1080\"\n\n            )\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        if resolution == 720:\n\n            self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_HD_720P\n\n        elif resolution == 1080:\n\n            self._camera_parameters.resolution = blueye.protocol.Resolution.RESOLUTION_FULLHD_1080P\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def framerate(self) -&gt; int:\n\n        \"\"\"Set or get the camera frame rate\n\n        *Arguments*:\n\n        * framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30\n\n        *Returns*:\n\n        * framerate (int): Get the camera frame rate\n\n        \"\"\"\n\n        self._update_camera_parameters()\n\n        if self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_25:\n\n            return 25\n\n        elif self._camera_parameters.framerate == blueye.protocol.Framerate.FRAMERATE_FPS_30:\n\n            return 30\n\n    @framerate.setter\n\n    def framerate(self, framerate: int):\n\n        if framerate not in (25, 30):\n\n            raise ValueError(f\"{framerate} is not a valid framerate. Valid values are 25 or 30\")\n\n        if self._camera_parameters is None:\n\n            self._update_camera_parameters()\n\n        if framerate == 25:\n\n            self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_25\n\n        elif framerate == 30:\n\n            self._camera_parameters.framerate = blueye.protocol.Framerate.FRAMERATE_FPS_30\n\n        self._parent_drone._req_rep_client.set_camera_parameters(self._camera_parameters)\n\n    @property\n\n    def record_time(self) -&gt; Optional[int]:\n\n        \"\"\"Set or get the duration of the current camera recording\n\n        *Returns*:\n\n        * record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording\n\n        \"\"\"\n\n        record_state = self._get_record_state()\n\n        if record_state is None:\n\n            return None\n\n        if self._is_guestport_camera:\n\n            return record_state.guestport_seconds\n\n        else:\n\n            return record_state.main_seconds\n\n    def take_picture(self):\n\n        \"\"\"Takes a still picture and stores it locally on the drone\n\n        These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client.\n\n        \"\"\"\n\n        self._parent_drone._ctrl_client.take_still_picture()\n</code></pre>"},{"location":"reference/blueye/sdk/camera/#descendants","title":"Descendants","text":"<ul> <li>blueye.sdk.guestport.GuestPortCamera</li> </ul>"},{"location":"reference/blueye/sdk/camera/#instance-variables","title":"Instance variables","text":"<pre><code>bitrate\n</code></pre> <p>Set or get the video stream bitrate</p> <p>Arguments:</p> <ul> <li>bitrate (int): Set the video stream bitrate in bits, valid values are in range                  (1 000 000..16 000 000)</li> </ul> <p>Returns:</p> <ul> <li>bitrate (int): The H264 video stream bitrate</li> </ul> <pre><code>bitrate_still_picture\n</code></pre> <p>Set or get the bitrate for the still picture stream</p> <p>Arguments:</p> <ul> <li>bitrate (int): Set the still picture stream bitrate in bits, valid values are in range                  (1 000 000 .. 300 000 000). Default value is 100 000 000.</li> </ul> <p>Returns:</p> <ul> <li>bitrate (int): The still picture stream bitrate</li> </ul> <pre><code>exposure\n</code></pre> <p>Set or get the camera exposure</p> <p>Arguments:</p> <ul> <li>exposure (int): Set the camera exposure time. Unit is thousandths of a second, ie.                   5 = 5s/1000. Valid values are in the range (1 .. 5000) or -1 for auto                   exposure</li> </ul> <p>Returns:</p> <ul> <li>exposure (int): Get the camera exposure</li> </ul> <pre><code>framerate\n</code></pre> <p>Set or get the camera frame rate</p> <p>Arguments:</p> <ul> <li>framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30</li> </ul> <p>Returns:</p> <ul> <li>framerate (int): Get the camera frame rate</li> </ul> <pre><code>hue\n</code></pre> <p>Set or get the camera hue</p> <p>Arguments:</p> <ul> <li>hue (int): Set the camera hue. Valid values are in the range (-40..40)</li> </ul> <p>Returns:</p> <ul> <li>hue (int): Get the camera hue</li> </ul> <pre><code>is_recording\n</code></pre> <p>Get or set the camera recording state</p> <p>Arguments:</p> <ul> <li>start_recording (bool): Set to True to start a recording, set to False to stop the current                           recording.</li> </ul> <p>Returns:</p> <ul> <li>Recording state (bool): True if the camera is currently recording, False if not</li> </ul> <pre><code>record_time\n</code></pre> <p>Set or get the duration of the current camera recording</p> <p>Returns:</p> <ul> <li>record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording</li> </ul> <pre><code>resolution\n</code></pre> <p>Set or get the camera resolution</p> <p>Arguments:</p> <ul> <li>resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080</li> </ul> <p>Returns:</p> <ul> <li>resolution (int): Get the camera resolution</li> </ul> <pre><code>whitebalance\n</code></pre> <p>Set or get the camera white balance</p> <p>Arguments:</p> <ul> <li>white_balance (int): Set the camera white balance. Valid values are in the range                        (2800..9300) or -1 for auto white balance</li> </ul> <p>Returns:</p> <ul> <li>white_balance (int): Get the camera white balance</li> </ul>"},{"location":"reference/blueye/sdk/camera/#methods","title":"Methods","text":""},{"location":"reference/blueye/sdk/camera/#take_picture","title":"take_picture","text":"<pre><code>def take_picture(\n    self\n)\n</code></pre> <p>Takes a still picture and stores it locally on the drone</p> <p>These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client.</p> View Source <pre><code>    def take_picture(self):\n\n        \"\"\"Takes a still picture and stores it locally on the drone\n\n        These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client.\n\n        \"\"\"\n\n        self._parent_drone._ctrl_client.take_still_picture()\n</code></pre>"},{"location":"reference/blueye/sdk/camera/#overlay","title":"Overlay","text":"<pre><code>class Overlay(\n    parent_drone: 'Drone'\n)\n</code></pre> <p>Control the overlay on videos and pictures</p> View Source <pre><code>class Overlay:\n\n    \"\"\"Control the overlay on videos and pictures\"\"\"\n\n    def __init__(self, parent_drone: Drone):\n\n        self._parent_drone = parent_drone\n\n        self._overlay_parametres = None\n\n    def _update_overlay_parameters(self):\n\n        self._overlay_parametres = self._parent_drone._req_rep_client.get_overlay_parameters()\n\n    @property\n\n    def temperature_enabled(self) -&gt; bool:\n\n        \"\"\"Get or set the state of the temperature overlay\"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.temperature_enabled\n\n    @temperature_enabled.setter\n\n    def temperature_enabled(self, enable_temperature: bool):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.temperature_enabled = enable_temperature\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def depth_enabled(self) -&gt; bool:\n\n        \"\"\"Get or set the state of the depth overlay\"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.depth_enabled\n\n    @depth_enabled.setter\n\n    def depth_enabled(self, enable_depth: bool):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.depth_enabled = enable_depth\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def heading_enabled(self) -&gt; bool:\n\n        \"\"\"Get or set the state of the heading overlay\"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.heading_enabled\n\n    @heading_enabled.setter\n\n    def heading_enabled(self, enable_heading: bool):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.heading_enabled = enable_heading\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def tilt_enabled(self) -&gt; bool:\n\n        \"\"\"Get or set the state of the tilt overlay\"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.tilt_enabled\n\n    @tilt_enabled.setter\n\n    def tilt_enabled(self, enable_tilt: bool):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.tilt_enabled = enable_tilt\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def date_enabled(self) -&gt; bool:\n\n        \"\"\"Get or set the state of the date overlay\"\"\"\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        return self._overlay_parametres.date_enabled\n\n    @date_enabled.setter\n\n    def date_enabled(self, enable_date: bool):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.date_enabled = enable_date\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def logo(self) -&gt; blueye.protcol.LogoType:\n\n        \"\"\"Get or set logo overlay selection\n\n        Needs to be set to an instance of the `blueye.protocol.LogoType` enum, if not a\n\n        RuntimeWarning is raised.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.logo_type\n\n    @logo.setter\n\n    def logo(self, logo_type: blueye.protocol.LogoType):\n\n        if not isinstance(logo_type, blueye.protocol.LogoType):\n\n            warnings.warn(\"Invalid logo type, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.logo_type = logo_type\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def depth_unit(self) -&gt; blueye.protocol.DepthUnit:\n\n        \"\"\"Get or set the depth unit for the overlay\n\n        Needs to be set to an instance of the `blueye.protocol.DepthUnit` enum, if not a\n\n        RuntimeWarning is raised.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.depth_unit\n\n    @depth_unit.setter\n\n    def depth_unit(self, unit: blueye.protocol.DepthUnit):\n\n        if not isinstance(unit, blueye.protocol.DepthUnit):\n\n            warnings.warn(\"Invalid depth unit, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.depth_unit = unit\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def temperature_unit(self) -&gt; blueye.protocol.TemperatureUnit:\n\n        \"\"\"Get or set the temperature unit for the overlay\n\n        Needs to be set to an instance of the `blueye.protocol.TemperatureUnit` enum, if not a\n\n        RuntimeWarning is raised.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.temperature_unit\n\n    @temperature_unit.setter\n\n    def temperature_unit(self, unit: blueye.protocol.TemperatureUnit):\n\n        if not isinstance(unit, blueye.protocol.TemperatureUnit):\n\n            warnings.warn(\"Invalid temperature unit, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.temperature_unit = unit\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def timezone_offset(self) -&gt; int:\n\n        \"\"\"Get or set the timezone offset for the overlay\n\n        Set to the number of minutes (either positive or negative) the timestamp should be offset.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.timezone_offset\n\n    @timezone_offset.setter\n\n    def timezone_offset(self, offset: int):\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.timezone_offset = offset\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def margin_width(self) -&gt; int:\n\n        \"\"\"Get or set the margin width for the overlay\n\n        The amount of pixels to use as margin on the right and left side of the overlay. Needs to\n\n        be a positive integer.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.margin_width\n\n    @margin_width.setter\n\n    def margin_width(self, width: int):\n\n        if width &lt; 0:\n\n            warnings.warn(\"Invalid margin width, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.margin_width = width\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def margin_height(self) -&gt; int:\n\n        \"\"\"Get or set the margin height for the overlay\n\n        The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be\n\n        a positive integer.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.margin_height\n\n    @margin_height.setter\n\n    def margin_height(self, height: int):\n\n        if height &lt; 0:\n\n            warnings.warn(\"Invalid margin height, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.margin_height = height\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def font_size(self) -&gt; blueye.protocol.FontSize:\n\n        \"\"\"Get or set the font size for the overlay\n\n        Needs to be an instance of the `blueye.protocol.Fontsize` enum, if not a RuntimeWarning is\n\n        raised.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.font_size\n\n    @font_size.setter\n\n    def font_size(self, size: blueye.protocol.FontSize):\n\n        if not isinstance(size, blueye.protocol.FontSize):\n\n            warnings.warn(\"Invalid font size, ignoring\", RuntimeWarning)\n\n        else:\n\n            if self._overlay_parametres is None:\n\n                self._update_overlay_parameters()\n\n            self._overlay_parametres.font_size = size\n\n            self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def title(self) -&gt; str:\n\n        \"\"\"Get or set the title for the overlay\n\n        The title needs to be a string of only ASCII characters with a maximum length of 63\n\n        characters. If a longer title is passed it will be truncated, and a RuntimeWarning is\n\n        raised.\n\n        Set to an empty string to disable title.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.title\n\n    @title.setter\n\n    def title(self, input_title: str):\n\n        new_title = input_title\n\n        if len(input_title) &gt; 63:\n\n            warnings.warn(\"Too long title, truncating to 63 characters\", RuntimeWarning)\n\n            new_title = new_title[:63]\n\n        try:\n\n            bytes(new_title, \"ascii\")\n\n        except UnicodeEncodeError:\n\n            warnings.warn(\"Title can only contain ASCII characters, ignoring\", RuntimeWarning)\n\n            return\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.title = new_title\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def subtitle(self) -&gt; str:\n\n        \"\"\"Get or set the subtitle for the overlay\n\n        The subtitle needs to be a string of only ASCII characters with a maximum length of 63\n\n        characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is\n\n        raised.\n\n        Set to an empty string to disable the subtitle.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.subtitle\n\n    @subtitle.setter\n\n    def subtitle(self, input_subtitle: str):\n\n        new_subtitle = input_subtitle\n\n        if len(input_subtitle) &gt; 63:\n\n            warnings.warn(\"Too long subtitle, truncating to 63 characters\", RuntimeWarning)\n\n            new_subtitle = new_subtitle[:63]\n\n        try:\n\n            bytes(new_subtitle, \"ascii\")\n\n        except UnicodeEncodeError:\n\n            warnings.warn(\"Subtitle can only contain ASCII characters, ignoring\", RuntimeWarning)\n\n            return\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.subtitle = new_subtitle\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    @property\n\n    def date_format(self) -&gt; str:\n\n        \"\"\"Get or set the format string for the time displayed in the overlay\n\n        Must be a string containing only ASCII characters, with a max length of 63 characters.\n\n        The format codes are defined by the C89 standard, see\n\n        https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\n\n        for an overview of the available codes.\n\n        \"\"\"\n\n        self._update_overlay_parameters()\n\n        return self._overlay_parametres.date_format\n\n    @date_format.setter\n\n    def date_format(self, input_format_str: str):\n\n        format_str = input_format_str\n\n        if len(format_str) &gt; 63:\n\n            warnings.warn(\n\n                \"Too long date format string, truncating to 63 characters\", RuntimeWarning\n\n            )\n\n            format_str = format_str[:63]\n\n        try:\n\n            bytes(format_str, \"ascii\")\n\n        except UnicodeEncodeError:\n\n            warnings.warn(\n\n                \"Date format string can only contain ASCII characters, ignoring\", RuntimeWarning\n\n            )\n\n            return\n\n        if self._overlay_parametres is None:\n\n            self._update_overlay_parameters()\n\n        self._overlay_parametres.date_format = format_str\n\n        self._parent_drone._req_rep_client.set_overlay_parameters(self._overlay_parametres)\n\n    def upload_logo(self, path_to_logo: str, timeout: float = 1.0):\n\n        \"\"\"Upload user selectable logo for watermarking videos and pictures\n\n        Set the logo-property to `blueye.protocol.LogoType.LOG_TYPE_CUSTOM` to enable this logo.\n\n        Allowed filetype: JPG or PNG.\n\n        Max resolution: 2000 px.\n\n        Max file size: 5 MB.\n\n        *Exceptions*:\n\n        * `requests.exceptions.HTTPError` : Status code 400 for invalid files\n\n        * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified\n\n                                                 timeout (default 1s)\n\n        \"\"\"\n\n        with open(path_to_logo, \"rb\") as f:\n\n            url = f\"http://{self._parent_drone._ip}/asset/logo\"\n\n            files = {\"image\": f}\n\n            response = requests.post(url, files=files, timeout=timeout)\n\n        response.raise_for_status()\n\n    def download_logo(self, output_directory=\".\", timeout: float = 1.0):\n\n        \"\"\"Download the original user uploaded logo (PNG or JPG)\n\n        Select the download directory with the output_directory parameter.\n\n        *Exceptions*:\n\n        * `requests.exceptions.HTTPError` : If no custom logo is uploaded.\n\n        * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified\n\n                                                 timeout (default 1s)\n\n        \"\"\"\n\n        response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout)\n\n        response.raise_for_status()\n\n        filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0]\n\n        with open(f\"{output_directory}/{filename}\", \"wb\") as f:\n\n            f.write(response.content)\n\n    def delete_logo(self, timeout: float = 1.0):\n\n        \"\"\"Delete the user uploaded logo from the drone\n\n        *Exceptions*:\n\n        * `requests.exceptions.HTTPError` : If an error occurs during deletion\n\n        * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified\n\n                                                 timeout (default 1s)\n\n        \"\"\"\n\n        response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout)\n\n        response.raise_for_status()\n</code></pre>"},{"location":"reference/blueye/sdk/camera/#instance-variables_1","title":"Instance variables","text":"<pre><code>date_enabled\n</code></pre> <p>Get or set the state of the date overlay</p> <pre><code>date_format\n</code></pre> <p>Get or set the format string for the time displayed in the overlay</p> <p>Must be a string containing only ASCII characters, with a max length of 63 characters.</p> <p>The format codes are defined by the C89 standard, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes for an overview of the available codes.</p> <pre><code>depth_enabled\n</code></pre> <p>Get or set the state of the depth overlay</p> <pre><code>depth_unit\n</code></pre> <p>Get or set the depth unit for the overlay</p> <p>Needs to be set to an instance of the <code>blueye.protocol.DepthUnit</code> enum, if not a RuntimeWarning is raised.</p> <pre><code>font_size\n</code></pre> <p>Get or set the font size for the overlay</p> <p>Needs to be an instance of the <code>blueye.protocol.Fontsize</code> enum, if not a RuntimeWarning is raised.</p> <pre><code>heading_enabled\n</code></pre> <p>Get or set the state of the heading overlay</p> <pre><code>logo\n</code></pre> <p>Get or set logo overlay selection</p> <p>Needs to be set to an instance of the <code>blueye.protocol.LogoType</code> enum, if not a RuntimeWarning is raised.</p> <pre><code>margin_height\n</code></pre> <p>Get or set the margin height for the overlay</p> <p>The amount of pixels to use as margin on the top and bottom side of the overlay. Needs to be a positive integer.</p> <pre><code>margin_width\n</code></pre> <p>Get or set the margin width for the overlay</p> <p>The amount of pixels to use as margin on the right and left side of the overlay. Needs to be a positive integer.</p> <pre><code>subtitle\n</code></pre> <p>Get or set the subtitle for the overlay</p> <p>The subtitle needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer subtitle is passed it will be truncated, and a RuntimeWarning is raised.</p> <p>Set to an empty string to disable the subtitle.</p> <pre><code>temperature_enabled\n</code></pre> <p>Get or set the state of the temperature overlay</p> <pre><code>temperature_unit\n</code></pre> <p>Get or set the temperature unit for the overlay</p> <p>Needs to be set to an instance of the <code>blueye.protocol.TemperatureUnit</code> enum, if not a RuntimeWarning is raised.</p> <pre><code>tilt_enabled\n</code></pre> <p>Get or set the state of the tilt overlay</p> <pre><code>timezone_offset\n</code></pre> <p>Get or set the timezone offset for the overlay</p> <p>Set to the number of minutes (either positive or negative) the timestamp should be offset.</p> <pre><code>title\n</code></pre> <p>Get or set the title for the overlay</p> <p>The title needs to be a string of only ASCII characters with a maximum length of 63 characters. If a longer title is passed it will be truncated, and a RuntimeWarning is raised.</p> <p>Set to an empty string to disable title.</p>"},{"location":"reference/blueye/sdk/camera/#methods_1","title":"Methods","text":""},{"location":"reference/blueye/sdk/camera/#delete_logo","title":"delete_logo","text":"<pre><code>def delete_logo(\n    self,\n    timeout: 'float' = 1.0\n)\n</code></pre> <p>Delete the user uploaded logo from the drone</p> <p>Exceptions:</p> <ul> <li> <p><code>requests.exceptions.HTTPError</code> : If an error occurs during deletion</p> </li> <li> <p><code>requests.exceptions.ConnectTimeout</code> : If unable to create a connection within specified                                          timeout (default 1s)</p> </li> </ul> View Source <pre><code>    def delete_logo(self, timeout: float = 1.0):\n\n        \"\"\"Delete the user uploaded logo from the drone\n\n        *Exceptions*:\n\n        * `requests.exceptions.HTTPError` : If an error occurs during deletion\n\n        * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified\n\n                                                 timeout (default 1s)\n\n        \"\"\"\n\n        response = requests.delete(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout)\n\n        response.raise_for_status()\n</code></pre>"},{"location":"reference/blueye/sdk/camera/#download_logo","title":"download_logo","text":"<pre><code>def download_logo(\n    self,\n    output_directory='.',\n    timeout: 'float' = 1.0\n)\n</code></pre> <p>Download the original user uploaded logo (PNG or JPG)</p> <p>Select the download directory with the output_directory parameter.</p> <p>Exceptions:</p> <ul> <li> <p><code>requests.exceptions.HTTPError</code> : If no custom logo is uploaded.</p> </li> <li> <p><code>requests.exceptions.ConnectTimeout</code> : If unable to create a connection within specified                                          timeout (default 1s)</p> </li> </ul> View Source <pre><code>    def download_logo(self, output_directory=\".\", timeout: float = 1.0):\n\n        \"\"\"Download the original user uploaded logo (PNG or JPG)\n\n        Select the download directory with the output_directory parameter.\n\n        *Exceptions*:\n\n        * `requests.exceptions.HTTPError` : If no custom logo is uploaded.\n\n        * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified\n\n                                                 timeout (default 1s)\n\n        \"\"\"\n\n        response = requests.get(f\"http://{self._parent_drone._ip}/asset/logo\", timeout=timeout)\n\n        response.raise_for_status()\n\n        filename = re.findall('filename=\"(.+)\"', response.headers[\"Content-Disposition\"])[0]\n\n        with open(f\"{output_directory}/{filename}\", \"wb\") as f:\n\n            f.write(response.content)\n</code></pre>"},{"location":"reference/blueye/sdk/camera/#upload_logo","title":"upload_logo","text":"<pre><code>def upload_logo(\n    self,\n    path_to_logo: 'str',\n    timeout: 'float' = 1.0\n)\n</code></pre> <p>Upload user selectable logo for watermarking videos and pictures</p> <p>Set the logo-property to <code>blueye.protocol.LogoType.LOG_TYPE_CUSTOM</code> to enable this logo.</p> <p>Allowed filetype: JPG or PNG. Max resolution: 2000 px. Max file size: 5 MB.</p> <p>Exceptions:</p> <ul> <li> <p><code>requests.exceptions.HTTPError</code> : Status code 400 for invalid files</p> </li> <li> <p><code>requests.exceptions.ConnectTimeout</code> : If unable to create a connection within specified                                          timeout (default 1s)</p> </li> </ul> View Source <pre><code>    def upload_logo(self, path_to_logo: str, timeout: float = 1.0):\n\n        \"\"\"Upload user selectable logo for watermarking videos and pictures\n\n        Set the logo-property to `blueye.protocol.LogoType.LOG_TYPE_CUSTOM` to enable this logo.\n\n        Allowed filetype: JPG or PNG.\n\n        Max resolution: 2000 px.\n\n        Max file size: 5 MB.\n\n        *Exceptions*:\n\n        * `requests.exceptions.HTTPError` : Status code 400 for invalid files\n\n        * `requests.exceptions.ConnectTimeout` : If unable to create a connection within specified\n\n                                                 timeout (default 1s)\n\n        \"\"\"\n\n        with open(path_to_logo, \"rb\") as f:\n\n            url = f\"http://{self._parent_drone._ip}/asset/logo\"\n\n            files = {\"image\": f}\n\n            response = requests.post(url, files=files, timeout=timeout)\n\n        response.raise_for_status()\n</code></pre>"},{"location":"reference/blueye/sdk/camera/#tilt","title":"Tilt","text":"<pre><code>class Tilt(\n    parent_drone: 'Drone'\n)\n</code></pre> View Source <pre><code>class Tilt:\n\n    def __init__(self, parent_drone: Drone):\n\n        self._parent_drone = parent_drone\n\n    def _verify_tilt_in_features(self):\n\n        \"\"\"Checks that the connected drone has the tilt feature\n\n        Raises a RuntimeError if it does not.\n\n        \"\"\"\n\n        if \"tilt\" not in self._parent_drone.features:\n\n            raise RuntimeError(\"The connected drone does not support tilting the camera.\")\n\n    def set_velocity(self, velocity: float):\n\n        \"\"\"Set the speed and direction of the camera tilt\n\n        *Arguments*:\n\n        * velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down.\n\n        Raises a RuntimeError if the connected drone does not have the tilt option\n\n        \"\"\"\n\n        self._verify_tilt_in_features()\n\n        self._parent_drone._ctrl_client.set_tilt_velocity(velocity)\n\n    @property\n\n    def angle(self) -&gt; Optional[float]:\n\n        \"\"\"Return the current angle of the camera tilt\n\n        Raises a RuntimeError if the connected drone does not have the tilt option\n\n        \"\"\"\n\n        self._verify_tilt_in_features()\n\n        tilt_angle_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltAngleTel)\n\n        if tilt_angle_tel is not None:\n\n            return tilt_angle_tel.angle.value\n\n        else:\n\n            return None\n\n    @property\n\n    def stabilization_enabled(self) -&gt; Optional[bool]:\n\n        \"\"\"Get or set the state of active camera stabilization\n\n        *Arguments*:\n\n        * enabled (bool): True to turn stabilization on, False to turn it off\n\n        *Returns*:\n\n        * enabled (bool): Current state of active camera stabilization\n\n        \"\"\"\n\n        self._verify_tilt_in_features()\n\n        tilt_stab_tel = self._parent_drone.telemetry.get(blueye.protocol.TiltStabilizationTel)\n\n        if tilt_stab_tel is not None:\n\n            return tilt_stab_tel.state.enabled\n\n        else:\n\n            return None\n\n    @stabilization_enabled.setter\n\n    def stabilization_enabled(self, enabled: bool):\n\n        self._verify_tilt_in_features()\n\n        self._parent_drone._ctrl_client.set_tilt_stabilization(enabled)\n</code></pre>"},{"location":"reference/blueye/sdk/camera/#instance-variables_2","title":"Instance variables","text":"<pre><code>angle\n</code></pre> <p>Return the current angle of the camera tilt</p> <p>Raises a RuntimeError if the connected drone does not have the tilt option</p> <pre><code>stabilization_enabled\n</code></pre> <p>Get or set the state of active camera stabilization</p> <p>Arguments:</p> <ul> <li>enabled (bool): True to turn stabilization on, False to turn it off</li> </ul> <p>Returns:</p> <ul> <li>enabled (bool): Current state of active camera stabilization</li> </ul>"},{"location":"reference/blueye/sdk/camera/#methods_2","title":"Methods","text":""},{"location":"reference/blueye/sdk/camera/#set_velocity","title":"set_velocity","text":"<pre><code>def set_velocity(\n    self,\n    velocity: 'float'\n)\n</code></pre> <p>Set the speed and direction of the camera tilt</p> <p>Arguments:</p> <ul> <li>velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down.</li> </ul> <p>Raises a RuntimeError if the connected drone does not have the tilt option</p> View Source <pre><code>    def set_velocity(self, velocity: float):\n\n        \"\"\"Set the speed and direction of the camera tilt\n\n        *Arguments*:\n\n        * velocity (float): Speed and direction of the tilt. 1 is max speed up, -1 is max speed down.\n\n        Raises a RuntimeError if the connected drone does not have the tilt option\n\n        \"\"\"\n\n        self._verify_tilt_in_features()\n\n        self._parent_drone._ctrl_client.set_tilt_velocity(velocity)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/","title":"Module blueye.sdk.connection","text":"View Source <pre><code>from __future__ import annotations\n\nimport importlib.metadata\n\nimport logging\n\nimport platform\n\nimport queue\n\nimport threading\n\nimport uuid\n\nfrom typing import Any, Callable, Dict, List, NamedTuple, Tuple\n\nimport blueye.protocol\n\nimport proto\n\nimport zmq\n\nlogger = logging.getLogger(__name__)\n\nclass WatchdogPublisher(threading.Thread):\n\n    def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None):\n\n        super().__init__(daemon=True)\n\n        self._parent_drone = parent_drone\n\n        self._context = context or zmq.Context().instance()\n\n        self._socket = self._context.socket(zmq.PUB)\n\n        self._socket.connect(f\"tcp://{self._parent_drone._ip}:5557\")\n\n        self._exit_flag = threading.Event()\n\n    def run(self):\n\n        duration = 0\n\n        WATCHDOG_DELAY = 1\n\n        while not self._exit_flag.wait(WATCHDOG_DELAY):\n\n            self.pet_watchdog(duration)\n\n            duration += 1\n\n    def pet_watchdog(self, duration):\n\n        msg = blueye.protocol.WatchdogCtrl(\n\n            connection_duration={\"value\": duration}, client_id=self._parent_drone.client_id\n\n        )\n\n        self._socket.send_multipart(\n\n            [\n\n                bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"),\n\n                blueye.protocol.WatchdogCtrl.serialize(msg),\n\n            ]\n\n        )\n\n    def stop(self):\n\n        \"\"\"Stop the watchdog thread started by run()\"\"\"\n\n        self._exit_flag.set()\n\nclass Callback(NamedTuple):\n\n    \"\"\"Specifications for callback for telemetry messages\"\"\"\n\n    message_filter: List[proto.messages.Message]\n\n    function: Callable[[str, proto.message.Message], None]\n\n    pass_raw_data: bool\n\n    uuid_hex: str\n\n    kwargs: Dict[str, Any]\n\nclass TelemetryClient(threading.Thread):\n\n    def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None):\n\n        super().__init__(daemon=True)\n\n        self._parent_drone = parent_drone\n\n        self._context = context or zmq.Context().instance()\n\n        self._socket = self._context.socket(zmq.SUB)\n\n        self._socket.connect(f\"tcp://{self._parent_drone._ip}:5555\")\n\n        self._socket.setsockopt_string(zmq.SUBSCRIBE, \"\")\n\n        self._exit_flag = threading.Event()\n\n        self._state_lock = threading.Lock()\n\n        self._callbacks: List[Callback] = []\n\n        self._state: Dict[proto.message.Message, bytes] = {}\n\n        \"\"\"`_state` is dictionary of the latest received messages, where the key is the protobuf\n\n        message class, eg. blueye.protocol.DepthTel and the value is the serialized protobuf\n\n        message\"\"\"\n\n    def _handle_message(self, msg: Tuple[bytes, bytes]):\n\n        msg_type_name = msg[0].decode(\"utf-8\").replace(\"blueye.protocol.\", \"\")\n\n        try:\n\n            msg_type = blueye.protocol.__getattribute__(msg_type_name)\n\n        except AttributeError:\n\n            # If a new telemetry message is introduced before the SDK is updated this can\n\n            # be a common occurence, so choosing to log with info instead of warning\n\n            logger.info(f\"Ignoring unknown message type: {msg_type_name}\")\n\n            return\n\n        msg_payload = msg[1]\n\n        with self._state_lock:\n\n            self._state[msg_type] = msg_payload\n\n        for callback in self._callbacks:\n\n            if msg_type in callback.message_filter or callback.message_filter == []:\n\n                if callback.pass_raw_data:\n\n                    callback.function(msg_type_name, msg_payload, **callback.kwargs)\n\n                else:\n\n                    msg_deserialized = msg_type.deserialize(msg_payload)\n\n                    callback.function(msg_type_name, msg_deserialized, **callback.kwargs)\n\n    def run(self):\n\n        poller = zmq.Poller()\n\n        poller.register(self._socket, zmq.POLLIN)\n\n        while not self._exit_flag.is_set():\n\n            events_to_be_processed = poller.poll(10)\n\n            if len(events_to_be_processed) &gt; 0:\n\n                msg = self._socket.recv_multipart()\n\n                self._handle_message(msg)\n\n    def add_callback(\n\n        self,\n\n        msg_filter: List[proto.message.Message],\n\n        callback_function: Callable[[str, proto.message.Message], None],\n\n        raw: bool,\n\n        **kwargs,\n\n    ):\n\n        uuid_hex = uuid.uuid1().hex\n\n        self._callbacks.append(Callback(msg_filter, callback_function, raw, uuid_hex, kwargs))\n\n        return uuid_hex\n\n    def remove_callback(self, callback_id):\n\n        try:\n\n            self._callbacks.pop([cb.uuid_hex for cb in self._callbacks].index(callback_id))\n\n        except ValueError:\n\n            logger.warning(f\"Callback with id {callback_id} not found, ignoring\")\n\n    def get(self, key: proto.message.Message):\n\n        with self._state_lock:\n\n            return self._state[key]\n\n    def stop(self):\n\n        self._exit_flag.set()\n\nclass CtrlClient(threading.Thread):\n\n    def __init__(\n\n        self,\n\n        parent_drone: \"blueye.sdk.Drone\",\n\n        context: zmq.Context = None,\n\n    ):\n\n        super().__init__(daemon=True)\n\n        self._context = context or zmq.Context().instance()\n\n        self._parent_drone = parent_drone\n\n        self._drone_pub_socket = self._context.socket(zmq.PUB)\n\n        self._drone_pub_socket.connect(f\"tcp://{self._parent_drone._ip}:5557\")\n\n        self._messages_to_send = queue.Queue()\n\n        self._exit_flag = threading.Event()\n\n    def run(self):\n\n        while not self._exit_flag.is_set():\n\n            try:\n\n                msg = self._messages_to_send.get(timeout=0.1)\n\n                self._drone_pub_socket.send_multipart(\n\n                    [\n\n                        bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"),\n\n                        msg.__class__.serialize(msg),\n\n                    ]\n\n                )\n\n            except queue.Empty:\n\n                # No messages to send, so we can\n\n                continue\n\n    def stop(self):\n\n        self._exit_flag.set()\n\n    def set_lights(self, value: float):\n\n        msg = blueye.protocol.LightsCtrl(lights={\"value\": value})\n\n        self._messages_to_send.put(msg)\n\n    def set_guest_port_lights(self, value: float):\n\n        msg = blueye.protocol.GuestportLightsCtrl(lights={\"value\": value})\n\n        self._messages_to_send.put(msg)\n\n    def set_water_density(self, value: float):\n\n        msg = blueye.protocol.WaterDensityCtrl(density={\"value\": value})\n\n        self._messages_to_send.put(msg)\n\n    def set_tilt_velocity(self, value: float):\n\n        msg = blueye.protocol.TiltVelocityCtrl(velocity={\"value\": value})\n\n        self._messages_to_send.put(msg)\n\n    def set_tilt_stabilization(self, enabled: bool):\n\n        msg = blueye.protocol.TiltStabilizationCtrl(state={\"enabled\": enabled})\n\n        self._messages_to_send.put(msg)\n\n    def set_motion_input(\n\n        self, surge: float, sway: float, heave: float, yaw: float, slow: float, boost: float\n\n    ):\n\n        msg = blueye.protocol.MotionInputCtrl(\n\n            motion_input={\n\n                \"surge\": surge,\n\n                \"sway\": sway,\n\n                \"heave\": heave,\n\n                \"yaw\": yaw,\n\n                \"slow\": slow,\n\n                \"boost\": boost,\n\n            }\n\n        )\n\n        self._messages_to_send.put(msg)\n\n    def set_auto_depth_state(self, enabled: bool):\n\n        msg = blueye.protocol.AutoDepthCtrl(state={\"enabled\": enabled})\n\n        self._messages_to_send.put(msg)\n\n    def set_auto_heading_state(self, enabled: bool):\n\n        msg = blueye.protocol.AutoHeadingCtrl(state={\"enabled\": enabled})\n\n        self._messages_to_send.put(msg)\n\n    def set_recording_state(self, main_enabled: bool, guestport_enabled: bool):\n\n        msg = blueye.protocol.RecordCtrl(\n\n            record_on={\"main\": main_enabled, \"guestport\": guestport_enabled}\n\n        )\n\n        self._messages_to_send.put(msg)\n\n    def take_still_picture(self):\n\n        msg = blueye.protocol.TakePictureCtrl()\n\n        self._messages_to_send.put(msg)\n\nclass ReqRepClient(threading.Thread):\n\n    def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None):\n\n        super().__init__(daemon=True)\n\n        self._context = context or zmq.Context().instance()\n\n        self._parent_drone = parent_drone\n\n        self._socket = self._context.socket(zmq.REQ)\n\n        self._socket.connect(f\"tcp://{self._parent_drone._ip}:5556\")\n\n        self._requests_to_send = queue.Queue()\n\n        self._exit_flag = threading.Event()\n\n    @staticmethod\n\n    def _get_client_info() -&gt; blueye.protocol.ClientInfo:\n\n        client_info = blueye.protocol.ClientInfo(\n\n            type=\"SDK\",\n\n            version=f\"{importlib.metadata.version('blueye.sdk')}\",\n\n            device_type=\"Computer\",\n\n            platform=f\"{platform.system()}\",\n\n            platform_version=f\"{platform.release()}\",\n\n            name=f\"{platform.node()}\",\n\n        )\n\n        return client_info\n\n    @staticmethod\n\n    def _parse_type_to_string(msg: proto.message.MessageMeta | str) -&gt; str:\n\n        message_type = (\n\n            msg.meta.full_name.replace(\"blueye.protocol.\", \"\")\n\n            if type(msg) is proto.message.MessageMeta\n\n            else msg.replace(\"blueye.protocol.\", \"\")\n\n        )\n\n        return message_type\n\n    def run(self):\n\n        while not self._exit_flag.is_set():\n\n            try:\n\n                msg, response_type, response_callback_queue = self._requests_to_send.get(\n\n                    timeout=0.1\n\n                )\n\n                self._socket.send_multipart(\n\n                    [\n\n                        bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"),\n\n                        msg.__class__.serialize(msg),\n\n                    ]\n\n                )\n\n            except queue.Empty:\n\n                # No requests to send, so we can\n\n                continue\n\n            # TODO: Deal with timeout\n\n            resp = self._socket.recv_multipart()\n\n            resp_deserialized = response_type.deserialize(resp[1])\n\n            response_callback_queue.put(resp_deserialized)\n\n    def stop(self):\n\n        self._exit_flag.set()\n\n    def _send_request_get_response(\n\n        self,\n\n        request: proto.message.Message,\n\n        expected_response: proto.message.Message,\n\n        timeout: float,\n\n    ):\n\n        response_queue = queue.Queue(maxsize=1)\n\n        self._requests_to_send.put((request, expected_response, response_queue))\n\n        try:\n\n            return response_queue.get(timeout=timeout)\n\n        except queue.Empty:\n\n            raise blueye.protocol.exceptions.ResponseTimeout(\n\n                \"No response received from drone before timeout\"\n\n            )\n\n    def ping(self, timeout: float) -&gt; blueye.protocol.PingRep:\n\n        request = blueye.protocol.PingReq()\n\n        return self._send_request_get_response(request, blueye.protocol.PingRep, timeout)\n\n    def get_camera_parameters(\n\n        self, camera: blueye.protocol.Camera, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.CameraParameters:\n\n        request = blueye.protocol.GetCameraParametersReq(camera=camera)\n\n        response = self._send_request_get_response(\n\n            request, blueye.protocol.GetCameraParametersRep, timeout\n\n        )\n\n        return response.camera_parameters\n\n    def set_camera_parameters(\n\n        self,\n\n        parameters: blueye.protocol.CameraParameters,\n\n        timeout: float = 0.05,\n\n    ):\n\n        request = blueye.protocol.SetCameraParametersReq(camera_parameters=parameters)\n\n        return self._send_request_get_response(\n\n            request, blueye.protocol.SetCameraParametersRep, timeout\n\n        )\n\n    def get_overlay_parameters(self, timeout: float = 0.05) -&gt; blueye.protocol.OverlayParameters:\n\n        request = blueye.protocol.GetOverlayParametersReq()\n\n        response = self._send_request_get_response(\n\n            request, blueye.protocol.GetOverlayParametersRep, timeout\n\n        )\n\n        return response.overlay_parameters\n\n    def set_overlay_parameters(\n\n        self, parameters: blueye.protocol.OverlayParameters, timeout: float = 0.05\n\n    ):\n\n        request = blueye.protocol.SetOverlayParametersReq(overlay_parameters=parameters)\n\n        return self._send_request_get_response(\n\n            request, blueye.protocol.SetOverlayParametersRep, timeout\n\n        )\n\n    def sync_time(self, time: int, timeout: float = 0.05):\n\n        request = blueye.protocol.SyncTimeReq(\n\n            time={\"unix_timestamp\": {\"seconds\": time, \"nanos\": 0}}\n\n        )\n\n        return self._send_request_get_response(request, blueye.protocol.SyncTimeRep, timeout)\n\n    def connect_client(\n\n        self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.ConnectClientRep:\n\n        client = client_info or self._get_client_info()\n\n        request = blueye.protocol.ConnectClientReq(client_info=client)\n\n        return self._send_request_get_response(request, blueye.protocol.ConnectClientRep, timeout)\n\n    def disconnect_client(\n\n        self, client_id: int, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.DisconnectClientRep:\n\n        request = blueye.protocol.DisconnectClientReq(client_id=client_id)\n\n        return self._send_request_get_response(\n\n            request, blueye.protocol.DisconnectClientRep, timeout\n\n        )\n\n    def set_telemetry_msg_publish_frequency(\n\n        self, msg: proto.message.MessageMeta | str, frequency: float, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.SetPubFrequencyRep:\n\n        message_type = self._parse_type_to_string(msg)\n\n        request = blueye.protocol.SetPubFrequencyReq(\n\n            message_type=message_type,\n\n            frequency=frequency,\n\n        )\n\n        return self._send_request_get_response(request, blueye.protocol.SetPubFrequencyRep, timeout)\n\n    def get_telemetry_msg(self, msg: proto.message.MessageMeta | str, timeout: float = 0.05):\n\n        message_type = self._parse_type_to_string(msg)\n\n        request = blueye.protocol.GetTelemetryReq(message_type=message_type)\n\n        return self._send_request_get_response(request, blueye.protocol.GetTelemetryRep, timeout)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#variables","title":"Variables","text":"<pre><code>logger\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#classes","title":"Classes","text":""},{"location":"reference/blueye/sdk/connection/#callback","title":"Callback","text":"<pre><code>class Callback(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Specifications for callback for telemetry messages</p> View Source <pre><code>class Callback(NamedTuple):\n\n    \"\"\"Specifications for callback for telemetry messages\"\"\"\n\n    message_filter: List[proto.messages.Message]\n\n    function: Callable[[str, proto.message.Message], None]\n\n    pass_raw_data: bool\n\n    uuid_hex: str\n\n    kwargs: Dict[str, Any]\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>builtins.tuple</li> </ul>"},{"location":"reference/blueye/sdk/connection/#class-variables","title":"Class variables","text":"<pre><code>function\n</code></pre> <pre><code>kwargs\n</code></pre> <pre><code>message_filter\n</code></pre> <pre><code>pass_raw_data\n</code></pre> <pre><code>uuid_hex\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#methods","title":"Methods","text":""},{"location":"reference/blueye/sdk/connection/#count","title":"count","text":"<pre><code>def count(\n    self,\n    value,\n    /\n)\n</code></pre> <p>Return number of occurrences of value.</p>"},{"location":"reference/blueye/sdk/connection/#index","title":"index","text":"<pre><code>def index(\n    self,\n    value,\n    start=0,\n    stop=9223372036854775807,\n    /\n)\n</code></pre> <p>Return first index of value.</p> <p>Raises ValueError if the value is not present.</p>"},{"location":"reference/blueye/sdk/connection/#ctrlclient","title":"CtrlClient","text":"<pre><code>class CtrlClient(\n    parent_drone: \"'blueye.sdk.Drone'\",\n    context: 'zmq.Context' = None\n)\n</code></pre> <p>A class that represents a thread of control.</p> <p>This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass.</p> View Source <pre><code>class CtrlClient(threading.Thread):\n\n    def __init__(\n\n        self,\n\n        parent_drone: \"blueye.sdk.Drone\",\n\n        context: zmq.Context = None,\n\n    ):\n\n        super().__init__(daemon=True)\n\n        self._context = context or zmq.Context().instance()\n\n        self._parent_drone = parent_drone\n\n        self._drone_pub_socket = self._context.socket(zmq.PUB)\n\n        self._drone_pub_socket.connect(f\"tcp://{self._parent_drone._ip}:5557\")\n\n        self._messages_to_send = queue.Queue()\n\n        self._exit_flag = threading.Event()\n\n    def run(self):\n\n        while not self._exit_flag.is_set():\n\n            try:\n\n                msg = self._messages_to_send.get(timeout=0.1)\n\n                self._drone_pub_socket.send_multipart(\n\n                    [\n\n                        bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"),\n\n                        msg.__class__.serialize(msg),\n\n                    ]\n\n                )\n\n            except queue.Empty:\n\n                # No messages to send, so we can\n\n                continue\n\n    def stop(self):\n\n        self._exit_flag.set()\n\n    def set_lights(self, value: float):\n\n        msg = blueye.protocol.LightsCtrl(lights={\"value\": value})\n\n        self._messages_to_send.put(msg)\n\n    def set_guest_port_lights(self, value: float):\n\n        msg = blueye.protocol.GuestportLightsCtrl(lights={\"value\": value})\n\n        self._messages_to_send.put(msg)\n\n    def set_water_density(self, value: float):\n\n        msg = blueye.protocol.WaterDensityCtrl(density={\"value\": value})\n\n        self._messages_to_send.put(msg)\n\n    def set_tilt_velocity(self, value: float):\n\n        msg = blueye.protocol.TiltVelocityCtrl(velocity={\"value\": value})\n\n        self._messages_to_send.put(msg)\n\n    def set_tilt_stabilization(self, enabled: bool):\n\n        msg = blueye.protocol.TiltStabilizationCtrl(state={\"enabled\": enabled})\n\n        self._messages_to_send.put(msg)\n\n    def set_motion_input(\n\n        self, surge: float, sway: float, heave: float, yaw: float, slow: float, boost: float\n\n    ):\n\n        msg = blueye.protocol.MotionInputCtrl(\n\n            motion_input={\n\n                \"surge\": surge,\n\n                \"sway\": sway,\n\n                \"heave\": heave,\n\n                \"yaw\": yaw,\n\n                \"slow\": slow,\n\n                \"boost\": boost,\n\n            }\n\n        )\n\n        self._messages_to_send.put(msg)\n\n    def set_auto_depth_state(self, enabled: bool):\n\n        msg = blueye.protocol.AutoDepthCtrl(state={\"enabled\": enabled})\n\n        self._messages_to_send.put(msg)\n\n    def set_auto_heading_state(self, enabled: bool):\n\n        msg = blueye.protocol.AutoHeadingCtrl(state={\"enabled\": enabled})\n\n        self._messages_to_send.put(msg)\n\n    def set_recording_state(self, main_enabled: bool, guestport_enabled: bool):\n\n        msg = blueye.protocol.RecordCtrl(\n\n            record_on={\"main\": main_enabled, \"guestport\": guestport_enabled}\n\n        )\n\n        self._messages_to_send.put(msg)\n\n    def take_still_picture(self):\n\n        msg = blueye.protocol.TakePictureCtrl()\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>threading.Thread</li> </ul>"},{"location":"reference/blueye/sdk/connection/#instance-variables","title":"Instance variables","text":"<pre><code>daemon\n</code></pre> <p>A boolean value indicating whether this thread is a daemon thread.</p> <p>This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False.</p> <p>The entire Python program exits when only daemon threads are left.</p> <pre><code>ident\n</code></pre> <p>Thread identifier of this thread or None if it has not been started.</p> <p>This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</p> <pre><code>name\n</code></pre> <p>A string used for identification purposes only.</p> <p>It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.</p> <pre><code>native_id\n</code></pre> <p>Native integral thread ID of this thread, or None if it has not been started.</p> <p>This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.</p>"},{"location":"reference/blueye/sdk/connection/#methods_1","title":"Methods","text":""},{"location":"reference/blueye/sdk/connection/#getname","title":"getName","text":"<pre><code>def getName(\n    self\n)\n</code></pre> <p>Return a string used for identification purposes only.</p> <p>This method is deprecated, use the name attribute instead.</p> View Source <pre><code>    def getName(self):\n\n        \"\"\"Return a string used for identification purposes only.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('getName() is deprecated, get the name attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        return self.name\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#isdaemon","title":"isDaemon","text":"<pre><code>def isDaemon(\n    self\n)\n</code></pre> <p>Return whether this thread is a daemon.</p> <p>This method is deprecated, use the daemon attribute instead.</p> View Source <pre><code>    def isDaemon(self):\n\n        \"\"\"Return whether this thread is a daemon.\n\n        This method is deprecated, use the daemon attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('isDaemon() is deprecated, get the daemon attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        return self.daemon\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#is_alive","title":"is_alive","text":"<pre><code>def is_alive(\n    self\n)\n</code></pre> <p>Return whether the thread is alive.</p> <p>This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate().</p> View Source <pre><code>    def is_alive(self):\n\n        \"\"\"Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n\n        after the run() method terminates. See also the module function\n\n        enumerate().\n\n        \"\"\"\n\n        assert self._initialized, \"Thread.__init__() not called\"\n\n        if self._is_stopped or not self._started.is_set():\n\n            return False\n\n        self._wait_for_tstate_lock(False)\n\n        return not self._is_stopped\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#join","title":"join","text":"<pre><code>def join(\n    self,\n    timeout=None\n)\n</code></pre> <p>Wait until the thread terminates.</p> <p>This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs.</p> <p>When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out.</p> <p>When the timeout argument is not present or None, the operation will block until the thread terminates.</p> <p>A thread can be join()ed many times.</p> <p>join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception.</p> View Source <pre><code>    def join(self, timeout=None):\n\n        \"\"\"Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n\n        called terminates -- either normally or through an unhandled exception\n\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n\n        floating point number specifying a timeout for the operation in seconds\n\n        (or fractions thereof). As join() always returns None, you must call\n\n        is_alive() after join() to decide whether a timeout happened -- if the\n\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n\n        thread as that would cause a deadlock. It is also an error to join() a\n\n        thread before it has been started and attempts to do so raises the same\n\n        exception.\n\n        \"\"\"\n\n        if not self._initialized:\n\n            raise RuntimeError(\"Thread.__init__() not called\")\n\n        if not self._started.is_set():\n\n            raise RuntimeError(\"cannot join thread before it is started\")\n\n        if self is current_thread():\n\n            raise RuntimeError(\"cannot join current thread\")\n\n        if timeout is None:\n\n            self._wait_for_tstate_lock()\n\n        else:\n\n            # the behavior of a negative timeout isn't documented, but\n\n            # historically .join(timeout=x) for x&lt;0 has acted as if timeout=0\n\n            self._wait_for_tstate_lock(timeout=max(timeout, 0))\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#run","title":"run","text":"<pre><code>def run(\n    self\n)\n</code></pre> <p>Method representing the thread's activity.</p> <p>You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively.</p> View Source <pre><code>    def run(self):\n\n        while not self._exit_flag.is_set():\n\n            try:\n\n                msg = self._messages_to_send.get(timeout=0.1)\n\n                self._drone_pub_socket.send_multipart(\n\n                    [\n\n                        bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"),\n\n                        msg.__class__.serialize(msg),\n\n                    ]\n\n                )\n\n            except queue.Empty:\n\n                # No messages to send, so we can\n\n                continue\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#setdaemon","title":"setDaemon","text":"<pre><code>def setDaemon(\n    self,\n    daemonic\n)\n</code></pre> <p>Set whether this thread is a daemon.</p> <p>This method is deprecated, use the .daemon property instead.</p> View Source <pre><code>    def setDaemon(self, daemonic):\n\n        \"\"\"Set whether this thread is a daemon.\n\n        This method is deprecated, use the .daemon property instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('setDaemon() is deprecated, set the daemon attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        self.daemon = daemonic\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#setname","title":"setName","text":"<pre><code>def setName(\n    self,\n    name\n)\n</code></pre> <p>Set the name string for this thread.</p> <p>This method is deprecated, use the name attribute instead.</p> View Source <pre><code>    def setName(self, name):\n\n        \"\"\"Set the name string for this thread.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('setName() is deprecated, set the name attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        self.name = name\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_auto_depth_state","title":"set_auto_depth_state","text":"<pre><code>def set_auto_depth_state(\n    self,\n    enabled: 'bool'\n)\n</code></pre> View Source <pre><code>    def set_auto_depth_state(self, enabled: bool):\n\n        msg = blueye.protocol.AutoDepthCtrl(state={\"enabled\": enabled})\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_auto_heading_state","title":"set_auto_heading_state","text":"<pre><code>def set_auto_heading_state(\n    self,\n    enabled: 'bool'\n)\n</code></pre> View Source <pre><code>    def set_auto_heading_state(self, enabled: bool):\n\n        msg = blueye.protocol.AutoHeadingCtrl(state={\"enabled\": enabled})\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_guest_port_lights","title":"set_guest_port_lights","text":"<pre><code>def set_guest_port_lights(\n    self,\n    value: 'float'\n)\n</code></pre> View Source <pre><code>    def set_guest_port_lights(self, value: float):\n\n        msg = blueye.protocol.GuestportLightsCtrl(lights={\"value\": value})\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_lights","title":"set_lights","text":"<pre><code>def set_lights(\n    self,\n    value: 'float'\n)\n</code></pre> View Source <pre><code>    def set_lights(self, value: float):\n\n        msg = blueye.protocol.LightsCtrl(lights={\"value\": value})\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_motion_input","title":"set_motion_input","text":"<pre><code>def set_motion_input(\n    self,\n    surge: 'float',\n    sway: 'float',\n    heave: 'float',\n    yaw: 'float',\n    slow: 'float',\n    boost: 'float'\n)\n</code></pre> View Source <pre><code>    def set_motion_input(\n\n        self, surge: float, sway: float, heave: float, yaw: float, slow: float, boost: float\n\n    ):\n\n        msg = blueye.protocol.MotionInputCtrl(\n\n            motion_input={\n\n                \"surge\": surge,\n\n                \"sway\": sway,\n\n                \"heave\": heave,\n\n                \"yaw\": yaw,\n\n                \"slow\": slow,\n\n                \"boost\": boost,\n\n            }\n\n        )\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_recording_state","title":"set_recording_state","text":"<pre><code>def set_recording_state(\n    self,\n    main_enabled: 'bool',\n    guestport_enabled: 'bool'\n)\n</code></pre> View Source <pre><code>    def set_recording_state(self, main_enabled: bool, guestport_enabled: bool):\n\n        msg = blueye.protocol.RecordCtrl(\n\n            record_on={\"main\": main_enabled, \"guestport\": guestport_enabled}\n\n        )\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_tilt_stabilization","title":"set_tilt_stabilization","text":"<pre><code>def set_tilt_stabilization(\n    self,\n    enabled: 'bool'\n)\n</code></pre> View Source <pre><code>    def set_tilt_stabilization(self, enabled: bool):\n\n        msg = blueye.protocol.TiltStabilizationCtrl(state={\"enabled\": enabled})\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_tilt_velocity","title":"set_tilt_velocity","text":"<pre><code>def set_tilt_velocity(\n    self,\n    value: 'float'\n)\n</code></pre> View Source <pre><code>    def set_tilt_velocity(self, value: float):\n\n        msg = blueye.protocol.TiltVelocityCtrl(velocity={\"value\": value})\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_water_density","title":"set_water_density","text":"<pre><code>def set_water_density(\n    self,\n    value: 'float'\n)\n</code></pre> View Source <pre><code>    def set_water_density(self, value: float):\n\n        msg = blueye.protocol.WaterDensityCtrl(density={\"value\": value})\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#start","title":"start","text":"<pre><code>def start(\n    self\n)\n</code></pre> <p>Start the thread's activity.</p> <p>It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control.</p> <p>This method will raise a RuntimeError if called more than once on the same thread object.</p> View Source <pre><code>    def start(self):\n\n        \"\"\"Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n\n        same thread object.\n\n        \"\"\"\n\n        if not self._initialized:\n\n            raise RuntimeError(\"thread.__init__() not called\")\n\n        if self._started.is_set():\n\n            raise RuntimeError(\"threads can only be started once\")\n\n        with _active_limbo_lock:\n\n            _limbo[self] = self\n\n        try:\n\n            _start_new_thread(self._bootstrap, ())\n\n        except Exception:\n\n            with _active_limbo_lock:\n\n                del _limbo[self]\n\n            raise\n\n        self._started.wait()\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#stop","title":"stop","text":"<pre><code>def stop(\n    self\n)\n</code></pre> View Source <pre><code>    def stop(self):\n\n        self._exit_flag.set()\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#take_still_picture","title":"take_still_picture","text":"<pre><code>def take_still_picture(\n    self\n)\n</code></pre> View Source <pre><code>    def take_still_picture(self):\n\n        msg = blueye.protocol.TakePictureCtrl()\n\n        self._messages_to_send.put(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#reqrepclient","title":"ReqRepClient","text":"<pre><code>class ReqRepClient(\n    parent_drone: \"'blueye.sdk.Drone'\",\n    context: 'zmq.Context' = None\n)\n</code></pre> <p>A class that represents a thread of control.</p> <p>This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass.</p> View Source <pre><code>class ReqRepClient(threading.Thread):\n\n    def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None):\n\n        super().__init__(daemon=True)\n\n        self._context = context or zmq.Context().instance()\n\n        self._parent_drone = parent_drone\n\n        self._socket = self._context.socket(zmq.REQ)\n\n        self._socket.connect(f\"tcp://{self._parent_drone._ip}:5556\")\n\n        self._requests_to_send = queue.Queue()\n\n        self._exit_flag = threading.Event()\n\n    @staticmethod\n\n    def _get_client_info() -&gt; blueye.protocol.ClientInfo:\n\n        client_info = blueye.protocol.ClientInfo(\n\n            type=\"SDK\",\n\n            version=f\"{importlib.metadata.version('blueye.sdk')}\",\n\n            device_type=\"Computer\",\n\n            platform=f\"{platform.system()}\",\n\n            platform_version=f\"{platform.release()}\",\n\n            name=f\"{platform.node()}\",\n\n        )\n\n        return client_info\n\n    @staticmethod\n\n    def _parse_type_to_string(msg: proto.message.MessageMeta | str) -&gt; str:\n\n        message_type = (\n\n            msg.meta.full_name.replace(\"blueye.protocol.\", \"\")\n\n            if type(msg) is proto.message.MessageMeta\n\n            else msg.replace(\"blueye.protocol.\", \"\")\n\n        )\n\n        return message_type\n\n    def run(self):\n\n        while not self._exit_flag.is_set():\n\n            try:\n\n                msg, response_type, response_callback_queue = self._requests_to_send.get(\n\n                    timeout=0.1\n\n                )\n\n                self._socket.send_multipart(\n\n                    [\n\n                        bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"),\n\n                        msg.__class__.serialize(msg),\n\n                    ]\n\n                )\n\n            except queue.Empty:\n\n                # No requests to send, so we can\n\n                continue\n\n            # TODO: Deal with timeout\n\n            resp = self._socket.recv_multipart()\n\n            resp_deserialized = response_type.deserialize(resp[1])\n\n            response_callback_queue.put(resp_deserialized)\n\n    def stop(self):\n\n        self._exit_flag.set()\n\n    def _send_request_get_response(\n\n        self,\n\n        request: proto.message.Message,\n\n        expected_response: proto.message.Message,\n\n        timeout: float,\n\n    ):\n\n        response_queue = queue.Queue(maxsize=1)\n\n        self._requests_to_send.put((request, expected_response, response_queue))\n\n        try:\n\n            return response_queue.get(timeout=timeout)\n\n        except queue.Empty:\n\n            raise blueye.protocol.exceptions.ResponseTimeout(\n\n                \"No response received from drone before timeout\"\n\n            )\n\n    def ping(self, timeout: float) -&gt; blueye.protocol.PingRep:\n\n        request = blueye.protocol.PingReq()\n\n        return self._send_request_get_response(request, blueye.protocol.PingRep, timeout)\n\n    def get_camera_parameters(\n\n        self, camera: blueye.protocol.Camera, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.CameraParameters:\n\n        request = blueye.protocol.GetCameraParametersReq(camera=camera)\n\n        response = self._send_request_get_response(\n\n            request, blueye.protocol.GetCameraParametersRep, timeout\n\n        )\n\n        return response.camera_parameters\n\n    def set_camera_parameters(\n\n        self,\n\n        parameters: blueye.protocol.CameraParameters,\n\n        timeout: float = 0.05,\n\n    ):\n\n        request = blueye.protocol.SetCameraParametersReq(camera_parameters=parameters)\n\n        return self._send_request_get_response(\n\n            request, blueye.protocol.SetCameraParametersRep, timeout\n\n        )\n\n    def get_overlay_parameters(self, timeout: float = 0.05) -&gt; blueye.protocol.OverlayParameters:\n\n        request = blueye.protocol.GetOverlayParametersReq()\n\n        response = self._send_request_get_response(\n\n            request, blueye.protocol.GetOverlayParametersRep, timeout\n\n        )\n\n        return response.overlay_parameters\n\n    def set_overlay_parameters(\n\n        self, parameters: blueye.protocol.OverlayParameters, timeout: float = 0.05\n\n    ):\n\n        request = blueye.protocol.SetOverlayParametersReq(overlay_parameters=parameters)\n\n        return self._send_request_get_response(\n\n            request, blueye.protocol.SetOverlayParametersRep, timeout\n\n        )\n\n    def sync_time(self, time: int, timeout: float = 0.05):\n\n        request = blueye.protocol.SyncTimeReq(\n\n            time={\"unix_timestamp\": {\"seconds\": time, \"nanos\": 0}}\n\n        )\n\n        return self._send_request_get_response(request, blueye.protocol.SyncTimeRep, timeout)\n\n    def connect_client(\n\n        self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.ConnectClientRep:\n\n        client = client_info or self._get_client_info()\n\n        request = blueye.protocol.ConnectClientReq(client_info=client)\n\n        return self._send_request_get_response(request, blueye.protocol.ConnectClientRep, timeout)\n\n    def disconnect_client(\n\n        self, client_id: int, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.DisconnectClientRep:\n\n        request = blueye.protocol.DisconnectClientReq(client_id=client_id)\n\n        return self._send_request_get_response(\n\n            request, blueye.protocol.DisconnectClientRep, timeout\n\n        )\n\n    def set_telemetry_msg_publish_frequency(\n\n        self, msg: proto.message.MessageMeta | str, frequency: float, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.SetPubFrequencyRep:\n\n        message_type = self._parse_type_to_string(msg)\n\n        request = blueye.protocol.SetPubFrequencyReq(\n\n            message_type=message_type,\n\n            frequency=frequency,\n\n        )\n\n        return self._send_request_get_response(request, blueye.protocol.SetPubFrequencyRep, timeout)\n\n    def get_telemetry_msg(self, msg: proto.message.MessageMeta | str, timeout: float = 0.05):\n\n        message_type = self._parse_type_to_string(msg)\n\n        request = blueye.protocol.GetTelemetryReq(message_type=message_type)\n\n        return self._send_request_get_response(request, blueye.protocol.GetTelemetryRep, timeout)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#ancestors-in-mro_2","title":"Ancestors (in MRO)","text":"<ul> <li>threading.Thread</li> </ul>"},{"location":"reference/blueye/sdk/connection/#instance-variables_1","title":"Instance variables","text":"<pre><code>daemon\n</code></pre> <p>A boolean value indicating whether this thread is a daemon thread.</p> <p>This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False.</p> <p>The entire Python program exits when only daemon threads are left.</p> <pre><code>ident\n</code></pre> <p>Thread identifier of this thread or None if it has not been started.</p> <p>This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</p> <pre><code>name\n</code></pre> <p>A string used for identification purposes only.</p> <p>It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.</p> <pre><code>native_id\n</code></pre> <p>Native integral thread ID of this thread, or None if it has not been started.</p> <p>This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.</p>"},{"location":"reference/blueye/sdk/connection/#methods_2","title":"Methods","text":""},{"location":"reference/blueye/sdk/connection/#connect_client","title":"connect_client","text":"<pre><code>def connect_client(\n    self,\n    client_info: 'blueye.protocol.ClientInfo' = None,\n    timeout: 'float' = 0.05\n) -&gt; 'blueye.protocol.ConnectClientRep'\n</code></pre> View Source <pre><code>    def connect_client(\n\n        self, client_info: blueye.protocol.ClientInfo = None, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.ConnectClientRep:\n\n        client = client_info or self._get_client_info()\n\n        request = blueye.protocol.ConnectClientReq(client_info=client)\n\n        return self._send_request_get_response(request, blueye.protocol.ConnectClientRep, timeout)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#disconnect_client","title":"disconnect_client","text":"<pre><code>def disconnect_client(\n    self,\n    client_id: 'int',\n    timeout: 'float' = 0.05\n) -&gt; 'blueye.protocol.DisconnectClientRep'\n</code></pre> View Source <pre><code>    def disconnect_client(\n\n        self, client_id: int, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.DisconnectClientRep:\n\n        request = blueye.protocol.DisconnectClientReq(client_id=client_id)\n\n        return self._send_request_get_response(\n\n            request, blueye.protocol.DisconnectClientRep, timeout\n\n        )\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#getname_1","title":"getName","text":"<pre><code>def getName(\n    self\n)\n</code></pre> <p>Return a string used for identification purposes only.</p> <p>This method is deprecated, use the name attribute instead.</p> View Source <pre><code>    def getName(self):\n\n        \"\"\"Return a string used for identification purposes only.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('getName() is deprecated, get the name attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        return self.name\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#get_camera_parameters","title":"get_camera_parameters","text":"<pre><code>def get_camera_parameters(\n    self,\n    camera: 'blueye.protocol.Camera',\n    timeout: 'float' = 0.05\n) -&gt; 'blueye.protocol.CameraParameters'\n</code></pre> View Source <pre><code>    def get_camera_parameters(\n\n        self, camera: blueye.protocol.Camera, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.CameraParameters:\n\n        request = blueye.protocol.GetCameraParametersReq(camera=camera)\n\n        response = self._send_request_get_response(\n\n            request, blueye.protocol.GetCameraParametersRep, timeout\n\n        )\n\n        return response.camera_parameters\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#get_overlay_parameters","title":"get_overlay_parameters","text":"<pre><code>def get_overlay_parameters(\n    self,\n    timeout: 'float' = 0.05\n) -&gt; 'blueye.protocol.OverlayParameters'\n</code></pre> View Source <pre><code>    def get_overlay_parameters(self, timeout: float = 0.05) -&gt; blueye.protocol.OverlayParameters:\n\n        request = blueye.protocol.GetOverlayParametersReq()\n\n        response = self._send_request_get_response(\n\n            request, blueye.protocol.GetOverlayParametersRep, timeout\n\n        )\n\n        return response.overlay_parameters\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#get_telemetry_msg","title":"get_telemetry_msg","text":"<pre><code>def get_telemetry_msg(\n    self,\n    msg: 'proto.message.MessageMeta | str',\n    timeout: 'float' = 0.05\n)\n</code></pre> View Source <pre><code>    def get_telemetry_msg(self, msg: proto.message.MessageMeta | str, timeout: float = 0.05):\n\n        message_type = self._parse_type_to_string(msg)\n\n        request = blueye.protocol.GetTelemetryReq(message_type=message_type)\n\n        return self._send_request_get_response(request, blueye.protocol.GetTelemetryRep, timeout)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#isdaemon_1","title":"isDaemon","text":"<pre><code>def isDaemon(\n    self\n)\n</code></pre> <p>Return whether this thread is a daemon.</p> <p>This method is deprecated, use the daemon attribute instead.</p> View Source <pre><code>    def isDaemon(self):\n\n        \"\"\"Return whether this thread is a daemon.\n\n        This method is deprecated, use the daemon attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('isDaemon() is deprecated, get the daemon attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        return self.daemon\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#is_alive_1","title":"is_alive","text":"<pre><code>def is_alive(\n    self\n)\n</code></pre> <p>Return whether the thread is alive.</p> <p>This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate().</p> View Source <pre><code>    def is_alive(self):\n\n        \"\"\"Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n\n        after the run() method terminates. See also the module function\n\n        enumerate().\n\n        \"\"\"\n\n        assert self._initialized, \"Thread.__init__() not called\"\n\n        if self._is_stopped or not self._started.is_set():\n\n            return False\n\n        self._wait_for_tstate_lock(False)\n\n        return not self._is_stopped\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#join_1","title":"join","text":"<pre><code>def join(\n    self,\n    timeout=None\n)\n</code></pre> <p>Wait until the thread terminates.</p> <p>This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs.</p> <p>When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out.</p> <p>When the timeout argument is not present or None, the operation will block until the thread terminates.</p> <p>A thread can be join()ed many times.</p> <p>join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception.</p> View Source <pre><code>    def join(self, timeout=None):\n\n        \"\"\"Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n\n        called terminates -- either normally or through an unhandled exception\n\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n\n        floating point number specifying a timeout for the operation in seconds\n\n        (or fractions thereof). As join() always returns None, you must call\n\n        is_alive() after join() to decide whether a timeout happened -- if the\n\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n\n        thread as that would cause a deadlock. It is also an error to join() a\n\n        thread before it has been started and attempts to do so raises the same\n\n        exception.\n\n        \"\"\"\n\n        if not self._initialized:\n\n            raise RuntimeError(\"Thread.__init__() not called\")\n\n        if not self._started.is_set():\n\n            raise RuntimeError(\"cannot join thread before it is started\")\n\n        if self is current_thread():\n\n            raise RuntimeError(\"cannot join current thread\")\n\n        if timeout is None:\n\n            self._wait_for_tstate_lock()\n\n        else:\n\n            # the behavior of a negative timeout isn't documented, but\n\n            # historically .join(timeout=x) for x&lt;0 has acted as if timeout=0\n\n            self._wait_for_tstate_lock(timeout=max(timeout, 0))\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#ping","title":"ping","text":"<pre><code>def ping(\n    self,\n    timeout: 'float'\n) -&gt; 'blueye.protocol.PingRep'\n</code></pre> View Source <pre><code>    def ping(self, timeout: float) -&gt; blueye.protocol.PingRep:\n\n        request = blueye.protocol.PingReq()\n\n        return self._send_request_get_response(request, blueye.protocol.PingRep, timeout)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#run_1","title":"run","text":"<pre><code>def run(\n    self\n)\n</code></pre> <p>Method representing the thread's activity.</p> <p>You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively.</p> View Source <pre><code>    def run(self):\n\n        while not self._exit_flag.is_set():\n\n            try:\n\n                msg, response_type, response_callback_queue = self._requests_to_send.get(\n\n                    timeout=0.1\n\n                )\n\n                self._socket.send_multipart(\n\n                    [\n\n                        bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"),\n\n                        msg.__class__.serialize(msg),\n\n                    ]\n\n                )\n\n            except queue.Empty:\n\n                # No requests to send, so we can\n\n                continue\n\n            # TODO: Deal with timeout\n\n            resp = self._socket.recv_multipart()\n\n            resp_deserialized = response_type.deserialize(resp[1])\n\n            response_callback_queue.put(resp_deserialized)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#setdaemon_1","title":"setDaemon","text":"<pre><code>def setDaemon(\n    self,\n    daemonic\n)\n</code></pre> <p>Set whether this thread is a daemon.</p> <p>This method is deprecated, use the .daemon property instead.</p> View Source <pre><code>    def setDaemon(self, daemonic):\n\n        \"\"\"Set whether this thread is a daemon.\n\n        This method is deprecated, use the .daemon property instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('setDaemon() is deprecated, set the daemon attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        self.daemon = daemonic\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#setname_1","title":"setName","text":"<pre><code>def setName(\n    self,\n    name\n)\n</code></pre> <p>Set the name string for this thread.</p> <p>This method is deprecated, use the name attribute instead.</p> View Source <pre><code>    def setName(self, name):\n\n        \"\"\"Set the name string for this thread.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('setName() is deprecated, set the name attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        self.name = name\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_camera_parameters","title":"set_camera_parameters","text":"<pre><code>def set_camera_parameters(\n    self,\n    parameters: 'blueye.protocol.CameraParameters',\n    timeout: 'float' = 0.05\n)\n</code></pre> View Source <pre><code>    def set_camera_parameters(\n\n        self,\n\n        parameters: blueye.protocol.CameraParameters,\n\n        timeout: float = 0.05,\n\n    ):\n\n        request = blueye.protocol.SetCameraParametersReq(camera_parameters=parameters)\n\n        return self._send_request_get_response(\n\n            request, blueye.protocol.SetCameraParametersRep, timeout\n\n        )\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_overlay_parameters","title":"set_overlay_parameters","text":"<pre><code>def set_overlay_parameters(\n    self,\n    parameters: 'blueye.protocol.OverlayParameters',\n    timeout: 'float' = 0.05\n)\n</code></pre> View Source <pre><code>    def set_overlay_parameters(\n\n        self, parameters: blueye.protocol.OverlayParameters, timeout: float = 0.05\n\n    ):\n\n        request = blueye.protocol.SetOverlayParametersReq(overlay_parameters=parameters)\n\n        return self._send_request_get_response(\n\n            request, blueye.protocol.SetOverlayParametersRep, timeout\n\n        )\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#set_telemetry_msg_publish_frequency","title":"set_telemetry_msg_publish_frequency","text":"<pre><code>def set_telemetry_msg_publish_frequency(\n    self,\n    msg: 'proto.message.MessageMeta | str',\n    frequency: 'float',\n    timeout: 'float' = 0.05\n) -&gt; 'blueye.protocol.SetPubFrequencyRep'\n</code></pre> View Source <pre><code>    def set_telemetry_msg_publish_frequency(\n\n        self, msg: proto.message.MessageMeta | str, frequency: float, timeout: float = 0.05\n\n    ) -&gt; blueye.protocol.SetPubFrequencyRep:\n\n        message_type = self._parse_type_to_string(msg)\n\n        request = blueye.protocol.SetPubFrequencyReq(\n\n            message_type=message_type,\n\n            frequency=frequency,\n\n        )\n\n        return self._send_request_get_response(request, blueye.protocol.SetPubFrequencyRep, timeout)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#start_1","title":"start","text":"<pre><code>def start(\n    self\n)\n</code></pre> <p>Start the thread's activity.</p> <p>It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control.</p> <p>This method will raise a RuntimeError if called more than once on the same thread object.</p> View Source <pre><code>    def start(self):\n\n        \"\"\"Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n\n        same thread object.\n\n        \"\"\"\n\n        if not self._initialized:\n\n            raise RuntimeError(\"thread.__init__() not called\")\n\n        if self._started.is_set():\n\n            raise RuntimeError(\"threads can only be started once\")\n\n        with _active_limbo_lock:\n\n            _limbo[self] = self\n\n        try:\n\n            _start_new_thread(self._bootstrap, ())\n\n        except Exception:\n\n            with _active_limbo_lock:\n\n                del _limbo[self]\n\n            raise\n\n        self._started.wait()\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#stop_1","title":"stop","text":"<pre><code>def stop(\n    self\n)\n</code></pre> View Source <pre><code>    def stop(self):\n\n        self._exit_flag.set()\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#sync_time","title":"sync_time","text":"<pre><code>def sync_time(\n    self,\n    time: 'int',\n    timeout: 'float' = 0.05\n)\n</code></pre> View Source <pre><code>    def sync_time(self, time: int, timeout: float = 0.05):\n\n        request = blueye.protocol.SyncTimeReq(\n\n            time={\"unix_timestamp\": {\"seconds\": time, \"nanos\": 0}}\n\n        )\n\n        return self._send_request_get_response(request, blueye.protocol.SyncTimeRep, timeout)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#telemetryclient","title":"TelemetryClient","text":"<pre><code>class TelemetryClient(\n    parent_drone: \"'blueye.sdk.Drone'\",\n    context: 'zmq.Context' = None\n)\n</code></pre> <p>A class that represents a thread of control.</p> <p>This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass.</p> View Source <pre><code>class TelemetryClient(threading.Thread):\n\n    def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None):\n\n        super().__init__(daemon=True)\n\n        self._parent_drone = parent_drone\n\n        self._context = context or zmq.Context().instance()\n\n        self._socket = self._context.socket(zmq.SUB)\n\n        self._socket.connect(f\"tcp://{self._parent_drone._ip}:5555\")\n\n        self._socket.setsockopt_string(zmq.SUBSCRIBE, \"\")\n\n        self._exit_flag = threading.Event()\n\n        self._state_lock = threading.Lock()\n\n        self._callbacks: List[Callback] = []\n\n        self._state: Dict[proto.message.Message, bytes] = {}\n\n        \"\"\"`_state` is dictionary of the latest received messages, where the key is the protobuf\n\n        message class, eg. blueye.protocol.DepthTel and the value is the serialized protobuf\n\n        message\"\"\"\n\n    def _handle_message(self, msg: Tuple[bytes, bytes]):\n\n        msg_type_name = msg[0].decode(\"utf-8\").replace(\"blueye.protocol.\", \"\")\n\n        try:\n\n            msg_type = blueye.protocol.__getattribute__(msg_type_name)\n\n        except AttributeError:\n\n            # If a new telemetry message is introduced before the SDK is updated this can\n\n            # be a common occurence, so choosing to log with info instead of warning\n\n            logger.info(f\"Ignoring unknown message type: {msg_type_name}\")\n\n            return\n\n        msg_payload = msg[1]\n\n        with self._state_lock:\n\n            self._state[msg_type] = msg_payload\n\n        for callback in self._callbacks:\n\n            if msg_type in callback.message_filter or callback.message_filter == []:\n\n                if callback.pass_raw_data:\n\n                    callback.function(msg_type_name, msg_payload, **callback.kwargs)\n\n                else:\n\n                    msg_deserialized = msg_type.deserialize(msg_payload)\n\n                    callback.function(msg_type_name, msg_deserialized, **callback.kwargs)\n\n    def run(self):\n\n        poller = zmq.Poller()\n\n        poller.register(self._socket, zmq.POLLIN)\n\n        while not self._exit_flag.is_set():\n\n            events_to_be_processed = poller.poll(10)\n\n            if len(events_to_be_processed) &gt; 0:\n\n                msg = self._socket.recv_multipart()\n\n                self._handle_message(msg)\n\n    def add_callback(\n\n        self,\n\n        msg_filter: List[proto.message.Message],\n\n        callback_function: Callable[[str, proto.message.Message], None],\n\n        raw: bool,\n\n        **kwargs,\n\n    ):\n\n        uuid_hex = uuid.uuid1().hex\n\n        self._callbacks.append(Callback(msg_filter, callback_function, raw, uuid_hex, kwargs))\n\n        return uuid_hex\n\n    def remove_callback(self, callback_id):\n\n        try:\n\n            self._callbacks.pop([cb.uuid_hex for cb in self._callbacks].index(callback_id))\n\n        except ValueError:\n\n            logger.warning(f\"Callback with id {callback_id} not found, ignoring\")\n\n    def get(self, key: proto.message.Message):\n\n        with self._state_lock:\n\n            return self._state[key]\n\n    def stop(self):\n\n        self._exit_flag.set()\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#ancestors-in-mro_3","title":"Ancestors (in MRO)","text":"<ul> <li>threading.Thread</li> </ul>"},{"location":"reference/blueye/sdk/connection/#instance-variables_2","title":"Instance variables","text":"<pre><code>daemon\n</code></pre> <p>A boolean value indicating whether this thread is a daemon thread.</p> <p>This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False.</p> <p>The entire Python program exits when only daemon threads are left.</p> <pre><code>ident\n</code></pre> <p>Thread identifier of this thread or None if it has not been started.</p> <p>This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</p> <pre><code>name\n</code></pre> <p>A string used for identification purposes only.</p> <p>It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.</p> <pre><code>native_id\n</code></pre> <p>Native integral thread ID of this thread, or None if it has not been started.</p> <p>This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.</p>"},{"location":"reference/blueye/sdk/connection/#methods_3","title":"Methods","text":""},{"location":"reference/blueye/sdk/connection/#add_callback","title":"add_callback","text":"<pre><code>def add_callback(\n    self,\n    msg_filter: 'List[proto.message.Message]',\n    callback_function: 'Callable[[str, proto.message.Message], None]',\n    raw: 'bool',\n    **kwargs\n)\n</code></pre> View Source <pre><code>    def add_callback(\n\n        self,\n\n        msg_filter: List[proto.message.Message],\n\n        callback_function: Callable[[str, proto.message.Message], None],\n\n        raw: bool,\n\n        **kwargs,\n\n    ):\n\n        uuid_hex = uuid.uuid1().hex\n\n        self._callbacks.append(Callback(msg_filter, callback_function, raw, uuid_hex, kwargs))\n\n        return uuid_hex\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#get","title":"get","text":"<pre><code>def get(\n    self,\n    key: 'proto.message.Message'\n)\n</code></pre> View Source <pre><code>    def get(self, key: proto.message.Message):\n\n        with self._state_lock:\n\n            return self._state[key]\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#getname_2","title":"getName","text":"<pre><code>def getName(\n    self\n)\n</code></pre> <p>Return a string used for identification purposes only.</p> <p>This method is deprecated, use the name attribute instead.</p> View Source <pre><code>    def getName(self):\n\n        \"\"\"Return a string used for identification purposes only.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('getName() is deprecated, get the name attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        return self.name\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#isdaemon_2","title":"isDaemon","text":"<pre><code>def isDaemon(\n    self\n)\n</code></pre> <p>Return whether this thread is a daemon.</p> <p>This method is deprecated, use the daemon attribute instead.</p> View Source <pre><code>    def isDaemon(self):\n\n        \"\"\"Return whether this thread is a daemon.\n\n        This method is deprecated, use the daemon attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('isDaemon() is deprecated, get the daemon attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        return self.daemon\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#is_alive_2","title":"is_alive","text":"<pre><code>def is_alive(\n    self\n)\n</code></pre> <p>Return whether the thread is alive.</p> <p>This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate().</p> View Source <pre><code>    def is_alive(self):\n\n        \"\"\"Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n\n        after the run() method terminates. See also the module function\n\n        enumerate().\n\n        \"\"\"\n\n        assert self._initialized, \"Thread.__init__() not called\"\n\n        if self._is_stopped or not self._started.is_set():\n\n            return False\n\n        self._wait_for_tstate_lock(False)\n\n        return not self._is_stopped\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#join_2","title":"join","text":"<pre><code>def join(\n    self,\n    timeout=None\n)\n</code></pre> <p>Wait until the thread terminates.</p> <p>This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs.</p> <p>When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out.</p> <p>When the timeout argument is not present or None, the operation will block until the thread terminates.</p> <p>A thread can be join()ed many times.</p> <p>join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception.</p> View Source <pre><code>    def join(self, timeout=None):\n\n        \"\"\"Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n\n        called terminates -- either normally or through an unhandled exception\n\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n\n        floating point number specifying a timeout for the operation in seconds\n\n        (or fractions thereof). As join() always returns None, you must call\n\n        is_alive() after join() to decide whether a timeout happened -- if the\n\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n\n        thread as that would cause a deadlock. It is also an error to join() a\n\n        thread before it has been started and attempts to do so raises the same\n\n        exception.\n\n        \"\"\"\n\n        if not self._initialized:\n\n            raise RuntimeError(\"Thread.__init__() not called\")\n\n        if not self._started.is_set():\n\n            raise RuntimeError(\"cannot join thread before it is started\")\n\n        if self is current_thread():\n\n            raise RuntimeError(\"cannot join current thread\")\n\n        if timeout is None:\n\n            self._wait_for_tstate_lock()\n\n        else:\n\n            # the behavior of a negative timeout isn't documented, but\n\n            # historically .join(timeout=x) for x&lt;0 has acted as if timeout=0\n\n            self._wait_for_tstate_lock(timeout=max(timeout, 0))\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#remove_callback","title":"remove_callback","text":"<pre><code>def remove_callback(\n    self,\n    callback_id\n)\n</code></pre> View Source <pre><code>    def remove_callback(self, callback_id):\n\n        try:\n\n            self._callbacks.pop([cb.uuid_hex for cb in self._callbacks].index(callback_id))\n\n        except ValueError:\n\n            logger.warning(f\"Callback with id {callback_id} not found, ignoring\")\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#run_2","title":"run","text":"<pre><code>def run(\n    self\n)\n</code></pre> <p>Method representing the thread's activity.</p> <p>You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively.</p> View Source <pre><code>    def run(self):\n\n        poller = zmq.Poller()\n\n        poller.register(self._socket, zmq.POLLIN)\n\n        while not self._exit_flag.is_set():\n\n            events_to_be_processed = poller.poll(10)\n\n            if len(events_to_be_processed) &gt; 0:\n\n                msg = self._socket.recv_multipart()\n\n                self._handle_message(msg)\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#setdaemon_2","title":"setDaemon","text":"<pre><code>def setDaemon(\n    self,\n    daemonic\n)\n</code></pre> <p>Set whether this thread is a daemon.</p> <p>This method is deprecated, use the .daemon property instead.</p> View Source <pre><code>    def setDaemon(self, daemonic):\n\n        \"\"\"Set whether this thread is a daemon.\n\n        This method is deprecated, use the .daemon property instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('setDaemon() is deprecated, set the daemon attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        self.daemon = daemonic\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#setname_2","title":"setName","text":"<pre><code>def setName(\n    self,\n    name\n)\n</code></pre> <p>Set the name string for this thread.</p> <p>This method is deprecated, use the name attribute instead.</p> View Source <pre><code>    def setName(self, name):\n\n        \"\"\"Set the name string for this thread.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('setName() is deprecated, set the name attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        self.name = name\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#start_2","title":"start","text":"<pre><code>def start(\n    self\n)\n</code></pre> <p>Start the thread's activity.</p> <p>It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control.</p> <p>This method will raise a RuntimeError if called more than once on the same thread object.</p> View Source <pre><code>    def start(self):\n\n        \"\"\"Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n\n        same thread object.\n\n        \"\"\"\n\n        if not self._initialized:\n\n            raise RuntimeError(\"thread.__init__() not called\")\n\n        if self._started.is_set():\n\n            raise RuntimeError(\"threads can only be started once\")\n\n        with _active_limbo_lock:\n\n            _limbo[self] = self\n\n        try:\n\n            _start_new_thread(self._bootstrap, ())\n\n        except Exception:\n\n            with _active_limbo_lock:\n\n                del _limbo[self]\n\n            raise\n\n        self._started.wait()\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#stop_2","title":"stop","text":"<pre><code>def stop(\n    self\n)\n</code></pre> View Source <pre><code>    def stop(self):\n\n        self._exit_flag.set()\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#watchdogpublisher","title":"WatchdogPublisher","text":"<pre><code>class WatchdogPublisher(\n    parent_drone: \"'blueye.sdk.Drone'\",\n    context: 'zmq.Context' = None\n)\n</code></pre> <p>A class that represents a thread of control.</p> <p>This class can be safely subclassed in a limited fashion. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the run() method in a subclass.</p> View Source <pre><code>class WatchdogPublisher(threading.Thread):\n\n    def __init__(self, parent_drone: \"blueye.sdk.Drone\", context: zmq.Context = None):\n\n        super().__init__(daemon=True)\n\n        self._parent_drone = parent_drone\n\n        self._context = context or zmq.Context().instance()\n\n        self._socket = self._context.socket(zmq.PUB)\n\n        self._socket.connect(f\"tcp://{self._parent_drone._ip}:5557\")\n\n        self._exit_flag = threading.Event()\n\n    def run(self):\n\n        duration = 0\n\n        WATCHDOG_DELAY = 1\n\n        while not self._exit_flag.wait(WATCHDOG_DELAY):\n\n            self.pet_watchdog(duration)\n\n            duration += 1\n\n    def pet_watchdog(self, duration):\n\n        msg = blueye.protocol.WatchdogCtrl(\n\n            connection_duration={\"value\": duration}, client_id=self._parent_drone.client_id\n\n        )\n\n        self._socket.send_multipart(\n\n            [\n\n                bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"),\n\n                blueye.protocol.WatchdogCtrl.serialize(msg),\n\n            ]\n\n        )\n\n    def stop(self):\n\n        \"\"\"Stop the watchdog thread started by run()\"\"\"\n\n        self._exit_flag.set()\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#ancestors-in-mro_4","title":"Ancestors (in MRO)","text":"<ul> <li>threading.Thread</li> </ul>"},{"location":"reference/blueye/sdk/connection/#instance-variables_3","title":"Instance variables","text":"<pre><code>daemon\n</code></pre> <p>A boolean value indicating whether this thread is a daemon thread.</p> <p>This must be set before start() is called, otherwise RuntimeError is raised. Its initial value is inherited from the creating thread; the main thread is not a daemon thread and therefore all threads created in the main thread default to daemon = False.</p> <p>The entire Python program exits when only daemon threads are left.</p> <pre><code>ident\n</code></pre> <p>Thread identifier of this thread or None if it has not been started.</p> <p>This is a nonzero integer. See the get_ident() function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</p> <pre><code>name\n</code></pre> <p>A string used for identification purposes only.</p> <p>It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.</p> <pre><code>native_id\n</code></pre> <p>Native integral thread ID of this thread, or None if it has not been started.</p> <p>This is a non-negative integer. See the get_native_id() function. This represents the Thread ID as reported by the kernel.</p>"},{"location":"reference/blueye/sdk/connection/#methods_4","title":"Methods","text":""},{"location":"reference/blueye/sdk/connection/#getname_3","title":"getName","text":"<pre><code>def getName(\n    self\n)\n</code></pre> <p>Return a string used for identification purposes only.</p> <p>This method is deprecated, use the name attribute instead.</p> View Source <pre><code>    def getName(self):\n\n        \"\"\"Return a string used for identification purposes only.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('getName() is deprecated, get the name attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        return self.name\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#isdaemon_3","title":"isDaemon","text":"<pre><code>def isDaemon(\n    self\n)\n</code></pre> <p>Return whether this thread is a daemon.</p> <p>This method is deprecated, use the daemon attribute instead.</p> View Source <pre><code>    def isDaemon(self):\n\n        \"\"\"Return whether this thread is a daemon.\n\n        This method is deprecated, use the daemon attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('isDaemon() is deprecated, get the daemon attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        return self.daemon\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#is_alive_3","title":"is_alive","text":"<pre><code>def is_alive(\n    self\n)\n</code></pre> <p>Return whether the thread is alive.</p> <p>This method returns True just before the run() method starts until just after the run() method terminates. See also the module function enumerate().</p> View Source <pre><code>    def is_alive(self):\n\n        \"\"\"Return whether the thread is alive.\n\n        This method returns True just before the run() method starts until just\n\n        after the run() method terminates. See also the module function\n\n        enumerate().\n\n        \"\"\"\n\n        assert self._initialized, \"Thread.__init__() not called\"\n\n        if self._is_stopped or not self._started.is_set():\n\n            return False\n\n        self._wait_for_tstate_lock(False)\n\n        return not self._is_stopped\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#join_3","title":"join","text":"<pre><code>def join(\n    self,\n    timeout=None\n)\n</code></pre> <p>Wait until the thread terminates.</p> <p>This blocks the calling thread until the thread whose join() method is called terminates -- either normally or through an unhandled exception or until the optional timeout occurs.</p> <p>When the timeout argument is present and not None, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As join() always returns None, you must call is_alive() after join() to decide whether a timeout happened -- if the thread is still alive, the join() call timed out.</p> <p>When the timeout argument is not present or None, the operation will block until the thread terminates.</p> <p>A thread can be join()ed many times.</p> <p>join() raises a RuntimeError if an attempt is made to join the current thread as that would cause a deadlock. It is also an error to join() a thread before it has been started and attempts to do so raises the same exception.</p> View Source <pre><code>    def join(self, timeout=None):\n\n        \"\"\"Wait until the thread terminates.\n\n        This blocks the calling thread until the thread whose join() method is\n\n        called terminates -- either normally or through an unhandled exception\n\n        or until the optional timeout occurs.\n\n        When the timeout argument is present and not None, it should be a\n\n        floating point number specifying a timeout for the operation in seconds\n\n        (or fractions thereof). As join() always returns None, you must call\n\n        is_alive() after join() to decide whether a timeout happened -- if the\n\n        thread is still alive, the join() call timed out.\n\n        When the timeout argument is not present or None, the operation will\n\n        block until the thread terminates.\n\n        A thread can be join()ed many times.\n\n        join() raises a RuntimeError if an attempt is made to join the current\n\n        thread as that would cause a deadlock. It is also an error to join() a\n\n        thread before it has been started and attempts to do so raises the same\n\n        exception.\n\n        \"\"\"\n\n        if not self._initialized:\n\n            raise RuntimeError(\"Thread.__init__() not called\")\n\n        if not self._started.is_set():\n\n            raise RuntimeError(\"cannot join thread before it is started\")\n\n        if self is current_thread():\n\n            raise RuntimeError(\"cannot join current thread\")\n\n        if timeout is None:\n\n            self._wait_for_tstate_lock()\n\n        else:\n\n            # the behavior of a negative timeout isn't documented, but\n\n            # historically .join(timeout=x) for x&lt;0 has acted as if timeout=0\n\n            self._wait_for_tstate_lock(timeout=max(timeout, 0))\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#pet_watchdog","title":"pet_watchdog","text":"<pre><code>def pet_watchdog(\n    self,\n    duration\n)\n</code></pre> View Source <pre><code>    def pet_watchdog(self, duration):\n\n        msg = blueye.protocol.WatchdogCtrl(\n\n            connection_duration={\"value\": duration}, client_id=self._parent_drone.client_id\n\n        )\n\n        self._socket.send_multipart(\n\n            [\n\n                bytes(msg._pb.DESCRIPTOR.full_name, \"utf-8\"),\n\n                blueye.protocol.WatchdogCtrl.serialize(msg),\n\n            ]\n\n        )\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#run_3","title":"run","text":"<pre><code>def run(\n    self\n)\n</code></pre> <p>Method representing the thread's activity.</p> <p>You may override this method in a subclass. The standard run() method invokes the callable object passed to the object's constructor as the target argument, if any, with sequential and keyword arguments taken from the args and kwargs arguments, respectively.</p> View Source <pre><code>    def run(self):\n\n        duration = 0\n\n        WATCHDOG_DELAY = 1\n\n        while not self._exit_flag.wait(WATCHDOG_DELAY):\n\n            self.pet_watchdog(duration)\n\n            duration += 1\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#setdaemon_3","title":"setDaemon","text":"<pre><code>def setDaemon(\n    self,\n    daemonic\n)\n</code></pre> <p>Set whether this thread is a daemon.</p> <p>This method is deprecated, use the .daemon property instead.</p> View Source <pre><code>    def setDaemon(self, daemonic):\n\n        \"\"\"Set whether this thread is a daemon.\n\n        This method is deprecated, use the .daemon property instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('setDaemon() is deprecated, set the daemon attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        self.daemon = daemonic\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#setname_3","title":"setName","text":"<pre><code>def setName(\n    self,\n    name\n)\n</code></pre> <p>Set the name string for this thread.</p> <p>This method is deprecated, use the name attribute instead.</p> View Source <pre><code>    def setName(self, name):\n\n        \"\"\"Set the name string for this thread.\n\n        This method is deprecated, use the name attribute instead.\n\n        \"\"\"\n\n        import warnings\n\n        warnings.warn('setName() is deprecated, set the name attribute instead',\n\n                      DeprecationWarning, stacklevel=2)\n\n        self.name = name\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#start_3","title":"start","text":"<pre><code>def start(\n    self\n)\n</code></pre> <p>Start the thread's activity.</p> <p>It must be called at most once per thread object. It arranges for the object's run() method to be invoked in a separate thread of control.</p> <p>This method will raise a RuntimeError if called more than once on the same thread object.</p> View Source <pre><code>    def start(self):\n\n        \"\"\"Start the thread's activity.\n\n        It must be called at most once per thread object. It arranges for the\n\n        object's run() method to be invoked in a separate thread of control.\n\n        This method will raise a RuntimeError if called more than once on the\n\n        same thread object.\n\n        \"\"\"\n\n        if not self._initialized:\n\n            raise RuntimeError(\"thread.__init__() not called\")\n\n        if self._started.is_set():\n\n            raise RuntimeError(\"threads can only be started once\")\n\n        with _active_limbo_lock:\n\n            _limbo[self] = self\n\n        try:\n\n            _start_new_thread(self._bootstrap, ())\n\n        except Exception:\n\n            with _active_limbo_lock:\n\n                del _limbo[self]\n\n            raise\n\n        self._started.wait()\n</code></pre>"},{"location":"reference/blueye/sdk/connection/#stop_3","title":"stop","text":"<pre><code>def stop(\n    self\n)\n</code></pre> <p>Stop the watchdog thread started by run()</p> View Source <pre><code>    def stop(self):\n\n        \"\"\"Stop the watchdog thread started by run()\"\"\"\n\n        self._exit_flag.set()\n</code></pre>"},{"location":"reference/blueye/sdk/constants/","title":"Module blueye.sdk.constants","text":"<p>This file contains constants used by the SDK.</p> View Source <pre><code>\"\"\"\n\nThis file contains constants used by the SDK.\n\n\"\"\"\n\nclass WaterDensities:\n\n    \"\"\"\n\n    Various typical densities for salt water (in kilograms/liter)\n\n    \"\"\"\n\n    fresh = 0.997\n\n    brackish = 1.011\n\n    salty = 1.025\n</code></pre>"},{"location":"reference/blueye/sdk/constants/#classes","title":"Classes","text":""},{"location":"reference/blueye/sdk/constants/#waterdensities","title":"WaterDensities","text":"<pre><code>class WaterDensities(\n    /,\n    *args,\n    **kwargs\n)\n</code></pre> <p>Various typical densities for salt water (in kilograms/liter)</p> View Source <pre><code>class WaterDensities:\n\n    \"\"\"\n\n    Various typical densities for salt water (in kilograms/liter)\n\n    \"\"\"\n\n    fresh = 0.997\n\n    brackish = 1.011\n\n    salty = 1.025\n</code></pre>"},{"location":"reference/blueye/sdk/constants/#class-variables","title":"Class variables","text":"<pre><code>brackish\n</code></pre> <pre><code>fresh\n</code></pre> <pre><code>salty\n</code></pre>"},{"location":"reference/blueye/sdk/drone/","title":"Module blueye.sdk.drone","text":"View Source <pre><code>#!/usr/bin/env python3\n\nfrom __future__ import annotations\n\nimport logging\n\nimport time\n\nfrom datetime import datetime\n\nfrom json import JSONDecodeError\n\nfrom typing import Callable, Dict, List, Optional\n\nimport blueye.protocol\n\nimport proto\n\nimport requests\n\nfrom packaging import version\n\nfrom .battery import Battery\n\nfrom .camera import Camera\n\nfrom .connection import CtrlClient, ReqRepClient, TelemetryClient, WatchdogPublisher\n\nfrom .constants import WaterDensities\n\nfrom .guestport import GuestPortCamera, GuestPortLight, Peripheral, device_to_peripheral\n\nfrom .logs import LegacyLogs, Logs\n\nfrom .motion import Motion\n\nlogger = logging.getLogger(__name__)\n\nclass Config:\n\n    def __init__(self, parent_drone: \"Drone\"):\n\n        self._parent_drone = parent_drone\n\n        self._water_density = WaterDensities.salty\n\n    @property\n\n    def water_density(self):\n\n        \"\"\"Get or set the current water density for increased pressure sensor accuracy\n\n        Older software versions will assume a water density of 1.025 kilograms per liter.\n\n        The WaterDensities class contains typical densities for salty-, brackish-, and fresh water\n\n        (these are the same values that the Blueye app uses).\n\n        \"\"\"\n\n        return self._water_density\n\n    @water_density.setter\n\n    def water_density(self, density: float):\n\n        self._water_density = density\n\n        self._parent_drone._ctrl_client.set_water_density(density)\n\n    def set_drone_time(self, time: int):\n\n        \"\"\"Set the system for the drone\n\n        This method is used to set the system time for the drone. The argument `time` is expected to\n\n        be a Unix timestamp (ie. the number of seconds since the epoch).\n\n        \"\"\"\n\n        self._parent_drone._req_rep_client.sync_time(time)\n\nclass _NoConnectionClient:\n\n    \"\"\"A client that raises a ConnectionError if you use any of its functions\"\"\"\n\n    def __getattr__(self, name):\n\n        def method(*args, **kwargs):\n\n            raise ConnectionError(\n\n                \"The connection to the drone is not established, \"\n\n                \"try calling the connect method before retrying\"\n\n            )\n\n        return method\n\nclass Telemetry:\n\n    def __init__(self, parent_drone: \"Drone\"):\n\n        self._parent_drone = parent_drone\n\n    def set_msg_publish_frequency(self, msg: proto.message.Message, frequency: float):\n\n        \"\"\"Set the publishing frequency of a specific telemetry message\n\n        Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a\n\n        frequency outside the valid range, or an incorrect message type.\n\n        *Arguments*:\n\n        * msg (proto.message.Message): The message to set the frequency of. Needs to be one of the\n\n                                       messages in blueye.protocol that end in Tel, eg.\n\n                                       blueye.protocol.DepthTel\n\n        * frequency (float): The frequency in Hz. Valid range is (0 .. 100).\n\n        \"\"\"\n\n        resp = self._parent_drone._req_rep_client.set_telemetry_msg_publish_frequency(\n\n            msg, frequency\n\n        )\n\n        if not resp.success:\n\n            raise RuntimeError(\"Could not set telemetry message frequency\")\n\n    def add_msg_callback(\n\n        self,\n\n        msg_filter: List[proto.message.Message],\n\n        callback: Callable[[str, proto.message.Message], None],\n\n        raw: bool = False,\n\n        **kwargs,\n\n    ) -&gt; str:\n\n        \"\"\"Register a telemetry message callback\n\n        The callback is called each time a message of the type is received\n\n        *Arguments*:\n\n        * msg_filter: A list of message types to register the callback for.\n\n                      Eg. `[blueye.protocol.DepthTel, blueye.protocol.Imu1Tel]`. If the list is\n\n                      empty the callback will be registered for all message types\n\n        * callback: The callback function. It should be minimal and return as fast as possible to\n\n                    not block the telemetry communication. It is called with two arguments, the\n\n                    message type name and the message object\n\n        * raw: Pass the raw data instead of the deserialized message to the callback function\n\n        * kwargs: Additional keyword arguments to pass to the callback function\n\n        *Returns*:\n\n        * uuid: Callback id. Can be used to remove callback in the future\n\n        \"\"\"\n\n        uuid_hex = self._parent_drone._telemetry_watcher.add_callback(\n\n            msg_filter, callback, raw, **kwargs\n\n        )\n\n        return uuid_hex\n\n    def remove_msg_callback(self, callback_id: str) -&gt; Optional[str]:\n\n        \"\"\"Remove a telemetry message callback\n\n        *Arguments*:\n\n        * callback_id: The callback id\n\n        \"\"\"\n\n        self._parent_drone._telemetry_watcher.remove_callback(callback_id)\n\n    def get(\n\n        self, msg_type: proto.message.Message, deserialize=True\n\n    ) -&gt; Optional[proto.message.Message | bytes]:\n\n        \"\"\"Get the latest telemetry message of the specified type\n\n        *Arguments*:\n\n        * msg_type: The message type to get. Eg. blueye.protocol.DepthTel\n\n        * deserialize: If True, the message will be deserialized before being returned. If False,\n\n                       the raw bytes will be returned.\n\n        *Returns*:\n\n        * The latest message of the specified type, or None if no message has been received yet\n\n        \"\"\"\n\n        try:\n\n            msg = self._parent_drone._telemetry_watcher.get(msg_type)\n\n        except KeyError:\n\n            if version.parse(self._parent_drone.software_version_short) &gt;= version.parse(\"3.3\"):\n\n                msg = self._parent_drone._req_rep_client.get_telemetry_msg(msg_type).payload.value\n\n                if msg == b\"\":\n\n                    return None\n\n            else:\n\n                return None\n\n        if deserialize:\n\n            return msg_type.deserialize(msg)\n\n        else:\n\n            return msg\n\nclass Drone:\n\n    \"\"\"A class providing an interface to a Blueye drone's functions\n\n    Automatically connects to the drone using the default ip when instantiated, this behaviour can\n\n    be disabled by setting `auto_connect=False`.\n\n    \"\"\"\n\n    def __init__(\n\n        self,\n\n        ip=\"192.168.1.101\",\n\n        auto_connect=True,\n\n        timeout=3,\n\n        disconnect_other_clients=False,\n\n    ):\n\n        self._ip = ip\n\n        self.camera = Camera(self, is_guestport_camera=False)\n\n        self.motion = Motion(self)\n\n        self.logs = Logs(self)\n\n        self.legacy_logs = LegacyLogs(self)\n\n        self.config = Config(self)\n\n        self.battery = Battery(self)\n\n        self.telemetry = Telemetry(self)\n\n        self.connected = False\n\n        self.client_id: int = None\n\n        self.in_control: bool = False\n\n        self._watchdog_publisher = _NoConnectionClient()\n\n        self._telemetry_watcher = _NoConnectionClient()\n\n        self._req_rep_client = _NoConnectionClient()\n\n        self._ctrl_client = _NoConnectionClient()\n\n        self.peripherals: Optional[List[Peripheral]] = None\n\n        \"\"\"This list holds the peripherals connected to the drone. If it is `None`, then no\n\n        Guestport telemetry message has been recieved yet.\"\"\"\n\n        if auto_connect is True:\n\n            self.connect(timeout=timeout, disconnect_other_clients=disconnect_other_clients)\n\n    def _verify_required_blunux_version(self, requirement: str):\n\n        \"\"\"Verify that Blunux version is higher than requirement\n\n        requirement needs to be a string that's able to be parsed by version.parse()\n\n        Raises a RuntimeError if the Blunux version of the connected drone does not match or exceed\n\n        the requirement.\n\n        \"\"\"\n\n        if version.parse(self.software_version_short) &lt; version.parse(requirement):\n\n            raise RuntimeError(\n\n                f\"Blunux version of connected drone is {self.software_version_short}. Version \"\n\n                f\"{requirement} or higher is required.\"\n\n            )\n\n    def _update_drone_info(self, timeout: float = 3):\n\n        \"\"\"Request and store information about the connected drone\"\"\"\n\n        try:\n\n            response = requests.get(\n\n                f\"http://{self._ip}/diagnostics/drone_info\", timeout=timeout\n\n            ).json()\n\n        except (\n\n            requests.ConnectTimeout,\n\n            requests.ReadTimeout,\n\n            requests.ConnectionError,\n\n            JSONDecodeError,\n\n        ) as e:\n\n            raise ConnectionError(\"Could not establish connection with drone\") from e\n\n        try:\n\n            self.features = list(filter(None, response[\"features\"].split(\",\")))\n\n        except KeyError:\n\n            # Drone versions older than 1.4.7 did not have this field.\n\n            self.features = []\n\n        self.software_version = response[\"sw_version\"]\n\n        self.software_version_short = self.software_version.split(\"-\")[0]\n\n        self.serial_number = response[\"serial_number\"]\n\n        self.uuid = response[\"hardware_id\"]\n\n    @staticmethod\n\n    def _drone_info_callback(msg_type: str, msg: blueye.protocol.DroneInfoTel, drone: Drone):\n\n        # Check if the GuestPortInfo has been initialized\n\n        if msg.drone_info.gp._pb.ByteSize() != 0:\n\n            drone._create_peripherals_from_drone_info(msg.drone_info.gp)\n\n        # Remove the callback after the first message has been received\n\n        drone.telemetry.remove_msg_callback(drone._drone_info_cb_id)\n\n    def _create_peripherals_from_drone_info(self, gp_info: blueye.protocol.GuestPortInfo):\n\n        self.peripherals = []\n\n        for port in (gp_info.gp1, gp_info.gp2, gp_info.gp3):\n\n            for device in port.device_list.devices:\n\n                peripheral = device_to_peripheral(self, port.guest_port_number, device)\n\n                self.peripherals.append(peripheral)\n\n                if isinstance(peripheral, GuestPortLight):\n\n                    self.external_light = peripheral\n\n                elif isinstance(peripheral, GuestPortCamera):\n\n                    self.external_camera = peripheral\n\n    def connect(\n\n        self,\n\n        client_info: blueye.protocol.ClientInfo = None,\n\n        timeout: float = 4,\n\n        disconnect_other_clients: bool = False,\n\n    ):\n\n        \"\"\"Establish a connection to the drone\n\n        Spawns of several threads for receiving telemetry, sending control messages and publishing\n\n        watchdog messages.\n\n        When a watchdog message is receieved by the drone the thrusters are armed, so to stop the\n\n        drone from moving unexpectedly when connecting all thruster set points are set to zero when\n\n        connecting.\n\n        ** Arguments **\n\n        - *client_info*: Information about the client connecting, if None the SDK will attempt to\n\n                         read it from the environment\n\n        - *timeout*: Seconds to wait for connection. The first connection on boot can be a little\n\n                     slower than the following ones\n\n        - *disconnect_other_clients*: If True, disconnect clients until drone reports that we are in\n\n                                      control\n\n        ** Raises **\n\n        - *ConnectionError*: If the connection attempt fails\n\n        - *RuntimeError*: If the Blunux version of the connected drone is too old\n\n        \"\"\"\n\n        logger.info(f\"Attempting to connect to drone at {self._ip}\")\n\n        self._update_drone_info(timeout=timeout)\n\n        self._verify_required_blunux_version(\"3.2\")\n\n        self._telemetry_watcher = TelemetryClient(self)\n\n        self._ctrl_client = CtrlClient(self)\n\n        self._watchdog_publisher = WatchdogPublisher(self)\n\n        self._req_rep_client = ReqRepClient(self)\n\n        self._telemetry_watcher.start()\n\n        self._req_rep_client.start()\n\n        self._ctrl_client.start()\n\n        self._watchdog_publisher.start()\n\n        self.ping()\n\n        connect_resp = self._req_rep_client.connect_client(client_info=client_info)\n\n        logger.info(f\"Connection successful, client id: {connect_resp.client_id}\")\n\n        logger.info(f\"Client id in control: {connect_resp.client_id_in_control}\")\n\n        logger.info(f\"There are {len(connect_resp.connected_clients)-1} other clients connected\")\n\n        self.client_id = connect_resp.client_id\n\n        self.in_control = connect_resp.client_id == connect_resp.client_id_in_control\n\n        self.connected = True\n\n        if disconnect_other_clients and not self.in_control:\n\n            self.take_control()\n\n        self._drone_info_cb_id = self.telemetry.add_msg_callback(\n\n            [blueye.protocol.DroneInfoTel],\n\n            Drone._drone_info_callback,\n\n            False,\n\n            drone=self,\n\n        )\n\n        if self.in_control:\n\n            # The drone runs from a read-only filesystem, and as such does not keep any state,\n\n            # therefore when we connect to it we should send the current time\n\n            current_time = int(time.time())\n\n            time_formatted = datetime.fromtimestamp(current_time).strftime(\"%d. %b %Y %H:%M\")\n\n            logger.debug(f\"Setting current time to {current_time} ({time_formatted})\")\n\n            self.config.set_drone_time(current_time)\n\n            logger.debug(f\"Disabling thrusters\")\n\n            self.motion.send_thruster_setpoint(0, 0, 0, 0)\n\n    def disconnect(self):\n\n        \"\"\"Disconnects the connection, allowing another client to take control of the drone\"\"\"\n\n        try:\n\n            self._req_rep_client.disconnect_client(self.client_id)\n\n        except blueye.protocol.exceptions.ResponseTimeout:\n\n            # If there's no response the connection is likely already closed, so we can just\n\n            # continue to stop threads and disconnect\n\n            pass\n\n        self._watchdog_publisher.stop()\n\n        self._telemetry_watcher.stop()\n\n        self._req_rep_client.stop()\n\n        self._ctrl_client.stop()\n\n        self._watchdog_publisher = _NoConnectionClient()\n\n        self._telemetry_watcher = _NoConnectionClient()\n\n        self._req_rep_client = _NoConnectionClient()\n\n        self._ctrl_client = _NoConnectionClient()\n\n        self.connected = False\n\n    @property\n\n    def connected_clients(self) -&gt; Optional[List[blueye.protocol.ConnectedClient]]:\n\n        \"\"\"Get a list of connected clients\"\"\"\n\n        clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel)\n\n        if clients_tel is None:\n\n            return None\n\n        else:\n\n            return list(clients_tel.connected_clients)\n\n    @property\n\n    def client_in_control(self) -&gt; Optional[int]:\n\n        \"\"\"Get the client id of the client in control of the drone\"\"\"\n\n        clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel)\n\n        if clients_tel is None:\n\n            return None\n\n        else:\n\n            return clients_tel.client_id_in_control\n\n    def take_control(self, timeout=1):\n\n        \"\"\"Take control of the drone, disconnecting other clients\n\n        Will disconnect other clients until the client is in control of the drone.\n\n        Raises a RuntimeError if the client could not take control of the drone in the given time.\n\n        \"\"\"\n\n        start_time = time.time()\n\n        client_in_control = self.client_in_control\n\n        while self.client_id != client_in_control:\n\n            if time.time() - start_time &gt; timeout:\n\n                raise RuntimeError(\"Could not take control of the drone in the given time\")\n\n            resp = self._req_rep_client.disconnect_client(client_in_control)\n\n            client_in_control = resp.client_id_in_control\n\n        self.in_control = True\n\n    @property\n\n    def lights(self) -&gt; Optional[float]:\n\n        \"\"\"Get or set the intensity of the drone lights\n\n        *Arguments*:\n\n        * brightness (float): Set the intensity of the drone light (0..1)\n\n        *Returns*:\n\n        * brightness (float): The intensity of the drone light (0..1)\n\n        \"\"\"\n\n        return self.telemetry.get(blueye.protocol.LightsTel).lights.value\n\n    @lights.setter\n\n    def lights(self, brightness: float):\n\n        if not 0 &lt;= brightness &lt;= 1:\n\n            raise ValueError(\"Error occured while trying to set lights to: \" f\"{brightness}\")\n\n        self._ctrl_client.set_lights(brightness)\n\n    @property\n\n    def depth(self) -&gt; Optional[float]:\n\n        \"\"\"Get the current depth in meters\n\n        *Returns*:\n\n        * depth (float): The depth in meters of water column.\n\n        \"\"\"\n\n        depth_tel = self.telemetry.get(blueye.protocol.DepthTel)\n\n        if depth_tel is None:\n\n            return None\n\n        else:\n\n            return depth_tel.depth.value\n\n    @property\n\n    def pose(self) -&gt; Optional[dict]:\n\n        \"\"\"Get the current orientation of the drone\n\n        *Returns*:\n\n        * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359.\n\n        \"\"\"\n\n        attitude_tel = self.telemetry.get(blueye.protocol.AttitudeTel)\n\n        if attitude_tel is None:\n\n            return None\n\n        attitude = attitude_tel.attitude\n\n        pose = {\n\n            \"roll\": (attitude.roll + 360) % 360,\n\n            \"pitch\": (attitude.pitch + 360) % 360,\n\n            \"yaw\": (attitude.yaw + 360) % 360,\n\n        }\n\n        return pose\n\n    @property\n\n    def error_flags(self) -&gt; Optional[Dict[str, bool]]:\n\n        \"\"\"Get the error flags\n\n        *Returns*:\n\n        * error_flags (dict): The error flags as bools in a dictionary\n\n        \"\"\"\n\n        error_flags_tel = self.telemetry.get(blueye.protocol.ErrorFlagsTel)\n\n        if error_flags_tel is None:\n\n            return None\n\n        error_flags_msg = error_flags_tel.error_flags\n\n        error_flags = {}\n\n        possible_flags = [attr for attr in dir(error_flags_msg) if not attr.startswith(\"__\")]\n\n        for flag in possible_flags:\n\n            error_flags[flag] = getattr(error_flags_msg, flag)\n\n        return error_flags\n\n    @property\n\n    def active_video_streams(self) -&gt; Optional[Dict[str, int]]:\n\n        \"\"\"Get the number of currently active connections to the video stream\n\n        Every client connected to the RTSP stream (does not matter if it's directly from GStreamer,\n\n        or from the Blueye app) counts as one connection.\n\n        \"\"\"\n\n        n_streamers_msg_tel = self.telemetry.get(blueye.protocol.NStreamersTel)\n\n        if n_streamers_msg_tel is None:\n\n            return None\n\n        n_streamers_msg = n_streamers_msg_tel.n_streamers\n\n        return {\"main\": n_streamers_msg.main, \"guestport\": n_streamers_msg.guestport}\n\n    def ping(self, timeout: float = 1.0):\n\n        \"\"\"Ping drone\n\n        Raises a ResponseTimeout exception if the drone does not respond within the timeout period.\n\n        \"\"\"\n\n        self._req_rep_client.ping(timeout)\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#variables","title":"Variables","text":"<pre><code>logger\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#classes","title":"Classes","text":""},{"location":"reference/blueye/sdk/drone/#config","title":"Config","text":"<pre><code>class Config(\n    parent_drone: \"'Drone'\"\n)\n</code></pre> View Source <pre><code>class Config:\n\n    def __init__(self, parent_drone: \"Drone\"):\n\n        self._parent_drone = parent_drone\n\n        self._water_density = WaterDensities.salty\n\n    @property\n\n    def water_density(self):\n\n        \"\"\"Get or set the current water density for increased pressure sensor accuracy\n\n        Older software versions will assume a water density of 1.025 kilograms per liter.\n\n        The WaterDensities class contains typical densities for salty-, brackish-, and fresh water\n\n        (these are the same values that the Blueye app uses).\n\n        \"\"\"\n\n        return self._water_density\n\n    @water_density.setter\n\n    def water_density(self, density: float):\n\n        self._water_density = density\n\n        self._parent_drone._ctrl_client.set_water_density(density)\n\n    def set_drone_time(self, time: int):\n\n        \"\"\"Set the system for the drone\n\n        This method is used to set the system time for the drone. The argument `time` is expected to\n\n        be a Unix timestamp (ie. the number of seconds since the epoch).\n\n        \"\"\"\n\n        self._parent_drone._req_rep_client.sync_time(time)\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#instance-variables","title":"Instance variables","text":"<pre><code>water_density\n</code></pre> <p>Get or set the current water density for increased pressure sensor accuracy</p> <p>Older software versions will assume a water density of 1.025 kilograms per liter.</p> <p>The WaterDensities class contains typical densities for salty-, brackish-, and fresh water (these are the same values that the Blueye app uses).</p>"},{"location":"reference/blueye/sdk/drone/#methods","title":"Methods","text":""},{"location":"reference/blueye/sdk/drone/#set_drone_time","title":"set_drone_time","text":"<pre><code>def set_drone_time(\n    self,\n    time: 'int'\n)\n</code></pre> <p>Set the system for the drone</p> <p>This method is used to set the system time for the drone. The argument <code>time</code> is expected to be a Unix timestamp (ie. the number of seconds since the epoch).</p> View Source <pre><code>    def set_drone_time(self, time: int):\n\n        \"\"\"Set the system for the drone\n\n        This method is used to set the system time for the drone. The argument `time` is expected to\n\n        be a Unix timestamp (ie. the number of seconds since the epoch).\n\n        \"\"\"\n\n        self._parent_drone._req_rep_client.sync_time(time)\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#drone","title":"Drone","text":"<pre><code>class Drone(\n    ip='192.168.1.101',\n    auto_connect=True,\n    timeout=3,\n    disconnect_other_clients=False\n)\n</code></pre> <p>A class providing an interface to a Blueye drone's functions</p> <p>Automatically connects to the drone using the default ip when instantiated, this behaviour can be disabled by setting <code>auto_connect=False</code>.</p> View Source <pre><code>class Drone:\n\n    \"\"\"A class providing an interface to a Blueye drone's functions\n\n    Automatically connects to the drone using the default ip when instantiated, this behaviour can\n\n    be disabled by setting `auto_connect=False`.\n\n    \"\"\"\n\n    def __init__(\n\n        self,\n\n        ip=\"192.168.1.101\",\n\n        auto_connect=True,\n\n        timeout=3,\n\n        disconnect_other_clients=False,\n\n    ):\n\n        self._ip = ip\n\n        self.camera = Camera(self, is_guestport_camera=False)\n\n        self.motion = Motion(self)\n\n        self.logs = Logs(self)\n\n        self.legacy_logs = LegacyLogs(self)\n\n        self.config = Config(self)\n\n        self.battery = Battery(self)\n\n        self.telemetry = Telemetry(self)\n\n        self.connected = False\n\n        self.client_id: int = None\n\n        self.in_control: bool = False\n\n        self._watchdog_publisher = _NoConnectionClient()\n\n        self._telemetry_watcher = _NoConnectionClient()\n\n        self._req_rep_client = _NoConnectionClient()\n\n        self._ctrl_client = _NoConnectionClient()\n\n        self.peripherals: Optional[List[Peripheral]] = None\n\n        \"\"\"This list holds the peripherals connected to the drone. If it is `None`, then no\n\n        Guestport telemetry message has been recieved yet.\"\"\"\n\n        if auto_connect is True:\n\n            self.connect(timeout=timeout, disconnect_other_clients=disconnect_other_clients)\n\n    def _verify_required_blunux_version(self, requirement: str):\n\n        \"\"\"Verify that Blunux version is higher than requirement\n\n        requirement needs to be a string that's able to be parsed by version.parse()\n\n        Raises a RuntimeError if the Blunux version of the connected drone does not match or exceed\n\n        the requirement.\n\n        \"\"\"\n\n        if version.parse(self.software_version_short) &lt; version.parse(requirement):\n\n            raise RuntimeError(\n\n                f\"Blunux version of connected drone is {self.software_version_short}. Version \"\n\n                f\"{requirement} or higher is required.\"\n\n            )\n\n    def _update_drone_info(self, timeout: float = 3):\n\n        \"\"\"Request and store information about the connected drone\"\"\"\n\n        try:\n\n            response = requests.get(\n\n                f\"http://{self._ip}/diagnostics/drone_info\", timeout=timeout\n\n            ).json()\n\n        except (\n\n            requests.ConnectTimeout,\n\n            requests.ReadTimeout,\n\n            requests.ConnectionError,\n\n            JSONDecodeError,\n\n        ) as e:\n\n            raise ConnectionError(\"Could not establish connection with drone\") from e\n\n        try:\n\n            self.features = list(filter(None, response[\"features\"].split(\",\")))\n\n        except KeyError:\n\n            # Drone versions older than 1.4.7 did not have this field.\n\n            self.features = []\n\n        self.software_version = response[\"sw_version\"]\n\n        self.software_version_short = self.software_version.split(\"-\")[0]\n\n        self.serial_number = response[\"serial_number\"]\n\n        self.uuid = response[\"hardware_id\"]\n\n    @staticmethod\n\n    def _drone_info_callback(msg_type: str, msg: blueye.protocol.DroneInfoTel, drone: Drone):\n\n        # Check if the GuestPortInfo has been initialized\n\n        if msg.drone_info.gp._pb.ByteSize() != 0:\n\n            drone._create_peripherals_from_drone_info(msg.drone_info.gp)\n\n        # Remove the callback after the first message has been received\n\n        drone.telemetry.remove_msg_callback(drone._drone_info_cb_id)\n\n    def _create_peripherals_from_drone_info(self, gp_info: blueye.protocol.GuestPortInfo):\n\n        self.peripherals = []\n\n        for port in (gp_info.gp1, gp_info.gp2, gp_info.gp3):\n\n            for device in port.device_list.devices:\n\n                peripheral = device_to_peripheral(self, port.guest_port_number, device)\n\n                self.peripherals.append(peripheral)\n\n                if isinstance(peripheral, GuestPortLight):\n\n                    self.external_light = peripheral\n\n                elif isinstance(peripheral, GuestPortCamera):\n\n                    self.external_camera = peripheral\n\n    def connect(\n\n        self,\n\n        client_info: blueye.protocol.ClientInfo = None,\n\n        timeout: float = 4,\n\n        disconnect_other_clients: bool = False,\n\n    ):\n\n        \"\"\"Establish a connection to the drone\n\n        Spawns of several threads for receiving telemetry, sending control messages and publishing\n\n        watchdog messages.\n\n        When a watchdog message is receieved by the drone the thrusters are armed, so to stop the\n\n        drone from moving unexpectedly when connecting all thruster set points are set to zero when\n\n        connecting.\n\n        ** Arguments **\n\n        - *client_info*: Information about the client connecting, if None the SDK will attempt to\n\n                         read it from the environment\n\n        - *timeout*: Seconds to wait for connection. The first connection on boot can be a little\n\n                     slower than the following ones\n\n        - *disconnect_other_clients*: If True, disconnect clients until drone reports that we are in\n\n                                      control\n\n        ** Raises **\n\n        - *ConnectionError*: If the connection attempt fails\n\n        - *RuntimeError*: If the Blunux version of the connected drone is too old\n\n        \"\"\"\n\n        logger.info(f\"Attempting to connect to drone at {self._ip}\")\n\n        self._update_drone_info(timeout=timeout)\n\n        self._verify_required_blunux_version(\"3.2\")\n\n        self._telemetry_watcher = TelemetryClient(self)\n\n        self._ctrl_client = CtrlClient(self)\n\n        self._watchdog_publisher = WatchdogPublisher(self)\n\n        self._req_rep_client = ReqRepClient(self)\n\n        self._telemetry_watcher.start()\n\n        self._req_rep_client.start()\n\n        self._ctrl_client.start()\n\n        self._watchdog_publisher.start()\n\n        self.ping()\n\n        connect_resp = self._req_rep_client.connect_client(client_info=client_info)\n\n        logger.info(f\"Connection successful, client id: {connect_resp.client_id}\")\n\n        logger.info(f\"Client id in control: {connect_resp.client_id_in_control}\")\n\n        logger.info(f\"There are {len(connect_resp.connected_clients)-1} other clients connected\")\n\n        self.client_id = connect_resp.client_id\n\n        self.in_control = connect_resp.client_id == connect_resp.client_id_in_control\n\n        self.connected = True\n\n        if disconnect_other_clients and not self.in_control:\n\n            self.take_control()\n\n        self._drone_info_cb_id = self.telemetry.add_msg_callback(\n\n            [blueye.protocol.DroneInfoTel],\n\n            Drone._drone_info_callback,\n\n            False,\n\n            drone=self,\n\n        )\n\n        if self.in_control:\n\n            # The drone runs from a read-only filesystem, and as such does not keep any state,\n\n            # therefore when we connect to it we should send the current time\n\n            current_time = int(time.time())\n\n            time_formatted = datetime.fromtimestamp(current_time).strftime(\"%d. %b %Y %H:%M\")\n\n            logger.debug(f\"Setting current time to {current_time} ({time_formatted})\")\n\n            self.config.set_drone_time(current_time)\n\n            logger.debug(f\"Disabling thrusters\")\n\n            self.motion.send_thruster_setpoint(0, 0, 0, 0)\n\n    def disconnect(self):\n\n        \"\"\"Disconnects the connection, allowing another client to take control of the drone\"\"\"\n\n        try:\n\n            self._req_rep_client.disconnect_client(self.client_id)\n\n        except blueye.protocol.exceptions.ResponseTimeout:\n\n            # If there's no response the connection is likely already closed, so we can just\n\n            # continue to stop threads and disconnect\n\n            pass\n\n        self._watchdog_publisher.stop()\n\n        self._telemetry_watcher.stop()\n\n        self._req_rep_client.stop()\n\n        self._ctrl_client.stop()\n\n        self._watchdog_publisher = _NoConnectionClient()\n\n        self._telemetry_watcher = _NoConnectionClient()\n\n        self._req_rep_client = _NoConnectionClient()\n\n        self._ctrl_client = _NoConnectionClient()\n\n        self.connected = False\n\n    @property\n\n    def connected_clients(self) -&gt; Optional[List[blueye.protocol.ConnectedClient]]:\n\n        \"\"\"Get a list of connected clients\"\"\"\n\n        clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel)\n\n        if clients_tel is None:\n\n            return None\n\n        else:\n\n            return list(clients_tel.connected_clients)\n\n    @property\n\n    def client_in_control(self) -&gt; Optional[int]:\n\n        \"\"\"Get the client id of the client in control of the drone\"\"\"\n\n        clients_tel = self.telemetry.get(blueye.protocol.ConnectedClientsTel)\n\n        if clients_tel is None:\n\n            return None\n\n        else:\n\n            return clients_tel.client_id_in_control\n\n    def take_control(self, timeout=1):\n\n        \"\"\"Take control of the drone, disconnecting other clients\n\n        Will disconnect other clients until the client is in control of the drone.\n\n        Raises a RuntimeError if the client could not take control of the drone in the given time.\n\n        \"\"\"\n\n        start_time = time.time()\n\n        client_in_control = self.client_in_control\n\n        while self.client_id != client_in_control:\n\n            if time.time() - start_time &gt; timeout:\n\n                raise RuntimeError(\"Could not take control of the drone in the given time\")\n\n            resp = self._req_rep_client.disconnect_client(client_in_control)\n\n            client_in_control = resp.client_id_in_control\n\n        self.in_control = True\n\n    @property\n\n    def lights(self) -&gt; Optional[float]:\n\n        \"\"\"Get or set the intensity of the drone lights\n\n        *Arguments*:\n\n        * brightness (float): Set the intensity of the drone light (0..1)\n\n        *Returns*:\n\n        * brightness (float): The intensity of the drone light (0..1)\n\n        \"\"\"\n\n        return self.telemetry.get(blueye.protocol.LightsTel).lights.value\n\n    @lights.setter\n\n    def lights(self, brightness: float):\n\n        if not 0 &lt;= brightness &lt;= 1:\n\n            raise ValueError(\"Error occured while trying to set lights to: \" f\"{brightness}\")\n\n        self._ctrl_client.set_lights(brightness)\n\n    @property\n\n    def depth(self) -&gt; Optional[float]:\n\n        \"\"\"Get the current depth in meters\n\n        *Returns*:\n\n        * depth (float): The depth in meters of water column.\n\n        \"\"\"\n\n        depth_tel = self.telemetry.get(blueye.protocol.DepthTel)\n\n        if depth_tel is None:\n\n            return None\n\n        else:\n\n            return depth_tel.depth.value\n\n    @property\n\n    def pose(self) -&gt; Optional[dict]:\n\n        \"\"\"Get the current orientation of the drone\n\n        *Returns*:\n\n        * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359.\n\n        \"\"\"\n\n        attitude_tel = self.telemetry.get(blueye.protocol.AttitudeTel)\n\n        if attitude_tel is None:\n\n            return None\n\n        attitude = attitude_tel.attitude\n\n        pose = {\n\n            \"roll\": (attitude.roll + 360) % 360,\n\n            \"pitch\": (attitude.pitch + 360) % 360,\n\n            \"yaw\": (attitude.yaw + 360) % 360,\n\n        }\n\n        return pose\n\n    @property\n\n    def error_flags(self) -&gt; Optional[Dict[str, bool]]:\n\n        \"\"\"Get the error flags\n\n        *Returns*:\n\n        * error_flags (dict): The error flags as bools in a dictionary\n\n        \"\"\"\n\n        error_flags_tel = self.telemetry.get(blueye.protocol.ErrorFlagsTel)\n\n        if error_flags_tel is None:\n\n            return None\n\n        error_flags_msg = error_flags_tel.error_flags\n\n        error_flags = {}\n\n        possible_flags = [attr for attr in dir(error_flags_msg) if not attr.startswith(\"__\")]\n\n        for flag in possible_flags:\n\n            error_flags[flag] = getattr(error_flags_msg, flag)\n\n        return error_flags\n\n    @property\n\n    def active_video_streams(self) -&gt; Optional[Dict[str, int]]:\n\n        \"\"\"Get the number of currently active connections to the video stream\n\n        Every client connected to the RTSP stream (does not matter if it's directly from GStreamer,\n\n        or from the Blueye app) counts as one connection.\n\n        \"\"\"\n\n        n_streamers_msg_tel = self.telemetry.get(blueye.protocol.NStreamersTel)\n\n        if n_streamers_msg_tel is None:\n\n            return None\n\n        n_streamers_msg = n_streamers_msg_tel.n_streamers\n\n        return {\"main\": n_streamers_msg.main, \"guestport\": n_streamers_msg.guestport}\n\n    def ping(self, timeout: float = 1.0):\n\n        \"\"\"Ping drone\n\n        Raises a ResponseTimeout exception if the drone does not respond within the timeout period.\n\n        \"\"\"\n\n        self._req_rep_client.ping(timeout)\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#instance-variables_1","title":"Instance variables","text":"<pre><code>active_video_streams\n</code></pre> <p>Get the number of currently active connections to the video stream</p> <p>Every client connected to the RTSP stream (does not matter if it's directly from GStreamer, or from the Blueye app) counts as one connection.</p> <pre><code>client_in_control\n</code></pre> <p>Get the client id of the client in control of the drone</p> <pre><code>connected_clients\n</code></pre> <p>Get a list of connected clients</p> <pre><code>depth\n</code></pre> <p>Get the current depth in meters</p> <p>Returns:</p> <ul> <li>depth (float): The depth in meters of water column.</li> </ul> <pre><code>error_flags\n</code></pre> <p>Get the error flags</p> <p>Returns:</p> <ul> <li>error_flags (dict): The error flags as bools in a dictionary</li> </ul> <pre><code>lights\n</code></pre> <p>Get or set the intensity of the drone lights</p> <p>Arguments:</p> <ul> <li>brightness (float): Set the intensity of the drone light (0..1)</li> </ul> <p>Returns:</p> <ul> <li>brightness (float): The intensity of the drone light (0..1)</li> </ul> <pre><code>pose\n</code></pre> <p>Get the current orientation of the drone</p> <p>Returns:</p> <ul> <li>pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359.</li> </ul>"},{"location":"reference/blueye/sdk/drone/#methods_1","title":"Methods","text":""},{"location":"reference/blueye/sdk/drone/#connect","title":"connect","text":"<pre><code>def connect(\n    self,\n    client_info: 'blueye.protocol.ClientInfo' = None,\n    timeout: 'float' = 4,\n    disconnect_other_clients: 'bool' = False\n)\n</code></pre> <p>Establish a connection to the drone</p> <p>Spawns of several threads for receiving telemetry, sending control messages and publishing watchdog messages.</p> <p>When a watchdog message is receieved by the drone the thrusters are armed, so to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting.</p> <p>** Arguments ** - client_info: Information about the client connecting, if None the SDK will attempt to                  read it from the environment - timeout: Seconds to wait for connection. The first connection on boot can be a little              slower than the following ones - disconnect_other_clients: If True, disconnect clients until drone reports that we are in                               control</p> <p>** Raises ** - ConnectionError: If the connection attempt fails - RuntimeError: If the Blunux version of the connected drone is too old</p> View Source <pre><code>    def connect(\n\n        self,\n\n        client_info: blueye.protocol.ClientInfo = None,\n\n        timeout: float = 4,\n\n        disconnect_other_clients: bool = False,\n\n    ):\n\n        \"\"\"Establish a connection to the drone\n\n        Spawns of several threads for receiving telemetry, sending control messages and publishing\n\n        watchdog messages.\n\n        When a watchdog message is receieved by the drone the thrusters are armed, so to stop the\n\n        drone from moving unexpectedly when connecting all thruster set points are set to zero when\n\n        connecting.\n\n        ** Arguments **\n\n        - *client_info*: Information about the client connecting, if None the SDK will attempt to\n\n                         read it from the environment\n\n        - *timeout*: Seconds to wait for connection. The first connection on boot can be a little\n\n                     slower than the following ones\n\n        - *disconnect_other_clients*: If True, disconnect clients until drone reports that we are in\n\n                                      control\n\n        ** Raises **\n\n        - *ConnectionError*: If the connection attempt fails\n\n        - *RuntimeError*: If the Blunux version of the connected drone is too old\n\n        \"\"\"\n\n        logger.info(f\"Attempting to connect to drone at {self._ip}\")\n\n        self._update_drone_info(timeout=timeout)\n\n        self._verify_required_blunux_version(\"3.2\")\n\n        self._telemetry_watcher = TelemetryClient(self)\n\n        self._ctrl_client = CtrlClient(self)\n\n        self._watchdog_publisher = WatchdogPublisher(self)\n\n        self._req_rep_client = ReqRepClient(self)\n\n        self._telemetry_watcher.start()\n\n        self._req_rep_client.start()\n\n        self._ctrl_client.start()\n\n        self._watchdog_publisher.start()\n\n        self.ping()\n\n        connect_resp = self._req_rep_client.connect_client(client_info=client_info)\n\n        logger.info(f\"Connection successful, client id: {connect_resp.client_id}\")\n\n        logger.info(f\"Client id in control: {connect_resp.client_id_in_control}\")\n\n        logger.info(f\"There are {len(connect_resp.connected_clients)-1} other clients connected\")\n\n        self.client_id = connect_resp.client_id\n\n        self.in_control = connect_resp.client_id == connect_resp.client_id_in_control\n\n        self.connected = True\n\n        if disconnect_other_clients and not self.in_control:\n\n            self.take_control()\n\n        self._drone_info_cb_id = self.telemetry.add_msg_callback(\n\n            [blueye.protocol.DroneInfoTel],\n\n            Drone._drone_info_callback,\n\n            False,\n\n            drone=self,\n\n        )\n\n        if self.in_control:\n\n            # The drone runs from a read-only filesystem, and as such does not keep any state,\n\n            # therefore when we connect to it we should send the current time\n\n            current_time = int(time.time())\n\n            time_formatted = datetime.fromtimestamp(current_time).strftime(\"%d. %b %Y %H:%M\")\n\n            logger.debug(f\"Setting current time to {current_time} ({time_formatted})\")\n\n            self.config.set_drone_time(current_time)\n\n            logger.debug(f\"Disabling thrusters\")\n\n            self.motion.send_thruster_setpoint(0, 0, 0, 0)\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#disconnect","title":"disconnect","text":"<pre><code>def disconnect(\n    self\n)\n</code></pre> <p>Disconnects the connection, allowing another client to take control of the drone</p> View Source <pre><code>    def disconnect(self):\n\n        \"\"\"Disconnects the connection, allowing another client to take control of the drone\"\"\"\n\n        try:\n\n            self._req_rep_client.disconnect_client(self.client_id)\n\n        except blueye.protocol.exceptions.ResponseTimeout:\n\n            # If there's no response the connection is likely already closed, so we can just\n\n            # continue to stop threads and disconnect\n\n            pass\n\n        self._watchdog_publisher.stop()\n\n        self._telemetry_watcher.stop()\n\n        self._req_rep_client.stop()\n\n        self._ctrl_client.stop()\n\n        self._watchdog_publisher = _NoConnectionClient()\n\n        self._telemetry_watcher = _NoConnectionClient()\n\n        self._req_rep_client = _NoConnectionClient()\n\n        self._ctrl_client = _NoConnectionClient()\n\n        self.connected = False\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#ping","title":"ping","text":"<pre><code>def ping(\n    self,\n    timeout: 'float' = 1.0\n)\n</code></pre> <p>Ping drone</p> <p>Raises a ResponseTimeout exception if the drone does not respond within the timeout period.</p> View Source <pre><code>    def ping(self, timeout: float = 1.0):\n\n        \"\"\"Ping drone\n\n        Raises a ResponseTimeout exception if the drone does not respond within the timeout period.\n\n        \"\"\"\n\n        self._req_rep_client.ping(timeout)\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#take_control","title":"take_control","text":"<pre><code>def take_control(\n    self,\n    timeout=1\n)\n</code></pre> <p>Take control of the drone, disconnecting other clients</p> <p>Will disconnect other clients until the client is in control of the drone. Raises a RuntimeError if the client could not take control of the drone in the given time.</p> View Source <pre><code>    def take_control(self, timeout=1):\n\n        \"\"\"Take control of the drone, disconnecting other clients\n\n        Will disconnect other clients until the client is in control of the drone.\n\n        Raises a RuntimeError if the client could not take control of the drone in the given time.\n\n        \"\"\"\n\n        start_time = time.time()\n\n        client_in_control = self.client_in_control\n\n        while self.client_id != client_in_control:\n\n            if time.time() - start_time &gt; timeout:\n\n                raise RuntimeError(\"Could not take control of the drone in the given time\")\n\n            resp = self._req_rep_client.disconnect_client(client_in_control)\n\n            client_in_control = resp.client_id_in_control\n\n        self.in_control = True\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#telemetry","title":"Telemetry","text":"<pre><code>class Telemetry(\n    parent_drone: \"'Drone'\"\n)\n</code></pre> View Source <pre><code>class Telemetry:\n\n    def __init__(self, parent_drone: \"Drone\"):\n\n        self._parent_drone = parent_drone\n\n    def set_msg_publish_frequency(self, msg: proto.message.Message, frequency: float):\n\n        \"\"\"Set the publishing frequency of a specific telemetry message\n\n        Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a\n\n        frequency outside the valid range, or an incorrect message type.\n\n        *Arguments*:\n\n        * msg (proto.message.Message): The message to set the frequency of. Needs to be one of the\n\n                                       messages in blueye.protocol that end in Tel, eg.\n\n                                       blueye.protocol.DepthTel\n\n        * frequency (float): The frequency in Hz. Valid range is (0 .. 100).\n\n        \"\"\"\n\n        resp = self._parent_drone._req_rep_client.set_telemetry_msg_publish_frequency(\n\n            msg, frequency\n\n        )\n\n        if not resp.success:\n\n            raise RuntimeError(\"Could not set telemetry message frequency\")\n\n    def add_msg_callback(\n\n        self,\n\n        msg_filter: List[proto.message.Message],\n\n        callback: Callable[[str, proto.message.Message], None],\n\n        raw: bool = False,\n\n        **kwargs,\n\n    ) -&gt; str:\n\n        \"\"\"Register a telemetry message callback\n\n        The callback is called each time a message of the type is received\n\n        *Arguments*:\n\n        * msg_filter: A list of message types to register the callback for.\n\n                      Eg. `[blueye.protocol.DepthTel, blueye.protocol.Imu1Tel]`. If the list is\n\n                      empty the callback will be registered for all message types\n\n        * callback: The callback function. It should be minimal and return as fast as possible to\n\n                    not block the telemetry communication. It is called with two arguments, the\n\n                    message type name and the message object\n\n        * raw: Pass the raw data instead of the deserialized message to the callback function\n\n        * kwargs: Additional keyword arguments to pass to the callback function\n\n        *Returns*:\n\n        * uuid: Callback id. Can be used to remove callback in the future\n\n        \"\"\"\n\n        uuid_hex = self._parent_drone._telemetry_watcher.add_callback(\n\n            msg_filter, callback, raw, **kwargs\n\n        )\n\n        return uuid_hex\n\n    def remove_msg_callback(self, callback_id: str) -&gt; Optional[str]:\n\n        \"\"\"Remove a telemetry message callback\n\n        *Arguments*:\n\n        * callback_id: The callback id\n\n        \"\"\"\n\n        self._parent_drone._telemetry_watcher.remove_callback(callback_id)\n\n    def get(\n\n        self, msg_type: proto.message.Message, deserialize=True\n\n    ) -&gt; Optional[proto.message.Message | bytes]:\n\n        \"\"\"Get the latest telemetry message of the specified type\n\n        *Arguments*:\n\n        * msg_type: The message type to get. Eg. blueye.protocol.DepthTel\n\n        * deserialize: If True, the message will be deserialized before being returned. If False,\n\n                       the raw bytes will be returned.\n\n        *Returns*:\n\n        * The latest message of the specified type, or None if no message has been received yet\n\n        \"\"\"\n\n        try:\n\n            msg = self._parent_drone._telemetry_watcher.get(msg_type)\n\n        except KeyError:\n\n            if version.parse(self._parent_drone.software_version_short) &gt;= version.parse(\"3.3\"):\n\n                msg = self._parent_drone._req_rep_client.get_telemetry_msg(msg_type).payload.value\n\n                if msg == b\"\":\n\n                    return None\n\n            else:\n\n                return None\n\n        if deserialize:\n\n            return msg_type.deserialize(msg)\n\n        else:\n\n            return msg\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#methods_2","title":"Methods","text":""},{"location":"reference/blueye/sdk/drone/#add_msg_callback","title":"add_msg_callback","text":"<pre><code>def add_msg_callback(\n    self,\n    msg_filter: 'List[proto.message.Message]',\n    callback: 'Callable[[str, proto.message.Message], None]',\n    raw: 'bool' = False,\n    **kwargs\n) -&gt; 'str'\n</code></pre> <p>Register a telemetry message callback</p> <p>The callback is called each time a message of the type is received</p> <p>Arguments:</p> <ul> <li>msg_filter: A list of message types to register the callback for.               Eg. <code>[blueye.protocol.DepthTel, blueye.protocol.Imu1Tel]</code>. If the list is               empty the callback will be registered for all message types</li> <li>callback: The callback function. It should be minimal and return as fast as possible to             not block the telemetry communication. It is called with two arguments, the             message type name and the message object</li> <li>raw: Pass the raw data instead of the deserialized message to the callback function</li> <li>kwargs: Additional keyword arguments to pass to the callback function</li> </ul> <p>Returns:</p> <ul> <li>uuid: Callback id. Can be used to remove callback in the future</li> </ul> View Source <pre><code>    def add_msg_callback(\n\n        self,\n\n        msg_filter: List[proto.message.Message],\n\n        callback: Callable[[str, proto.message.Message], None],\n\n        raw: bool = False,\n\n        **kwargs,\n\n    ) -&gt; str:\n\n        \"\"\"Register a telemetry message callback\n\n        The callback is called each time a message of the type is received\n\n        *Arguments*:\n\n        * msg_filter: A list of message types to register the callback for.\n\n                      Eg. `[blueye.protocol.DepthTel, blueye.protocol.Imu1Tel]`. If the list is\n\n                      empty the callback will be registered for all message types\n\n        * callback: The callback function. It should be minimal and return as fast as possible to\n\n                    not block the telemetry communication. It is called with two arguments, the\n\n                    message type name and the message object\n\n        * raw: Pass the raw data instead of the deserialized message to the callback function\n\n        * kwargs: Additional keyword arguments to pass to the callback function\n\n        *Returns*:\n\n        * uuid: Callback id. Can be used to remove callback in the future\n\n        \"\"\"\n\n        uuid_hex = self._parent_drone._telemetry_watcher.add_callback(\n\n            msg_filter, callback, raw, **kwargs\n\n        )\n\n        return uuid_hex\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#get","title":"get","text":"<pre><code>def get(\n    self,\n    msg_type: 'proto.message.Message',\n    deserialize=True\n) -&gt; 'Optional[proto.message.Message | bytes]'\n</code></pre> <p>Get the latest telemetry message of the specified type</p> <p>Arguments:</p> <ul> <li>msg_type: The message type to get. Eg. blueye.protocol.DepthTel</li> <li>deserialize: If True, the message will be deserialized before being returned. If False,                the raw bytes will be returned.</li> </ul> <p>Returns:</p> <ul> <li>The latest message of the specified type, or None if no message has been received yet</li> </ul> View Source <pre><code>    def get(\n\n        self, msg_type: proto.message.Message, deserialize=True\n\n    ) -&gt; Optional[proto.message.Message | bytes]:\n\n        \"\"\"Get the latest telemetry message of the specified type\n\n        *Arguments*:\n\n        * msg_type: The message type to get. Eg. blueye.protocol.DepthTel\n\n        * deserialize: If True, the message will be deserialized before being returned. If False,\n\n                       the raw bytes will be returned.\n\n        *Returns*:\n\n        * The latest message of the specified type, or None if no message has been received yet\n\n        \"\"\"\n\n        try:\n\n            msg = self._parent_drone._telemetry_watcher.get(msg_type)\n\n        except KeyError:\n\n            if version.parse(self._parent_drone.software_version_short) &gt;= version.parse(\"3.3\"):\n\n                msg = self._parent_drone._req_rep_client.get_telemetry_msg(msg_type).payload.value\n\n                if msg == b\"\":\n\n                    return None\n\n            else:\n\n                return None\n\n        if deserialize:\n\n            return msg_type.deserialize(msg)\n\n        else:\n\n            return msg\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#remove_msg_callback","title":"remove_msg_callback","text":"<pre><code>def remove_msg_callback(\n    self,\n    callback_id: 'str'\n) -&gt; 'Optional[str]'\n</code></pre> <p>Remove a telemetry message callback</p> <p>Arguments:</p> <ul> <li>callback_id: The callback id</li> </ul> View Source <pre><code>    def remove_msg_callback(self, callback_id: str) -&gt; Optional[str]:\n\n        \"\"\"Remove a telemetry message callback\n\n        *Arguments*:\n\n        * callback_id: The callback id\n\n        \"\"\"\n\n        self._parent_drone._telemetry_watcher.remove_callback(callback_id)\n</code></pre>"},{"location":"reference/blueye/sdk/drone/#set_msg_publish_frequency","title":"set_msg_publish_frequency","text":"<pre><code>def set_msg_publish_frequency(\n    self,\n    msg: 'proto.message.Message',\n    frequency: 'float'\n)\n</code></pre> <p>Set the publishing frequency of a specific telemetry message</p> <p>Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a frequency outside the valid range, or an incorrect message type.</p> <p>Arguments:</p> <ul> <li>msg (proto.message.Message): The message to set the frequency of. Needs to be one of the                                messages in blueye.protocol that end in Tel, eg.                                blueye.protocol.DepthTel</li> <li>frequency (float): The frequency in Hz. Valid range is (0 .. 100).</li> </ul> View Source <pre><code>    def set_msg_publish_frequency(self, msg: proto.message.Message, frequency: float):\n\n        \"\"\"Set the publishing frequency of a specific telemetry message\n\n        Raises a RuntimeError if the drone fails to set the frequency. Possible causes could be a\n\n        frequency outside the valid range, or an incorrect message type.\n\n        *Arguments*:\n\n        * msg (proto.message.Message): The message to set the frequency of. Needs to be one of the\n\n                                       messages in blueye.protocol that end in Tel, eg.\n\n                                       blueye.protocol.DepthTel\n\n        * frequency (float): The frequency in Hz. Valid range is (0 .. 100).\n\n        \"\"\"\n\n        resp = self._parent_drone._req_rep_client.set_telemetry_msg_publish_frequency(\n\n            msg, frequency\n\n        )\n\n        if not resp.success:\n\n            raise RuntimeError(\"Could not set telemetry message frequency\")\n</code></pre>"},{"location":"reference/blueye/sdk/guestport/","title":"Module blueye.sdk.guestport","text":"View Source <pre><code>import logging\n\nfrom typing import TYPE_CHECKING, Optional\n\nimport blueye.protocol as bp\n\nfrom packaging import version\n\nfrom .camera import Camera\n\nif TYPE_CHECKING:\n\n    from .drone import Drone\n\nlogger = logging.getLogger(__name__)\n\nclass Peripheral:\n\n    def __init__(\n\n        self, parent_drone: \"Drone\", port_number: bp.GuestPortNumber, device: bp.GuestPortDevice\n\n    ):\n\n        self.parent_drone = parent_drone\n\n        self.port_number: bp.GuestPortNumber = port_number\n\n        self.name: str = device.name\n\n        self.manufacturer: str = device.manufacturer\n\n        self.serial_number: str = device.serial_number\n\n        self.depth_rating: float = device.depth_rating\n\n        self.required_blunux_version: str = device.required_blunux_version\n\n        self.device_id: bp.GuestPortDeviceID = device.device_id\n\n        if self.required_blunux_version != \"\":\n\n            if version.parse(self.required_blunux_version) &gt; version.parse(\n\n                parent_drone.software_version_short\n\n            ):\n\n                logger.warning(\n\n                    f\"Peripheral {self.name} requires Blunux version \"\n\n                    f\"{self.required_blunux_version}, but the drone is running \"\n\n                    f\"{parent_drone.software_version_short}\"\n\n                )\n\nclass GuestPortCamera(Camera, Peripheral):\n\n    def __init__(\n\n        self, parent_drone: \"Drone\", port_number: bp.GuestPortNumber, device: bp.GuestPortDevice\n\n    ):\n\n        Camera.__init__(self, parent_drone, is_guestport_camera=True)\n\n        Peripheral.__init__(self, parent_drone, port_number, device)\n\nclass GuestPortLight(Peripheral):\n\n    def __init__(\n\n        self, parent_drone: \"Drone\", port_number: bp.GuestPortNumber, device: bp.GuestPortDevice\n\n    ):\n\n        Peripheral.__init__(self, parent_drone, port_number, device)\n\n    def set_intensity(self, intensity: float):\n\n        self.parent_drone._ctrl_client.set_guest_port_lights(intensity)\n\n    def get_intensity(self) -&gt; Optional[float]:\n\n        return self.parent_drone.telemetry.get(bp.GuestPortLightsTel).lights.value\n\ndef device_to_peripheral(\n\n    parent_drone: \"Drone\", port_number: bp.GuestPortNumber, device: bp.GuestPortDevice\n\n) -&gt; Peripheral:\n\n    logger.debug(f\"Found a {device.name} at port {port_number}\")\n\n    if device.device_id == bp.GuestPortDeviceID.GUEST_PORT_DEVICE_ID_BLUEYE_CAM:\n\n        peripheral = GuestPortCamera(parent_drone, port_number, device)\n\n    elif (\n\n        device.device_id == bp.GuestPortDeviceID.GUEST_PORT_DEVICE_ID_BLUEYE_LIGHT\n\n        or device.device_id == bp.GuestPortDeviceID.GUEST_PORT_DEVICE_ID_BLUEYE_LIGHT_PAIR\n\n        or device.device_id == bp.GuestPortDeviceID.GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_LUMEN\n\n    ):\n\n        peripheral = GuestPortLight(parent_drone, port_number, device)\n\n    else:\n\n        peripheral = Peripheral(parent_drone, port_number, device)\n\n    return peripheral\n</code></pre>"},{"location":"reference/blueye/sdk/guestport/#variables","title":"Variables","text":"<pre><code>TYPE_CHECKING\n</code></pre> <pre><code>logger\n</code></pre>"},{"location":"reference/blueye/sdk/guestport/#functions","title":"Functions","text":""},{"location":"reference/blueye/sdk/guestport/#device_to_peripheral","title":"device_to_peripheral","text":"<pre><code>def device_to_peripheral(\n    parent_drone: 'Drone',\n    port_number: blueye.protocol.types.message_formats.GuestPortNumber,\n    device: blueye.protocol.types.message_formats.GuestPortDevice\n) -&gt; blueye.sdk.guestport.Peripheral\n</code></pre> View Source <pre><code>def device_to_peripheral(\n\n    parent_drone: \"Drone\", port_number: bp.GuestPortNumber, device: bp.GuestPortDevice\n\n) -&gt; Peripheral:\n\n    logger.debug(f\"Found a {device.name} at port {port_number}\")\n\n    if device.device_id == bp.GuestPortDeviceID.GUEST_PORT_DEVICE_ID_BLUEYE_CAM:\n\n        peripheral = GuestPortCamera(parent_drone, port_number, device)\n\n    elif (\n\n        device.device_id == bp.GuestPortDeviceID.GUEST_PORT_DEVICE_ID_BLUEYE_LIGHT\n\n        or device.device_id == bp.GuestPortDeviceID.GUEST_PORT_DEVICE_ID_BLUEYE_LIGHT_PAIR\n\n        or device.device_id == bp.GuestPortDeviceID.GUEST_PORT_DEVICE_ID_BLUE_ROBOTICS_LUMEN\n\n    ):\n\n        peripheral = GuestPortLight(parent_drone, port_number, device)\n\n    else:\n\n        peripheral = Peripheral(parent_drone, port_number, device)\n\n    return peripheral\n</code></pre>"},{"location":"reference/blueye/sdk/guestport/#classes","title":"Classes","text":""},{"location":"reference/blueye/sdk/guestport/#guestportcamera","title":"GuestPortCamera","text":"<pre><code>class GuestPortCamera(\n    parent_drone: 'Drone',\n    port_number: blueye.protocol.types.message_formats.GuestPortNumber,\n    device: blueye.protocol.types.message_formats.GuestPortDevice\n)\n</code></pre> View Source <pre><code>class GuestPortCamera(Camera, Peripheral):\n\n    def __init__(\n\n        self, parent_drone: \"Drone\", port_number: bp.GuestPortNumber, device: bp.GuestPortDevice\n\n    ):\n\n        Camera.__init__(self, parent_drone, is_guestport_camera=True)\n\n        Peripheral.__init__(self, parent_drone, port_number, device)\n</code></pre>"},{"location":"reference/blueye/sdk/guestport/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>blueye.sdk.camera.Camera</li> <li>blueye.sdk.guestport.Peripheral</li> </ul>"},{"location":"reference/blueye/sdk/guestport/#instance-variables","title":"Instance variables","text":"<pre><code>bitrate\n</code></pre> <p>Set or get the video stream bitrate</p> <p>Arguments:</p> <ul> <li>bitrate (int): Set the video stream bitrate in bits, valid values are in range                  (1 000 000..16 000 000)</li> </ul> <p>Returns:</p> <ul> <li>bitrate (int): The H264 video stream bitrate</li> </ul> <pre><code>bitrate_still_picture\n</code></pre> <p>Set or get the bitrate for the still picture stream</p> <p>Arguments:</p> <ul> <li>bitrate (int): Set the still picture stream bitrate in bits, valid values are in range                  (1 000 000 .. 300 000 000). Default value is 100 000 000.</li> </ul> <p>Returns:</p> <ul> <li>bitrate (int): The still picture stream bitrate</li> </ul> <pre><code>exposure\n</code></pre> <p>Set or get the camera exposure</p> <p>Arguments:</p> <ul> <li>exposure (int): Set the camera exposure time. Unit is thousandths of a second, ie.                   5 = 5s/1000. Valid values are in the range (1 .. 5000) or -1 for auto                   exposure</li> </ul> <p>Returns:</p> <ul> <li>exposure (int): Get the camera exposure</li> </ul> <pre><code>framerate\n</code></pre> <p>Set or get the camera frame rate</p> <p>Arguments:</p> <ul> <li>framerate (int): Set the camera frame rate in frames per second. Valid values are 25 or 30</li> </ul> <p>Returns:</p> <ul> <li>framerate (int): Get the camera frame rate</li> </ul> <pre><code>hue\n</code></pre> <p>Set or get the camera hue</p> <p>Arguments:</p> <ul> <li>hue (int): Set the camera hue. Valid values are in the range (-40..40)</li> </ul> <p>Returns:</p> <ul> <li>hue (int): Get the camera hue</li> </ul> <pre><code>is_recording\n</code></pre> <p>Get or set the camera recording state</p> <p>Arguments:</p> <ul> <li>start_recording (bool): Set to True to start a recording, set to False to stop the current                           recording.</li> </ul> <p>Returns:</p> <ul> <li>Recording state (bool): True if the camera is currently recording, False if not</li> </ul> <pre><code>record_time\n</code></pre> <p>Set or get the duration of the current camera recording</p> <p>Returns:</p> <ul> <li>record_time (int): The length in seconds of the current recording, -1 if the camera is not currently recording</li> </ul> <pre><code>resolution\n</code></pre> <p>Set or get the camera resolution</p> <p>Arguments:</p> <ul> <li>resolution (int): Set the camera in vertical pixels. Valid values are 720 or 1080</li> </ul> <p>Returns:</p> <ul> <li>resolution (int): Get the camera resolution</li> </ul> <pre><code>whitebalance\n</code></pre> <p>Set or get the camera white balance</p> <p>Arguments:</p> <ul> <li>white_balance (int): Set the camera white balance. Valid values are in the range                        (2800..9300) or -1 for auto white balance</li> </ul> <p>Returns:</p> <ul> <li>white_balance (int): Get the camera white balance</li> </ul>"},{"location":"reference/blueye/sdk/guestport/#methods","title":"Methods","text":""},{"location":"reference/blueye/sdk/guestport/#take_picture","title":"take_picture","text":"<pre><code>def take_picture(\n    self\n)\n</code></pre> <p>Takes a still picture and stores it locally on the drone</p> <p>These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client.</p> View Source <pre><code>    def take_picture(self):\n\n        \"\"\"Takes a still picture and stores it locally on the drone\n\n        These pictures can be downloaded with the Blueye App, or by any WebDAV compatible client.\n\n        \"\"\"\n\n        self._parent_drone._ctrl_client.take_still_picture()\n</code></pre>"},{"location":"reference/blueye/sdk/guestport/#guestportlight","title":"GuestPortLight","text":"<pre><code>class GuestPortLight(\n    parent_drone: 'Drone',\n    port_number: blueye.protocol.types.message_formats.GuestPortNumber,\n    device: blueye.protocol.types.message_formats.GuestPortDevice\n)\n</code></pre> View Source <pre><code>class GuestPortLight(Peripheral):\n\n    def __init__(\n\n        self, parent_drone: \"Drone\", port_number: bp.GuestPortNumber, device: bp.GuestPortDevice\n\n    ):\n\n        Peripheral.__init__(self, parent_drone, port_number, device)\n\n    def set_intensity(self, intensity: float):\n\n        self.parent_drone._ctrl_client.set_guest_port_lights(intensity)\n\n    def get_intensity(self) -&gt; Optional[float]:\n\n        return self.parent_drone.telemetry.get(bp.GuestPortLightsTel).lights.value\n</code></pre>"},{"location":"reference/blueye/sdk/guestport/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>blueye.sdk.guestport.Peripheral</li> </ul>"},{"location":"reference/blueye/sdk/guestport/#methods_1","title":"Methods","text":""},{"location":"reference/blueye/sdk/guestport/#get_intensity","title":"get_intensity","text":"<pre><code>def get_intensity(\n    self\n) -&gt; Optional[float]\n</code></pre> View Source <pre><code>    def get_intensity(self) -&gt; Optional[float]:\n\n        return self.parent_drone.telemetry.get(bp.GuestPortLightsTel).lights.value\n</code></pre>"},{"location":"reference/blueye/sdk/guestport/#set_intensity","title":"set_intensity","text":"<pre><code>def set_intensity(\n    self,\n    intensity: float\n)\n</code></pre> View Source <pre><code>    def set_intensity(self, intensity: float):\n\n        self.parent_drone._ctrl_client.set_guest_port_lights(intensity)\n</code></pre>"},{"location":"reference/blueye/sdk/guestport/#peripheral","title":"Peripheral","text":"<pre><code>class Peripheral(\n    parent_drone: 'Drone',\n    port_number: blueye.protocol.types.message_formats.GuestPortNumber,\n    device: blueye.protocol.types.message_formats.GuestPortDevice\n)\n</code></pre> View Source <pre><code>class Peripheral:\n\n    def __init__(\n\n        self, parent_drone: \"Drone\", port_number: bp.GuestPortNumber, device: bp.GuestPortDevice\n\n    ):\n\n        self.parent_drone = parent_drone\n\n        self.port_number: bp.GuestPortNumber = port_number\n\n        self.name: str = device.name\n\n        self.manufacturer: str = device.manufacturer\n\n        self.serial_number: str = device.serial_number\n\n        self.depth_rating: float = device.depth_rating\n\n        self.required_blunux_version: str = device.required_blunux_version\n\n        self.device_id: bp.GuestPortDeviceID = device.device_id\n\n        if self.required_blunux_version != \"\":\n\n            if version.parse(self.required_blunux_version) &gt; version.parse(\n\n                parent_drone.software_version_short\n\n            ):\n\n                logger.warning(\n\n                    f\"Peripheral {self.name} requires Blunux version \"\n\n                    f\"{self.required_blunux_version}, but the drone is running \"\n\n                    f\"{parent_drone.software_version_short}\"\n\n                )\n</code></pre>"},{"location":"reference/blueye/sdk/guestport/#descendants","title":"Descendants","text":"<ul> <li>blueye.sdk.guestport.GuestPortCamera</li> <li>blueye.sdk.guestport.GuestPortLight</li> </ul>"},{"location":"reference/blueye/sdk/logs/","title":"Module blueye.sdk.logs","text":"View Source <pre><code>from __future__ import annotations\n\nimport logging\n\nimport zlib\n\nfrom datetime import datetime, timedelta, timezone\n\nfrom pathlib import Path\n\nfrom typing import Callable, Iterator, List, Optional, Tuple\n\nimport blueye.protocol as bp\n\nimport dateutil.parser\n\nimport proto\n\nimport requests\n\nimport tabulate\n\nfrom google.protobuf.internal.decoder import _DecodeVarint as decodeVarint\n\nfrom packaging import version\n\nfrom .utils import deserialize_any_to_message\n\nlogger = logging.getLogger(__name__)\n\ndef human_readable_filesize(binsize: int) -&gt; str:\n\n    \"\"\"Convert bytes to human readable string\"\"\"\n\n    suffix = \"B\"\n\n    num = binsize\n\n    for unit in [\"\", \"Ki\", \"Mi\"]:\n\n        if abs(num) &lt; 1024.0:\n\n            return f\"{num:3.1f} {unit}{suffix}\"\n\n        num /= 1024.0\n\n    return f\"{num:.1f} Gi{suffix}\"\n\ndef decompress_log(log: bytes) -&gt; bytes:\n\n    \"\"\"Decompress a log file\"\"\"\n\n    return zlib.decompressobj(wbits=zlib.MAX_WBITS | 16).decompress(log)\n\nclass LogStream:\n\n    \"\"\"Class for streaming a log\n\n    Creates a stream from a downloaded log file. Iterate over the object to get the next log record.\n\n    \"\"\"\n\n    def __init__(\n\n        self, log: bytes, decompress: bool = True\n\n    ) -&gt; Iterator[\n\n        Tuple[\n\n            proto.datetime_helpers.DatetimeWithNanoseconds,  # Real time clock\n\n            timedelta,  # Time since first message\n\n            proto.message.MessageMeta,  # Message type\n\n            proto.message.Message,  # Message contents\n\n        ]\n\n    ]:\n\n        if decompress:\n\n            self.decompressed_log = decompress_log(log)\n\n        else:\n\n            self.decompressed_log = log\n\n        self.pos = 0\n\n        self.start_monotonic: proto.datetime_helpers.DatetimeWithNanoseconds = 0\n\n    def __iter__(self):\n\n        return self\n\n    def __next__(self):\n\n        if self.pos &lt; len(self.decompressed_log):\n\n            msg_size, pos_msg_start = decodeVarint(self.decompressed_log, self.pos)\n\n            msg_data = self.decompressed_log[pos_msg_start : (pos_msg_start + msg_size)]\n\n            if len(msg_data) &lt; msg_size:\n\n                raise EOFError(\"Not enough bytes to read message\")\n\n            self.pos = pos_msg_start + msg_size\n\n            msg = bp.BinlogRecord.deserialize(msg_data)\n\n            payload_type, payload_msg_deserialized = deserialize_any_to_message(msg)\n\n            if self.start_monotonic == 0:\n\n                self.start_monotonic = msg.clock_monotonic\n\n            return (\n\n                msg.unix_timestamp,\n\n                msg.clock_monotonic - self.start_monotonic,\n\n                payload_type,\n\n                payload_msg_deserialized,\n\n            )\n\n        else:\n\n            raise StopIteration\n\nclass LogFile:\n\n    def __init__(\n\n        self,\n\n        name: str,\n\n        is_dive: bool,\n\n        filesize: int,\n\n        start_time: int,\n\n        max_depth_magnitude: int,\n\n        ip: str,\n\n    ):\n\n        self.name = name\n\n        self.is_dive = is_dive\n\n        self.filesize = filesize\n\n        self.start_time: datetime = datetime.fromtimestamp(start_time, tz=timezone.utc)\n\n        self.max_depth_magnitude = max_depth_magnitude\n\n        self.download_url = f\"http://{ip}/logs/{self.name}/binlog\"\n\n        self.content = None\n\n        self._formatted_values = [\n\n            self.name,\n\n            self.start_time.strftime(\"%d. %b %Y %H:%M\"),\n\n            f\"{self.max_depth_magnitude} m\",\n\n            human_readable_filesize(self.filesize),\n\n        ]\n\n    def download(\n\n        self,\n\n        output_path: Optional[Path | str] = None,\n\n        write_to_file: bool = True,\n\n        timeout: float = 1,\n\n        overwrite_cache: bool = False,\n\n    ) -&gt; bytes:\n\n        \"\"\"Download a log file from the drone\n\n        *Arguments*:\n\n        * `output_path`:\n\n            Path to write the log file to. If `None`, the log will be written to the\n\n            current working directory. If the path is a directory, the log will be\n\n            downloaded to that directory with its original name. Else the log will be\n\n            downloaded to the specified path.\n\n        * `write_to_file`:\n\n            If True, the log will be written to the specified path. If False, the\n\n            log will only be returned as a bytes object.\n\n        * `timeout`:\n\n            Seconds to wait for response\n\n        * `overwrite_cache`:\n\n            If True, the log will be downloaded even if it is already been downloaded.\n\n        *Returns*:\n\n        The compressed log file as a bytes object.\n\n        \"\"\"\n\n        if self.content is None or overwrite_cache:\n\n            self.content = requests.get(self.download_url, timeout=timeout).content\n\n        if write_to_file:\n\n            if output_path is None:\n\n                output_path = Path(f\"{self.name}.bez\")\n\n            else:\n\n                if type(output_path) == str:\n\n                    output_path = Path(output_path)\n\n                if output_path.is_dir():\n\n                    output_path = output_path.joinpath(f\"{self.name}.bez\")\n\n            with open(output_path, \"wb\") as f:\n\n                f.write(self.content)\n\n        return self.content\n\n    def parse_to_stream(self) -&gt; LogStream:\n\n        \"\"\"Parse the log file to a stream\n\n        Will download the log if it is not already downloaded.\n\n        *Returns*:\n\n        A `LogStream` object\n\n        \"\"\"\n\n        return LogStream(self.download(write_to_file=False))\n\n    def __format__(self, format_specifier):\n\n        if format_specifier == \"with_header\":\n\n            return tabulate.tabulate(\n\n                [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\"\n\n            )\n\n        else:\n\n            return tabulate.tabulate([self], tablefmt=\"plain\")\n\n    def __str__(self):\n\n        return f\"{self}\"\n\n    def __getitem__(self, item):\n\n        return self._formatted_values[item]\n\nclass Logs:\n\n    def __init__(self, parent_drone, auto_download_index=False):\n\n        self._parent_drone = parent_drone\n\n        self.auto_download_index = auto_download_index\n\n        self.index_downloaded = False\n\n        self._logs = {}\n\n        if auto_download_index:\n\n            self.refresh_log_index()\n\n    def refresh_log_index(self):\n\n        \"\"\"Refresh the log index from the drone\n\n        This is method is run on the first log access by default, but if you would like to check\n\n        for new log files it can be called at any time.\n\n        \"\"\"\n\n        if not self._parent_drone.connected:\n\n            raise ConnectionError(\n\n                \"The connection to the drone is not established, try calling the connect method \"\n\n                \"before retrying\"\n\n            )\n\n        logger.debug(\"Refreshing log index\")\n\n        logs_endpoint = f\"http://{self._parent_drone._ip}/logs\"\n\n        logs: List[dict] = requests.get(logs_endpoint).json()\n\n        if version.parse(self._parent_drone.software_version_short) &lt; version.parse(\"3.3\"):\n\n            # Extend index with dive info, sends a request for each log file so can be quite slow\n\n            # for drones with many logs. Not necessary for Blunux &gt;= 3.3 as dive info is included in\n\n            # the index.\n\n            logger.debug(f\"Getting dive info for {len(logs)} logs\")\n\n            for index, log in enumerate(logs):\n\n                dive_info = requests.get(f\"{logs_endpoint}/{log['name']}/dive_info\").json()\n\n                logs[index].update(dive_info)\n\n        # Instantiate log objects for each log\n\n        logger.debug(f\"Creating log objects for {len(logs)} logs\")\n\n        for log in logs:\n\n            if log[\"has_binlog\"]:\n\n                self._logs[log[\"name\"]] = LogFile(\n\n                    log[\"name\"],\n\n                    log[\"is_dive\"],\n\n                    log[\"binlog_size\"],\n\n                    log[\"start_time\"],\n\n                    log[\"max_depth_magnitude\"],\n\n                    self._parent_drone._ip,\n\n                )\n\n            else:\n\n                logger.info(f\"Log {log['name']} does not have a binlog, ignoring\")\n\n        self.index_downloaded = True\n\n    def __len__(self):\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        return len(self._logs)\n\n    def __getitem__(self, item):\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        if type(item) == str:\n\n            try:\n\n                return self._logs[item]\n\n            except KeyError:\n\n                raise KeyError(f\"A log with the name '{item}' does not exist\")\n\n        elif isinstance(item, slice):\n\n            logs_slice = Logs(self._parent_drone)\n\n            for log in list(self._logs.values())[item]:\n\n                logs_slice._logs[log.name] = log\n\n            logs_slice.index_downloaded = True\n\n            return logs_slice\n\n        else:\n\n            try:\n\n                return list(self._logs.values())[item]\n\n            except IndexError:\n\n                raise IndexError(\n\n                    f\"Tried to access log nr {item}, \"\n\n                    + f\"but there are only {len(self._logs.values())} logs available\"\n\n                )\n\n    def __str__(self):\n\n        return tabulate.tabulate(\n\n            self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\"\n\n        )\n\n    def filter(self, filter_func: Callable[[LogFile], bool]) -&gt; Logs:\n\n        \"\"\"Return a new Logs object with only those matching the filter\n\n        Eg. to get logs classified as a dive:\n\n        ```\n\n        dive_logs = myDrone.logs.filter(lambda log: log.is_dive)\n\n        ```\n\n        or to get all logs with a max depth greater than 10m:\n\n        ```\n\n        deep_logs = myDrone.logs.filter(lambda log: log.max_depth_magnitude &gt; 10)\n\n        ```\n\n        \"\"\"\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        filtered_logs = Logs(self._parent_drone)\n\n        filtered_logs.index_downloaded = True\n\n        for log in self:\n\n            if filter_func(log):\n\n                filtered_logs._logs[log.name] = log\n\n        return filtered_logs\n\nclass LegacyLogFile:\n\n    \"\"\"\n\n    This class is a container for a log file stored on the drone\n\n    The drone lists the file name, max depth, start time, and file size for each log,\n\n    and you can show this information by printing the log object, eg. on a Drone\n\n    object called `myDrone`:\n\n    ```\n\n    print(myDrone.logs[0])\n\n    ```\n\n    or, if you want to display the header you can format the object with `with_header`:\n\n    ```\n\n    print(f\"{myDrone.logs[0]:with_header}\")\n\n    ```\n\n    Calling the download() method on a log object will pull the CSV (Comma Separated\n\n    Value) file from the drone to your local filesystem.\n\n    \"\"\"\n\n    def __init__(self, maxdepth, name, timestamp, binsize, ip):\n\n        self.maxdepth = maxdepth\n\n        self.name = name\n\n        self.timestamp: datetime = dateutil.parser.isoparse(timestamp)\n\n        self.binsize = binsize\n\n        self.download_path = \"http://\" + ip + \"/logcsv/\" + name\n\n        self._formatted_values = [\n\n            self.name,\n\n            self.timestamp.strftime(\"%d. %b %Y %H:%M\"),\n\n            f\"{self.maxdepth/1000:.2f} m\",\n\n            human_readable_filesize(self.binsize),\n\n        ]\n\n    def download(self, output_path=None, output_name=None, downsample_divisor=10):\n\n        \"\"\"\n\n        Download the specified log to your local file system\n\n        If you specify an output_path the log file will be downloaded to that directory\n\n        instead of the current one.\n\n        Specifying output_name will overwrite the default file name with whatever you\n\n        have specified (be sure to include the .csv extension).\n\n        The drone samples the log content at 10 Hz, and by default this function downsamples this\n\n        rate to 1 Hz.\n\n        \"\"\"\n\n        log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content\n\n        if output_path is None:\n\n            output_path = \"./\"\n\n        if output_name is None:\n\n            output_name = self.name\n\n        with open(f\"{output_path}{output_name}\", \"wb\") as f:\n\n            f.write(log)\n\n    def __format__(self, format_specifier):\n\n        if format_specifier == \"with_header\":\n\n            return tabulate.tabulate(\n\n                [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\"\n\n            )\n\n        else:\n\n            return tabulate.tabulate([self], tablefmt=\"plain\")\n\n    def __str__(self):\n\n        return f\"{self}\"\n\n    def __getitem__(self, item):\n\n        return self._formatted_values[item]\n\nclass LegacyLogs:\n\n    \"\"\"This class is an index of the legacy csv log files stored on the drone\n\n    To show the available logs you simply print this object, ie. if your Drone object\n\n    is called `myDrone`, you can do:\n\n    ```\n\n    print(myDrone.legacy_logs)\n\n    ```\n\n    This will print a list of all available logs, with some of their metadata, such as\n\n    name and maxdepth.\n\n    You can access logfile objects either by index or by name. Eg. if you want the first\n\n    logfile in the list you can do `myDrone.logs[0]`, or if you want some particular log you\n\n    can do `myDrone.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want\n\n    the last 10 logs you can do `myDrone.logs[-10:]`.\n\n    \"\"\"\n\n    def __init__(self, parent_drone, auto_download_index=False):\n\n        self.ip = parent_drone._ip\n\n        self._parent_drone = parent_drone\n\n        self.index_downloaded = False\n\n        if auto_download_index:\n\n            self.refresh_log_index()\n\n        else:\n\n            self._logs = {}\n\n    def _get_list_of_logs_from_drone(self, get_all: bool):\n\n        list_of_dictionaries = requests.get(\n\n            \"http://\" + self.ip + \"/logcsv\", params={\"all\": True} if get_all else {}\n\n        ).json()\n\n        return list_of_dictionaries\n\n    def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries):\n\n        loglist = {}\n\n        for log in list_of_logs_in_dictionaries:\n\n            try:\n\n                loglist[log[\"name\"]] = LegacyLogFile(\n\n                    log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip\n\n                )\n\n            except dateutil.parser.ParserError:\n\n                logger.warning(\n\n                    f\"Could not parse timestamp for log {log['name']}, skipping this log file\"\n\n                )\n\n        return loglist\n\n    def refresh_log_index(self, get_all_logs=False):\n\n        \"\"\"Refresh the log index from the drone\n\n        This is method is run on the first log access by default, but if you would like to check\n\n        for new log files it can be called at any time.\n\n        Pass with `get_all_logs=True` to include logs that are not classified as dives.\n\n        \"\"\"\n\n        if not self._parent_drone.connected:\n\n            raise ConnectionError(\n\n                \"The connection to the drone is not established, try calling the connect method \"\n\n                \"before retrying\"\n\n            )\n\n        list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone(get_all_logs)\n\n        self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries)\n\n        self.index_downloaded = True\n\n    def __len__(self):\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        return len(self._logs)\n\n    def __getitem__(self, item):\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        if type(item) == str:\n\n            try:\n\n                return self._logs[item]\n\n            except KeyError:\n\n                raise KeyError(f\"A log with the name '{item}' does not exist\")\n\n        else:\n\n            try:\n\n                return list(self._logs.values())[item]\n\n            except IndexError:\n\n                raise IndexError(\n\n                    f\"Tried to access log nr {item}, \"\n\n                    + f\"but there are only {len(self._logs.values())} logs available\"\n\n                )\n\n    def __str__(self):\n\n        return tabulate.tabulate(\n\n            self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\"\n\n        )\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#variables","title":"Variables","text":"<pre><code>logger\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#functions","title":"Functions","text":""},{"location":"reference/blueye/sdk/logs/#decompress_log","title":"decompress_log","text":"<pre><code>def decompress_log(\n    log: 'bytes'\n) -&gt; 'bytes'\n</code></pre> <p>Decompress a log file</p> View Source <pre><code>def decompress_log(log: bytes) -&gt; bytes:\n\n    \"\"\"Decompress a log file\"\"\"\n\n    return zlib.decompressobj(wbits=zlib.MAX_WBITS | 16).decompress(log)\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#human_readable_filesize","title":"human_readable_filesize","text":"<pre><code>def human_readable_filesize(\n    binsize: 'int'\n) -&gt; 'str'\n</code></pre> <p>Convert bytes to human readable string</p> View Source <pre><code>def human_readable_filesize(binsize: int) -&gt; str:\n\n    \"\"\"Convert bytes to human readable string\"\"\"\n\n    suffix = \"B\"\n\n    num = binsize\n\n    for unit in [\"\", \"Ki\", \"Mi\"]:\n\n        if abs(num) &lt; 1024.0:\n\n            return f\"{num:3.1f} {unit}{suffix}\"\n\n        num /= 1024.0\n\n    return f\"{num:.1f} Gi{suffix}\"\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#classes","title":"Classes","text":""},{"location":"reference/blueye/sdk/logs/#legacylogfile","title":"LegacyLogFile","text":"<pre><code>class LegacyLogFile(\n    maxdepth,\n    name,\n    timestamp,\n    binsize,\n    ip\n)\n</code></pre> <p>This class is a container for a log file stored on the drone</p> <p>The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Drone object called <code>myDrone</code>:</p> <pre><code>print(myDrone.logs[0])\n</code></pre> <p>or, if you want to display the header you can format the object with <code>with_header</code>:</p> <pre><code>print(f\"{myDrone.logs[0]:with_header}\")\n</code></pre> <p>Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem.</p> View Source <pre><code>class LegacyLogFile:\n\n    \"\"\"\n\n    This class is a container for a log file stored on the drone\n\n    The drone lists the file name, max depth, start time, and file size for each log,\n\n    and you can show this information by printing the log object, eg. on a Drone\n\n    object called `myDrone`:\n\n    ```\n\n    print(myDrone.logs[0])\n\n    ```\n\n    or, if you want to display the header you can format the object with `with_header`:\n\n    ```\n\n    print(f\"{myDrone.logs[0]:with_header}\")\n\n    ```\n\n    Calling the download() method on a log object will pull the CSV (Comma Separated\n\n    Value) file from the drone to your local filesystem.\n\n    \"\"\"\n\n    def __init__(self, maxdepth, name, timestamp, binsize, ip):\n\n        self.maxdepth = maxdepth\n\n        self.name = name\n\n        self.timestamp: datetime = dateutil.parser.isoparse(timestamp)\n\n        self.binsize = binsize\n\n        self.download_path = \"http://\" + ip + \"/logcsv/\" + name\n\n        self._formatted_values = [\n\n            self.name,\n\n            self.timestamp.strftime(\"%d. %b %Y %H:%M\"),\n\n            f\"{self.maxdepth/1000:.2f} m\",\n\n            human_readable_filesize(self.binsize),\n\n        ]\n\n    def download(self, output_path=None, output_name=None, downsample_divisor=10):\n\n        \"\"\"\n\n        Download the specified log to your local file system\n\n        If you specify an output_path the log file will be downloaded to that directory\n\n        instead of the current one.\n\n        Specifying output_name will overwrite the default file name with whatever you\n\n        have specified (be sure to include the .csv extension).\n\n        The drone samples the log content at 10 Hz, and by default this function downsamples this\n\n        rate to 1 Hz.\n\n        \"\"\"\n\n        log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content\n\n        if output_path is None:\n\n            output_path = \"./\"\n\n        if output_name is None:\n\n            output_name = self.name\n\n        with open(f\"{output_path}{output_name}\", \"wb\") as f:\n\n            f.write(log)\n\n    def __format__(self, format_specifier):\n\n        if format_specifier == \"with_header\":\n\n            return tabulate.tabulate(\n\n                [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\"\n\n            )\n\n        else:\n\n            return tabulate.tabulate([self], tablefmt=\"plain\")\n\n    def __str__(self):\n\n        return f\"{self}\"\n\n    def __getitem__(self, item):\n\n        return self._formatted_values[item]\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#methods","title":"Methods","text":""},{"location":"reference/blueye/sdk/logs/#download","title":"download","text":"<pre><code>def download(\n    self,\n    output_path=None,\n    output_name=None,\n    downsample_divisor=10\n)\n</code></pre> <p>Download the specified log to your local file system</p> <p>If you specify an output_path the log file will be downloaded to that directory instead of the current one.</p> <p>Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension).</p> <p>The drone samples the log content at 10 Hz, and by default this function downsamples this rate to 1 Hz.</p> View Source <pre><code>    def download(self, output_path=None, output_name=None, downsample_divisor=10):\n\n        \"\"\"\n\n        Download the specified log to your local file system\n\n        If you specify an output_path the log file will be downloaded to that directory\n\n        instead of the current one.\n\n        Specifying output_name will overwrite the default file name with whatever you\n\n        have specified (be sure to include the .csv extension).\n\n        The drone samples the log content at 10 Hz, and by default this function downsamples this\n\n        rate to 1 Hz.\n\n        \"\"\"\n\n        log = requests.get(self.download_path, params={\"divisor\": downsample_divisor}).content\n\n        if output_path is None:\n\n            output_path = \"./\"\n\n        if output_name is None:\n\n            output_name = self.name\n\n        with open(f\"{output_path}{output_name}\", \"wb\") as f:\n\n            f.write(log)\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#legacylogs","title":"LegacyLogs","text":"<pre><code>class LegacyLogs(\n    parent_drone,\n    auto_download_index=False\n)\n</code></pre> <p>This class is an index of the legacy csv log files stored on the drone</p> <p>To show the available logs you simply print this object, ie. if your Drone object is called <code>myDrone</code>, you can do:</p> <pre><code>print(myDrone.legacy_logs)\n</code></pre> <p>This will print a list of all available logs, with some of their metadata, such as name and maxdepth.</p> <p>You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do <code>myDrone.logs[0]</code>, or if you want some particular log you can do <code>myDrone.logs[\"exampleName0001.csv\"]</code>. You can even give it a slice, so if you want the last 10 logs you can do <code>myDrone.logs[-10:]</code>.</p> View Source <pre><code>class LegacyLogs:\n\n    \"\"\"This class is an index of the legacy csv log files stored on the drone\n\n    To show the available logs you simply print this object, ie. if your Drone object\n\n    is called `myDrone`, you can do:\n\n    ```\n\n    print(myDrone.legacy_logs)\n\n    ```\n\n    This will print a list of all available logs, with some of their metadata, such as\n\n    name and maxdepth.\n\n    You can access logfile objects either by index or by name. Eg. if you want the first\n\n    logfile in the list you can do `myDrone.logs[0]`, or if you want some particular log you\n\n    can do `myDrone.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want\n\n    the last 10 logs you can do `myDrone.logs[-10:]`.\n\n    \"\"\"\n\n    def __init__(self, parent_drone, auto_download_index=False):\n\n        self.ip = parent_drone._ip\n\n        self._parent_drone = parent_drone\n\n        self.index_downloaded = False\n\n        if auto_download_index:\n\n            self.refresh_log_index()\n\n        else:\n\n            self._logs = {}\n\n    def _get_list_of_logs_from_drone(self, get_all: bool):\n\n        list_of_dictionaries = requests.get(\n\n            \"http://\" + self.ip + \"/logcsv\", params={\"all\": True} if get_all else {}\n\n        ).json()\n\n        return list_of_dictionaries\n\n    def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries):\n\n        loglist = {}\n\n        for log in list_of_logs_in_dictionaries:\n\n            try:\n\n                loglist[log[\"name\"]] = LegacyLogFile(\n\n                    log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip\n\n                )\n\n            except dateutil.parser.ParserError:\n\n                logger.warning(\n\n                    f\"Could not parse timestamp for log {log['name']}, skipping this log file\"\n\n                )\n\n        return loglist\n\n    def refresh_log_index(self, get_all_logs=False):\n\n        \"\"\"Refresh the log index from the drone\n\n        This is method is run on the first log access by default, but if you would like to check\n\n        for new log files it can be called at any time.\n\n        Pass with `get_all_logs=True` to include logs that are not classified as dives.\n\n        \"\"\"\n\n        if not self._parent_drone.connected:\n\n            raise ConnectionError(\n\n                \"The connection to the drone is not established, try calling the connect method \"\n\n                \"before retrying\"\n\n            )\n\n        list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone(get_all_logs)\n\n        self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries)\n\n        self.index_downloaded = True\n\n    def __len__(self):\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        return len(self._logs)\n\n    def __getitem__(self, item):\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        if type(item) == str:\n\n            try:\n\n                return self._logs[item]\n\n            except KeyError:\n\n                raise KeyError(f\"A log with the name '{item}' does not exist\")\n\n        else:\n\n            try:\n\n                return list(self._logs.values())[item]\n\n            except IndexError:\n\n                raise IndexError(\n\n                    f\"Tried to access log nr {item}, \"\n\n                    + f\"but there are only {len(self._logs.values())} logs available\"\n\n                )\n\n    def __str__(self):\n\n        return tabulate.tabulate(\n\n            self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\"\n\n        )\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#methods_1","title":"Methods","text":""},{"location":"reference/blueye/sdk/logs/#refresh_log_index","title":"refresh_log_index","text":"<pre><code>def refresh_log_index(\n    self,\n    get_all_logs=False\n)\n</code></pre> <p>Refresh the log index from the drone</p> <p>This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time.</p> <p>Pass with <code>get_all_logs=True</code> to include logs that are not classified as dives.</p> View Source <pre><code>    def refresh_log_index(self, get_all_logs=False):\n\n        \"\"\"Refresh the log index from the drone\n\n        This is method is run on the first log access by default, but if you would like to check\n\n        for new log files it can be called at any time.\n\n        Pass with `get_all_logs=True` to include logs that are not classified as dives.\n\n        \"\"\"\n\n        if not self._parent_drone.connected:\n\n            raise ConnectionError(\n\n                \"The connection to the drone is not established, try calling the connect method \"\n\n                \"before retrying\"\n\n            )\n\n        list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone(get_all_logs)\n\n        self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries)\n\n        self.index_downloaded = True\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#logfile","title":"LogFile","text":"<pre><code>class LogFile(\n    name: 'str',\n    is_dive: 'bool',\n    filesize: 'int',\n    start_time: 'int',\n    max_depth_magnitude: 'int',\n    ip: 'str'\n)\n</code></pre> View Source <pre><code>class LogFile:\n\n    def __init__(\n\n        self,\n\n        name: str,\n\n        is_dive: bool,\n\n        filesize: int,\n\n        start_time: int,\n\n        max_depth_magnitude: int,\n\n        ip: str,\n\n    ):\n\n        self.name = name\n\n        self.is_dive = is_dive\n\n        self.filesize = filesize\n\n        self.start_time: datetime = datetime.fromtimestamp(start_time, tz=timezone.utc)\n\n        self.max_depth_magnitude = max_depth_magnitude\n\n        self.download_url = f\"http://{ip}/logs/{self.name}/binlog\"\n\n        self.content = None\n\n        self._formatted_values = [\n\n            self.name,\n\n            self.start_time.strftime(\"%d. %b %Y %H:%M\"),\n\n            f\"{self.max_depth_magnitude} m\",\n\n            human_readable_filesize(self.filesize),\n\n        ]\n\n    def download(\n\n        self,\n\n        output_path: Optional[Path | str] = None,\n\n        write_to_file: bool = True,\n\n        timeout: float = 1,\n\n        overwrite_cache: bool = False,\n\n    ) -&gt; bytes:\n\n        \"\"\"Download a log file from the drone\n\n        *Arguments*:\n\n        * `output_path`:\n\n            Path to write the log file to. If `None`, the log will be written to the\n\n            current working directory. If the path is a directory, the log will be\n\n            downloaded to that directory with its original name. Else the log will be\n\n            downloaded to the specified path.\n\n        * `write_to_file`:\n\n            If True, the log will be written to the specified path. If False, the\n\n            log will only be returned as a bytes object.\n\n        * `timeout`:\n\n            Seconds to wait for response\n\n        * `overwrite_cache`:\n\n            If True, the log will be downloaded even if it is already been downloaded.\n\n        *Returns*:\n\n        The compressed log file as a bytes object.\n\n        \"\"\"\n\n        if self.content is None or overwrite_cache:\n\n            self.content = requests.get(self.download_url, timeout=timeout).content\n\n        if write_to_file:\n\n            if output_path is None:\n\n                output_path = Path(f\"{self.name}.bez\")\n\n            else:\n\n                if type(output_path) == str:\n\n                    output_path = Path(output_path)\n\n                if output_path.is_dir():\n\n                    output_path = output_path.joinpath(f\"{self.name}.bez\")\n\n            with open(output_path, \"wb\") as f:\n\n                f.write(self.content)\n\n        return self.content\n\n    def parse_to_stream(self) -&gt; LogStream:\n\n        \"\"\"Parse the log file to a stream\n\n        Will download the log if it is not already downloaded.\n\n        *Returns*:\n\n        A `LogStream` object\n\n        \"\"\"\n\n        return LogStream(self.download(write_to_file=False))\n\n    def __format__(self, format_specifier):\n\n        if format_specifier == \"with_header\":\n\n            return tabulate.tabulate(\n\n                [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\"\n\n            )\n\n        else:\n\n            return tabulate.tabulate([self], tablefmt=\"plain\")\n\n    def __str__(self):\n\n        return f\"{self}\"\n\n    def __getitem__(self, item):\n\n        return self._formatted_values[item]\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#methods_2","title":"Methods","text":""},{"location":"reference/blueye/sdk/logs/#download_1","title":"download","text":"<pre><code>def download(\n    self,\n    output_path: 'Optional[Path | str]' = None,\n    write_to_file: 'bool' = True,\n    timeout: 'float' = 1,\n    overwrite_cache: 'bool' = False\n) -&gt; 'bytes'\n</code></pre> <p>Download a log file from the drone</p> <p>Arguments:</p> <ul> <li><code>output_path</code>:     Path to write the log file to. If <code>None</code>, the log will be written to the     current working directory. If the path is a directory, the log will be     downloaded to that directory with its original name. Else the log will be     downloaded to the specified path.</li> <li><code>write_to_file</code>:     If True, the log will be written to the specified path. If False, the     log will only be returned as a bytes object.</li> <li><code>timeout</code>:     Seconds to wait for response</li> <li><code>overwrite_cache</code>:     If True, the log will be downloaded even if it is already been downloaded.</li> </ul> <p>Returns:</p> <p>The compressed log file as a bytes object.</p> View Source <pre><code>    def download(\n\n        self,\n\n        output_path: Optional[Path | str] = None,\n\n        write_to_file: bool = True,\n\n        timeout: float = 1,\n\n        overwrite_cache: bool = False,\n\n    ) -&gt; bytes:\n\n        \"\"\"Download a log file from the drone\n\n        *Arguments*:\n\n        * `output_path`:\n\n            Path to write the log file to. If `None`, the log will be written to the\n\n            current working directory. If the path is a directory, the log will be\n\n            downloaded to that directory with its original name. Else the log will be\n\n            downloaded to the specified path.\n\n        * `write_to_file`:\n\n            If True, the log will be written to the specified path. If False, the\n\n            log will only be returned as a bytes object.\n\n        * `timeout`:\n\n            Seconds to wait for response\n\n        * `overwrite_cache`:\n\n            If True, the log will be downloaded even if it is already been downloaded.\n\n        *Returns*:\n\n        The compressed log file as a bytes object.\n\n        \"\"\"\n\n        if self.content is None or overwrite_cache:\n\n            self.content = requests.get(self.download_url, timeout=timeout).content\n\n        if write_to_file:\n\n            if output_path is None:\n\n                output_path = Path(f\"{self.name}.bez\")\n\n            else:\n\n                if type(output_path) == str:\n\n                    output_path = Path(output_path)\n\n                if output_path.is_dir():\n\n                    output_path = output_path.joinpath(f\"{self.name}.bez\")\n\n            with open(output_path, \"wb\") as f:\n\n                f.write(self.content)\n\n        return self.content\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#parse_to_stream","title":"parse_to_stream","text":"<pre><code>def parse_to_stream(\n    self\n) -&gt; 'LogStream'\n</code></pre> <p>Parse the log file to a stream</p> <p>Will download the log if it is not already downloaded.</p> <p>Returns:</p> <p>A <code>LogStream</code> object</p> View Source <pre><code>    def parse_to_stream(self) -&gt; LogStream:\n\n        \"\"\"Parse the log file to a stream\n\n        Will download the log if it is not already downloaded.\n\n        *Returns*:\n\n        A `LogStream` object\n\n        \"\"\"\n\n        return LogStream(self.download(write_to_file=False))\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#logstream","title":"LogStream","text":"<pre><code>class LogStream(\n    log: 'bytes',\n    decompress: 'bool' = True\n)\n</code></pre> <p>Class for streaming a log</p> <p>Creates a stream from a downloaded log file. Iterate over the object to get the next log record.</p> View Source <pre><code>class LogStream:\n\n    \"\"\"Class for streaming a log\n\n    Creates a stream from a downloaded log file. Iterate over the object to get the next log record.\n\n    \"\"\"\n\n    def __init__(\n\n        self, log: bytes, decompress: bool = True\n\n    ) -&gt; Iterator[\n\n        Tuple[\n\n            proto.datetime_helpers.DatetimeWithNanoseconds,  # Real time clock\n\n            timedelta,  # Time since first message\n\n            proto.message.MessageMeta,  # Message type\n\n            proto.message.Message,  # Message contents\n\n        ]\n\n    ]:\n\n        if decompress:\n\n            self.decompressed_log = decompress_log(log)\n\n        else:\n\n            self.decompressed_log = log\n\n        self.pos = 0\n\n        self.start_monotonic: proto.datetime_helpers.DatetimeWithNanoseconds = 0\n\n    def __iter__(self):\n\n        return self\n\n    def __next__(self):\n\n        if self.pos &lt; len(self.decompressed_log):\n\n            msg_size, pos_msg_start = decodeVarint(self.decompressed_log, self.pos)\n\n            msg_data = self.decompressed_log[pos_msg_start : (pos_msg_start + msg_size)]\n\n            if len(msg_data) &lt; msg_size:\n\n                raise EOFError(\"Not enough bytes to read message\")\n\n            self.pos = pos_msg_start + msg_size\n\n            msg = bp.BinlogRecord.deserialize(msg_data)\n\n            payload_type, payload_msg_deserialized = deserialize_any_to_message(msg)\n\n            if self.start_monotonic == 0:\n\n                self.start_monotonic = msg.clock_monotonic\n\n            return (\n\n                msg.unix_timestamp,\n\n                msg.clock_monotonic - self.start_monotonic,\n\n                payload_type,\n\n                payload_msg_deserialized,\n\n            )\n\n        else:\n\n            raise StopIteration\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#logs","title":"Logs","text":"<pre><code>class Logs(\n    parent_drone,\n    auto_download_index=False\n)\n</code></pre> View Source <pre><code>class Logs:\n\n    def __init__(self, parent_drone, auto_download_index=False):\n\n        self._parent_drone = parent_drone\n\n        self.auto_download_index = auto_download_index\n\n        self.index_downloaded = False\n\n        self._logs = {}\n\n        if auto_download_index:\n\n            self.refresh_log_index()\n\n    def refresh_log_index(self):\n\n        \"\"\"Refresh the log index from the drone\n\n        This is method is run on the first log access by default, but if you would like to check\n\n        for new log files it can be called at any time.\n\n        \"\"\"\n\n        if not self._parent_drone.connected:\n\n            raise ConnectionError(\n\n                \"The connection to the drone is not established, try calling the connect method \"\n\n                \"before retrying\"\n\n            )\n\n        logger.debug(\"Refreshing log index\")\n\n        logs_endpoint = f\"http://{self._parent_drone._ip}/logs\"\n\n        logs: List[dict] = requests.get(logs_endpoint).json()\n\n        if version.parse(self._parent_drone.software_version_short) &lt; version.parse(\"3.3\"):\n\n            # Extend index with dive info, sends a request for each log file so can be quite slow\n\n            # for drones with many logs. Not necessary for Blunux &gt;= 3.3 as dive info is included in\n\n            # the index.\n\n            logger.debug(f\"Getting dive info for {len(logs)} logs\")\n\n            for index, log in enumerate(logs):\n\n                dive_info = requests.get(f\"{logs_endpoint}/{log['name']}/dive_info\").json()\n\n                logs[index].update(dive_info)\n\n        # Instantiate log objects for each log\n\n        logger.debug(f\"Creating log objects for {len(logs)} logs\")\n\n        for log in logs:\n\n            if log[\"has_binlog\"]:\n\n                self._logs[log[\"name\"]] = LogFile(\n\n                    log[\"name\"],\n\n                    log[\"is_dive\"],\n\n                    log[\"binlog_size\"],\n\n                    log[\"start_time\"],\n\n                    log[\"max_depth_magnitude\"],\n\n                    self._parent_drone._ip,\n\n                )\n\n            else:\n\n                logger.info(f\"Log {log['name']} does not have a binlog, ignoring\")\n\n        self.index_downloaded = True\n\n    def __len__(self):\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        return len(self._logs)\n\n    def __getitem__(self, item):\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        if type(item) == str:\n\n            try:\n\n                return self._logs[item]\n\n            except KeyError:\n\n                raise KeyError(f\"A log with the name '{item}' does not exist\")\n\n        elif isinstance(item, slice):\n\n            logs_slice = Logs(self._parent_drone)\n\n            for log in list(self._logs.values())[item]:\n\n                logs_slice._logs[log.name] = log\n\n            logs_slice.index_downloaded = True\n\n            return logs_slice\n\n        else:\n\n            try:\n\n                return list(self._logs.values())[item]\n\n            except IndexError:\n\n                raise IndexError(\n\n                    f\"Tried to access log nr {item}, \"\n\n                    + f\"but there are only {len(self._logs.values())} logs available\"\n\n                )\n\n    def __str__(self):\n\n        return tabulate.tabulate(\n\n            self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\"\n\n        )\n\n    def filter(self, filter_func: Callable[[LogFile], bool]) -&gt; Logs:\n\n        \"\"\"Return a new Logs object with only those matching the filter\n\n        Eg. to get logs classified as a dive:\n\n        ```\n\n        dive_logs = myDrone.logs.filter(lambda log: log.is_dive)\n\n        ```\n\n        or to get all logs with a max depth greater than 10m:\n\n        ```\n\n        deep_logs = myDrone.logs.filter(lambda log: log.max_depth_magnitude &gt; 10)\n\n        ```\n\n        \"\"\"\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        filtered_logs = Logs(self._parent_drone)\n\n        filtered_logs.index_downloaded = True\n\n        for log in self:\n\n            if filter_func(log):\n\n                filtered_logs._logs[log.name] = log\n\n        return filtered_logs\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#methods_3","title":"Methods","text":""},{"location":"reference/blueye/sdk/logs/#filter","title":"filter","text":"<pre><code>def filter(\n    self,\n    filter_func: 'Callable[[LogFile], bool]'\n) -&gt; 'Logs'\n</code></pre> <p>Return a new Logs object with only those matching the filter</p> <p>Eg. to get logs classified as a dive: <pre><code>dive_logs = myDrone.logs.filter(lambda log: log.is_dive)\n</code></pre></p> <p>or to get all logs with a max depth greater than 10m: <pre><code>deep_logs = myDrone.logs.filter(lambda log: log.max_depth_magnitude &gt; 10)\n</code></pre></p> View Source <pre><code>    def filter(self, filter_func: Callable[[LogFile], bool]) -&gt; Logs:\n\n        \"\"\"Return a new Logs object with only those matching the filter\n\n        Eg. to get logs classified as a dive:\n\n        ```\n\n        dive_logs = myDrone.logs.filter(lambda log: log.is_dive)\n\n        ```\n\n        or to get all logs with a max depth greater than 10m:\n\n        ```\n\n        deep_logs = myDrone.logs.filter(lambda log: log.max_depth_magnitude &gt; 10)\n\n        ```\n\n        \"\"\"\n\n        if not self.index_downloaded:\n\n            self.refresh_log_index()\n\n        filtered_logs = Logs(self._parent_drone)\n\n        filtered_logs.index_downloaded = True\n\n        for log in self:\n\n            if filter_func(log):\n\n                filtered_logs._logs[log.name] = log\n\n        return filtered_logs\n</code></pre>"},{"location":"reference/blueye/sdk/logs/#refresh_log_index_1","title":"refresh_log_index","text":"<pre><code>def refresh_log_index(\n    self\n)\n</code></pre> <p>Refresh the log index from the drone</p> <p>This is method is run on the first log access by default, but if you would like to check for new log files it can be called at any time.</p> View Source <pre><code>    def refresh_log_index(self):\n\n        \"\"\"Refresh the log index from the drone\n\n        This is method is run on the first log access by default, but if you would like to check\n\n        for new log files it can be called at any time.\n\n        \"\"\"\n\n        if not self._parent_drone.connected:\n\n            raise ConnectionError(\n\n                \"The connection to the drone is not established, try calling the connect method \"\n\n                \"before retrying\"\n\n            )\n\n        logger.debug(\"Refreshing log index\")\n\n        logs_endpoint = f\"http://{self._parent_drone._ip}/logs\"\n\n        logs: List[dict] = requests.get(logs_endpoint).json()\n\n        if version.parse(self._parent_drone.software_version_short) &lt; version.parse(\"3.3\"):\n\n            # Extend index with dive info, sends a request for each log file so can be quite slow\n\n            # for drones with many logs. Not necessary for Blunux &gt;= 3.3 as dive info is included in\n\n            # the index.\n\n            logger.debug(f\"Getting dive info for {len(logs)} logs\")\n\n            for index, log in enumerate(logs):\n\n                dive_info = requests.get(f\"{logs_endpoint}/{log['name']}/dive_info\").json()\n\n                logs[index].update(dive_info)\n\n        # Instantiate log objects for each log\n\n        logger.debug(f\"Creating log objects for {len(logs)} logs\")\n\n        for log in logs:\n\n            if log[\"has_binlog\"]:\n\n                self._logs[log[\"name\"]] = LogFile(\n\n                    log[\"name\"],\n\n                    log[\"is_dive\"],\n\n                    log[\"binlog_size\"],\n\n                    log[\"start_time\"],\n\n                    log[\"max_depth_magnitude\"],\n\n                    self._parent_drone._ip,\n\n                )\n\n            else:\n\n                logger.info(f\"Log {log['name']} does not have a binlog, ignoring\")\n\n        self.index_downloaded = True\n</code></pre>"},{"location":"reference/blueye/sdk/motion/","title":"Module blueye.sdk.motion","text":"View Source <pre><code>import threading\n\nfrom typing import Optional\n\nimport blueye.protocol\n\nclass Motion:\n\n    \"\"\"Control the motion of the drone, and set automatic control modes\n\n    Motion can be set one degree of freedom at a time by using the 4 motion properties\n\n    (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the\n\n    `send_thruster_setpoint` method.\n\n    \"\"\"\n\n    def __init__(self, parent_drone):\n\n        self._parent_drone = parent_drone\n\n        self.thruster_lock = threading.Lock()\n\n        self._current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0}\n\n        self._current_boost_setpoints = {\"slow\": 0, \"boost\": 0}\n\n    @property\n\n    def current_thruster_setpoints(self):\n\n        \"\"\"Returns the current setpoints for the thrusters\n\n        We maintain this state in the SDK since the drone expects to receive all of the setpoints at\n\n        once.\n\n        For setting the setpoints you should use the dedicated properties/functions for that, trying\n\n        to set them directly with this property will raise an AttributeError.\n\n        \"\"\"\n\n        return self._current_thruster_setpoints\n\n    @current_thruster_setpoints.setter\n\n    def current_thruster_setpoints(self, *args, **kwargs):\n\n        raise AttributeError(\n\n            \"Do not set the setpoints directly, use the surge, sway, heave, yaw properties or the \"\n\n            \"send_thruster_setpoint function for that.\"\n\n        )\n\n    def _send_motion_input_message(self):\n\n        \"\"\"Small helper function for building argument list to motion_input command\"\"\"\n\n        thruster_setpoints = self.current_thruster_setpoints.values()\n\n        boost_setpoints = self._current_boost_setpoints.values()\n\n        self._parent_drone._ctrl_client.set_motion_input(*thruster_setpoints, *boost_setpoints)\n\n    @property\n\n    def surge(self) -&gt; float:\n\n        \"\"\"Set force reference for the surge direction\n\n        Arguments:\n\n        * **surge** (float): Force set point in the surge direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move forward\n\n        \"\"\"\n\n        return self.current_thruster_setpoints[\"surge\"]\n\n    @surge.setter\n\n    def surge(self, surge_value: float):\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"surge\"] = surge_value\n\n            self._send_motion_input_message()\n\n    @property\n\n    def sway(self) -&gt; float:\n\n        \"\"\"Set force reference for the sway direction\n\n        Arguments:\n\n        * **sway** (float): Force set point in the sway direction in range &lt;-1, 1&gt;,\n\n                            a positive set point makes the drone move to the right\n\n        \"\"\"\n\n        return self.current_thruster_setpoints[\"sway\"]\n\n    @sway.setter\n\n    def sway(self, sway_value: float):\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"sway\"] = sway_value\n\n            self._send_motion_input_message()\n\n    @property\n\n    def heave(self) -&gt; float:\n\n        \"\"\"Set force reference for the heave direction\n\n        Arguments:\n\n        * **heave** (float): Force set point in the heave direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move downwards\n\n        \"\"\"\n\n        return self.current_thruster_setpoints[\"heave\"]\n\n    @heave.setter\n\n    def heave(self, heave_value: float):\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"heave\"] = heave_value\n\n            self._send_motion_input_message()\n\n    @property\n\n    def yaw(self) -&gt; float:\n\n        \"\"\"Set force reference for the yaw direction\n\n        Arguments:\n\n        * **yaw** (float): Moment set point in the sway direction in range &lt;-1, 1&gt;,\n\n                           a positive set point makes the drone rotate clockwise.\n\n        \"\"\"\n\n        return self.current_thruster_setpoints[\"yaw\"]\n\n    @yaw.setter\n\n    def yaw(self, yaw_value: float):\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"yaw\"] = yaw_value\n\n            self._send_motion_input_message()\n\n    def send_thruster_setpoint(self, surge, sway, heave, yaw):\n\n        \"\"\"Control the thrusters of the drone\n\n        Set reference values between -1 and 1 for each controllable degree of freedom on the drone.\n\n        The reference values are mapped linearly to a thruster force, a set point of -1 correspons\n\n        to maximum negative force and a set point of 1 corresponds to maximum positive force. For\n\n        the yaw direction the reference is a moment not a force, as the yaw direction is rotational\n\n        not translational.\n\n        Arguments:\n\n        * **surge** (float): Force set point in the surge direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move forward\n\n        * **sway** (float): Force set point in the sway direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move to the right\n\n        * **heave** (float): Force set point in the heave direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move down.\n\n        * **yaw** (float): Moment set point in the yaw direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone rotate clockwise.\n\n        \"\"\"\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"surge\"] = surge\n\n            self._current_thruster_setpoints[\"sway\"] = sway\n\n            self._current_thruster_setpoints[\"heave\"] = heave\n\n            self._current_thruster_setpoints[\"yaw\"] = yaw\n\n            self._send_motion_input_message()\n\n    @property\n\n    def boost(self) -&gt; float:\n\n        \"\"\"Get or set the boost gain\n\n        Arguments:\n\n        * **boost_gain** (float): Range from 0 to 1.\n\n        \"\"\"\n\n        return self._current_boost_setpoints[\"boost\"]\n\n    @boost.setter\n\n    def boost(self, boost_gain: float):\n\n        with self.thruster_lock:\n\n            self._current_boost_setpoints[\"boost\"] = boost_gain\n\n            self._send_motion_input_message()\n\n    @property\n\n    def slow(self) -&gt; float:\n\n        \"\"\"Get or set the \"slow gain\" (inverse of boost)\n\n        Arguments:\n\n        * **slow_gain** (float): Range from 0 to 1.\n\n        \"\"\"\n\n        return self._current_boost_setpoints[\"slow\"]\n\n    @slow.setter\n\n    def slow(self, slow_gain: float):\n\n        with self.thruster_lock:\n\n            self._current_boost_setpoints[\"slow\"] = slow_gain\n\n            self._send_motion_input_message()\n\n    @property\n\n    def auto_depth_active(self) -&gt; Optional[bool]:\n\n        \"\"\"Enable or disable the auto depth control mode\n\n        When auto depth is active, input for the heave direction to the thruster_setpoint function\n\n        specifies a speed set point instead of a force set point. A control loop on the drone will\n\n        then attempt to maintain the wanted speed in the heave direction as long as auto depth is\n\n        active.\n\n        *Arguments*:\n\n        * Enable (bool): Activate auto depth mode if true, de-activate if false\n\n        *Returns*:\n\n        * Auto depth state (bool): True if auto depth is active, false if not\n\n        \"\"\"\n\n        control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel)\n\n        if control_mode_tel is None:\n\n            return None\n\n        else:\n\n            return control_mode_tel.state.auto_depth\n\n    @auto_depth_active.setter\n\n    def auto_depth_active(self, enable: bool):\n\n        self._parent_drone._ctrl_client.set_auto_depth_state(enable)\n\n    @property\n\n    def auto_heading_active(self) -&gt; Optional[bool]:\n\n        \"\"\"Enable or disable the auto heading control mode\n\n        When auto heading is active, input for the yaw direction to the thruster_setpoint function\n\n        specifies a angular speed set point instead of a moment set point. A control loop on the\n\n        drone will then attempt to maintain the wanted angular velocity in the yaw direction as\n\n        long as auto heading is active.\n\n        *Arguments*:\n\n        * Enable (bool): Activate auto heading mode if true, de-activate if false\n\n        *Returns*:\n\n        * Auto heading state (bool): True if auto heading mode is active, false if not\n\n        \"\"\"\n\n        control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel)\n\n        if control_mode_tel is None:\n\n            return None\n\n        else:\n\n            return control_mode_tel.state.auto_heading\n\n    @auto_heading_active.setter\n\n    def auto_heading_active(self, enable: bool):\n\n        self._parent_drone._ctrl_client.set_auto_heading_state(enable)\n</code></pre>"},{"location":"reference/blueye/sdk/motion/#classes","title":"Classes","text":""},{"location":"reference/blueye/sdk/motion/#motion","title":"Motion","text":"<pre><code>class Motion(\n    parent_drone\n)\n</code></pre> <p>Control the motion of the drone, and set automatic control modes</p> <p>Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the <code>send_thruster_setpoint</code> method.</p> View Source <pre><code>class Motion:\n\n    \"\"\"Control the motion of the drone, and set automatic control modes\n\n    Motion can be set one degree of freedom at a time by using the 4 motion properties\n\n    (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the\n\n    `send_thruster_setpoint` method.\n\n    \"\"\"\n\n    def __init__(self, parent_drone):\n\n        self._parent_drone = parent_drone\n\n        self.thruster_lock = threading.Lock()\n\n        self._current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0}\n\n        self._current_boost_setpoints = {\"slow\": 0, \"boost\": 0}\n\n    @property\n\n    def current_thruster_setpoints(self):\n\n        \"\"\"Returns the current setpoints for the thrusters\n\n        We maintain this state in the SDK since the drone expects to receive all of the setpoints at\n\n        once.\n\n        For setting the setpoints you should use the dedicated properties/functions for that, trying\n\n        to set them directly with this property will raise an AttributeError.\n\n        \"\"\"\n\n        return self._current_thruster_setpoints\n\n    @current_thruster_setpoints.setter\n\n    def current_thruster_setpoints(self, *args, **kwargs):\n\n        raise AttributeError(\n\n            \"Do not set the setpoints directly, use the surge, sway, heave, yaw properties or the \"\n\n            \"send_thruster_setpoint function for that.\"\n\n        )\n\n    def _send_motion_input_message(self):\n\n        \"\"\"Small helper function for building argument list to motion_input command\"\"\"\n\n        thruster_setpoints = self.current_thruster_setpoints.values()\n\n        boost_setpoints = self._current_boost_setpoints.values()\n\n        self._parent_drone._ctrl_client.set_motion_input(*thruster_setpoints, *boost_setpoints)\n\n    @property\n\n    def surge(self) -&gt; float:\n\n        \"\"\"Set force reference for the surge direction\n\n        Arguments:\n\n        * **surge** (float): Force set point in the surge direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move forward\n\n        \"\"\"\n\n        return self.current_thruster_setpoints[\"surge\"]\n\n    @surge.setter\n\n    def surge(self, surge_value: float):\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"surge\"] = surge_value\n\n            self._send_motion_input_message()\n\n    @property\n\n    def sway(self) -&gt; float:\n\n        \"\"\"Set force reference for the sway direction\n\n        Arguments:\n\n        * **sway** (float): Force set point in the sway direction in range &lt;-1, 1&gt;,\n\n                            a positive set point makes the drone move to the right\n\n        \"\"\"\n\n        return self.current_thruster_setpoints[\"sway\"]\n\n    @sway.setter\n\n    def sway(self, sway_value: float):\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"sway\"] = sway_value\n\n            self._send_motion_input_message()\n\n    @property\n\n    def heave(self) -&gt; float:\n\n        \"\"\"Set force reference for the heave direction\n\n        Arguments:\n\n        * **heave** (float): Force set point in the heave direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move downwards\n\n        \"\"\"\n\n        return self.current_thruster_setpoints[\"heave\"]\n\n    @heave.setter\n\n    def heave(self, heave_value: float):\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"heave\"] = heave_value\n\n            self._send_motion_input_message()\n\n    @property\n\n    def yaw(self) -&gt; float:\n\n        \"\"\"Set force reference for the yaw direction\n\n        Arguments:\n\n        * **yaw** (float): Moment set point in the sway direction in range &lt;-1, 1&gt;,\n\n                           a positive set point makes the drone rotate clockwise.\n\n        \"\"\"\n\n        return self.current_thruster_setpoints[\"yaw\"]\n\n    @yaw.setter\n\n    def yaw(self, yaw_value: float):\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"yaw\"] = yaw_value\n\n            self._send_motion_input_message()\n\n    def send_thruster_setpoint(self, surge, sway, heave, yaw):\n\n        \"\"\"Control the thrusters of the drone\n\n        Set reference values between -1 and 1 for each controllable degree of freedom on the drone.\n\n        The reference values are mapped linearly to a thruster force, a set point of -1 correspons\n\n        to maximum negative force and a set point of 1 corresponds to maximum positive force. For\n\n        the yaw direction the reference is a moment not a force, as the yaw direction is rotational\n\n        not translational.\n\n        Arguments:\n\n        * **surge** (float): Force set point in the surge direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move forward\n\n        * **sway** (float): Force set point in the sway direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move to the right\n\n        * **heave** (float): Force set point in the heave direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move down.\n\n        * **yaw** (float): Moment set point in the yaw direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone rotate clockwise.\n\n        \"\"\"\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"surge\"] = surge\n\n            self._current_thruster_setpoints[\"sway\"] = sway\n\n            self._current_thruster_setpoints[\"heave\"] = heave\n\n            self._current_thruster_setpoints[\"yaw\"] = yaw\n\n            self._send_motion_input_message()\n\n    @property\n\n    def boost(self) -&gt; float:\n\n        \"\"\"Get or set the boost gain\n\n        Arguments:\n\n        * **boost_gain** (float): Range from 0 to 1.\n\n        \"\"\"\n\n        return self._current_boost_setpoints[\"boost\"]\n\n    @boost.setter\n\n    def boost(self, boost_gain: float):\n\n        with self.thruster_lock:\n\n            self._current_boost_setpoints[\"boost\"] = boost_gain\n\n            self._send_motion_input_message()\n\n    @property\n\n    def slow(self) -&gt; float:\n\n        \"\"\"Get or set the \"slow gain\" (inverse of boost)\n\n        Arguments:\n\n        * **slow_gain** (float): Range from 0 to 1.\n\n        \"\"\"\n\n        return self._current_boost_setpoints[\"slow\"]\n\n    @slow.setter\n\n    def slow(self, slow_gain: float):\n\n        with self.thruster_lock:\n\n            self._current_boost_setpoints[\"slow\"] = slow_gain\n\n            self._send_motion_input_message()\n\n    @property\n\n    def auto_depth_active(self) -&gt; Optional[bool]:\n\n        \"\"\"Enable or disable the auto depth control mode\n\n        When auto depth is active, input for the heave direction to the thruster_setpoint function\n\n        specifies a speed set point instead of a force set point. A control loop on the drone will\n\n        then attempt to maintain the wanted speed in the heave direction as long as auto depth is\n\n        active.\n\n        *Arguments*:\n\n        * Enable (bool): Activate auto depth mode if true, de-activate if false\n\n        *Returns*:\n\n        * Auto depth state (bool): True if auto depth is active, false if not\n\n        \"\"\"\n\n        control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel)\n\n        if control_mode_tel is None:\n\n            return None\n\n        else:\n\n            return control_mode_tel.state.auto_depth\n\n    @auto_depth_active.setter\n\n    def auto_depth_active(self, enable: bool):\n\n        self._parent_drone._ctrl_client.set_auto_depth_state(enable)\n\n    @property\n\n    def auto_heading_active(self) -&gt; Optional[bool]:\n\n        \"\"\"Enable or disable the auto heading control mode\n\n        When auto heading is active, input for the yaw direction to the thruster_setpoint function\n\n        specifies a angular speed set point instead of a moment set point. A control loop on the\n\n        drone will then attempt to maintain the wanted angular velocity in the yaw direction as\n\n        long as auto heading is active.\n\n        *Arguments*:\n\n        * Enable (bool): Activate auto heading mode if true, de-activate if false\n\n        *Returns*:\n\n        * Auto heading state (bool): True if auto heading mode is active, false if not\n\n        \"\"\"\n\n        control_mode_tel = self._parent_drone.telemetry.get(blueye.protocol.ControlModeTel)\n\n        if control_mode_tel is None:\n\n            return None\n\n        else:\n\n            return control_mode_tel.state.auto_heading\n\n    @auto_heading_active.setter\n\n    def auto_heading_active(self, enable: bool):\n\n        self._parent_drone._ctrl_client.set_auto_heading_state(enable)\n</code></pre>"},{"location":"reference/blueye/sdk/motion/#instance-variables","title":"Instance variables","text":"<pre><code>auto_depth_active\n</code></pre> <p>Enable or disable the auto depth control mode</p> <p>When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the drone will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active.</p> <p>Arguments:</p> <ul> <li>Enable (bool): Activate auto depth mode if true, de-activate if false</li> </ul> <p>Returns:</p> <ul> <li>Auto depth state (bool): True if auto depth is active, false if not</li> </ul> <pre><code>auto_heading_active\n</code></pre> <p>Enable or disable the auto heading control mode</p> <p>When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the drone will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active.</p> <p>Arguments:</p> <ul> <li>Enable (bool): Activate auto heading mode if true, de-activate if false</li> </ul> <p>Returns:</p> <ul> <li>Auto heading state (bool): True if auto heading mode is active, false if not</li> </ul> <pre><code>boost\n</code></pre> <p>Get or set the boost gain</p> <p>Arguments:</p> <ul> <li>boost_gain (float): Range from 0 to 1.</li> </ul> <pre><code>current_thruster_setpoints\n</code></pre> <p>Returns the current setpoints for the thrusters</p> <p>We maintain this state in the SDK since the drone expects to receive all of the setpoints at once.</p> <p>For setting the setpoints you should use the dedicated properties/functions for that, trying to set them directly with this property will raise an AttributeError.</p> <pre><code>heave\n</code></pre> <p>Set force reference for the heave direction</p> <p>Arguments:</p> <ul> <li>heave (float): Force set point in the heave direction in range &lt;-1, 1&gt;,                      a positive set point makes the drone move downwards</li> </ul> <pre><code>slow\n</code></pre> <p>Get or set the \"slow gain\" (inverse of boost)</p> <p>Arguments:</p> <ul> <li>slow_gain (float): Range from 0 to 1.</li> </ul> <pre><code>surge\n</code></pre> <p>Set force reference for the surge direction</p> <p>Arguments:</p> <ul> <li>surge (float): Force set point in the surge direction in range &lt;-1, 1&gt;,                      a positive set point makes the drone move forward</li> </ul> <pre><code>sway\n</code></pre> <p>Set force reference for the sway direction</p> <p>Arguments:</p> <ul> <li>sway (float): Force set point in the sway direction in range &lt;-1, 1&gt;,                     a positive set point makes the drone move to the right</li> </ul> <pre><code>yaw\n</code></pre> <p>Set force reference for the yaw direction</p> <p>Arguments:</p> <ul> <li>yaw (float): Moment set point in the sway direction in range &lt;-1, 1&gt;,                    a positive set point makes the drone rotate clockwise.</li> </ul>"},{"location":"reference/blueye/sdk/motion/#methods","title":"Methods","text":""},{"location":"reference/blueye/sdk/motion/#send_thruster_setpoint","title":"send_thruster_setpoint","text":"<pre><code>def send_thruster_setpoint(\n    self,\n    surge,\n    sway,\n    heave,\n    yaw\n)\n</code></pre> <p>Control the thrusters of the drone</p> <p>Set reference values between -1 and 1 for each controllable degree of freedom on the drone. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational.</p> <p>Arguments:</p> <ul> <li>surge (float): Force set point in the surge direction in range &lt;-1, 1&gt;,                      a positive set point makes the drone move forward</li> <li>sway (float): Force set point in the sway direction in range &lt;-1, 1&gt;,                      a positive set point makes the drone move to the right</li> <li>heave (float): Force set point in the heave direction in range &lt;-1, 1&gt;,                      a positive set point makes the drone move down.</li> <li>yaw (float): Moment set point in the yaw direction in range &lt;-1, 1&gt;,                      a positive set point makes the drone rotate clockwise.</li> </ul> View Source <pre><code>    def send_thruster_setpoint(self, surge, sway, heave, yaw):\n\n        \"\"\"Control the thrusters of the drone\n\n        Set reference values between -1 and 1 for each controllable degree of freedom on the drone.\n\n        The reference values are mapped linearly to a thruster force, a set point of -1 correspons\n\n        to maximum negative force and a set point of 1 corresponds to maximum positive force. For\n\n        the yaw direction the reference is a moment not a force, as the yaw direction is rotational\n\n        not translational.\n\n        Arguments:\n\n        * **surge** (float): Force set point in the surge direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move forward\n\n        * **sway** (float): Force set point in the sway direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move to the right\n\n        * **heave** (float): Force set point in the heave direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone move down.\n\n        * **yaw** (float): Moment set point in the yaw direction in range &lt;-1, 1&gt;,\n\n                             a positive set point makes the drone rotate clockwise.\n\n        \"\"\"\n\n        with self.thruster_lock:\n\n            self._current_thruster_setpoints[\"surge\"] = surge\n\n            self._current_thruster_setpoints[\"sway\"] = sway\n\n            self._current_thruster_setpoints[\"heave\"] = heave\n\n            self._current_thruster_setpoints[\"yaw\"] = yaw\n\n            self._send_motion_input_message()\n</code></pre>"},{"location":"reference/blueye/sdk/utils/","title":"Module blueye.sdk.utils","text":"View Source <pre><code>import os\n\nimport webbrowser\n\nfrom typing import Tuple\n\nimport blueye.protocol as bp\n\nimport proto\n\nfrom google.protobuf.any_pb2 import Any\n\nimport blueye.sdk\n\ndef open_local_documentation():\n\n    \"\"\"Open a pre-built local version of the SDK documentation\n\n    Useful when you are connected to the drone wifi, and don't have access to the online version.\n\n    \"\"\"\n\n    sdk_path = os.path.dirname(blueye.sdk.__file__)\n\n    # The documentation is located next to the top-level package so we move up a couple of levels\n\n    documentation_path = os.path.abspath(sdk_path + \"/../../blueye.sdk_docs/README.html\")\n\n    webbrowser.open(documentation_path)\n\ndef deserialize_any_to_message(msg: Any) -&gt; Tuple[proto.message.MessageMeta, proto.message.Message]:\n\n    \"\"\"Deserialize a protobuf Any message to a concrete message type\n\n    *Arguments*:\n\n    * msg: The Any message to deserialize. Needs to be a message defined in the blueye.protocol\n\n           package.\n\n    *Returns*:\n\n    * A tuple with the metatype and the deserialized message\n\n    \"\"\"\n\n    payload_msg_name = msg.type_url.replace(\"type.googleapis.com/blueye.protocol.\", \"\")\n\n    payload_type = bp.__getattribute__(payload_msg_name)\n\n    payload_msg_deserialized = payload_type.deserialize(msg.value)\n\n    return (payload_type, payload_msg_deserialized)\n</code></pre>"},{"location":"reference/blueye/sdk/utils/#functions","title":"Functions","text":""},{"location":"reference/blueye/sdk/utils/#deserialize_any_to_message","title":"deserialize_any_to_message","text":"<pre><code>def deserialize_any_to_message(\n    msg: google.protobuf.any_pb2.Any\n) -&gt; Tuple[proto.message.MessageMeta, proto.message.Message]\n</code></pre> <p>Deserialize a protobuf Any message to a concrete message type</p> <p>Arguments:</p> <ul> <li>msg: The Any message to deserialize. Needs to be a message defined in the blueye.protocol        package.</li> </ul> <p>Returns:</p> <ul> <li>A tuple with the metatype and the deserialized message</li> </ul> View Source <pre><code>def deserialize_any_to_message(msg: Any) -&gt; Tuple[proto.message.MessageMeta, proto.message.Message]:\n\n    \"\"\"Deserialize a protobuf Any message to a concrete message type\n\n    *Arguments*:\n\n    * msg: The Any message to deserialize. Needs to be a message defined in the blueye.protocol\n\n           package.\n\n    *Returns*:\n\n    * A tuple with the metatype and the deserialized message\n\n    \"\"\"\n\n    payload_msg_name = msg.type_url.replace(\"type.googleapis.com/blueye.protocol.\", \"\")\n\n    payload_type = bp.__getattribute__(payload_msg_name)\n\n    payload_msg_deserialized = payload_type.deserialize(msg.value)\n\n    return (payload_type, payload_msg_deserialized)\n</code></pre>"},{"location":"reference/blueye/sdk/utils/#open_local_documentation","title":"open_local_documentation","text":"<pre><code>def open_local_documentation(\n\n)\n</code></pre> <p>Open a pre-built local version of the SDK documentation</p> <p>Useful when you are connected to the drone wifi, and don't have access to the online version.</p> View Source <pre><code>def open_local_documentation():\n\n    \"\"\"Open a pre-built local version of the SDK documentation\n\n    Useful when you are connected to the drone wifi, and don't have access to the online version.\n\n    \"\"\"\n\n    sdk_path = os.path.dirname(blueye.sdk.__file__)\n\n    # The documentation is located next to the top-level package so we move up a couple of levels\n\n    documentation_path = os.path.abspath(sdk_path + \"/../../blueye.sdk_docs/README.html\")\n\n    webbrowser.open(documentation_path)\n</code></pre>"},{"location":"video/downloading/","title":"Downloading videos and images","text":"<p>Videos and images can easiest be downloaded through the mobile app, or by using the <code>Blueye file transfer</code> desktop application for Windows, Mac OS and Linux.</p> <p>If one wants a more control over the download process, all files are listable through any client that supports WebDAV. The server is available on the drone (default ip: <code>192.168.1.101</code>) and port <code>5050</code>.</p> <p>For example using a Python WebDAV client we could do the following to list the files on drone:</p> <pre><code>import webdav3.client as wc\n\n# Define the options for connecting\noptions = {\n    'webdav_hostname': \"http://192.168.1.101:5050\"\n}\n\n# Instantiate the connection\nclient = wc.Client(options)\n\n# List the avaiable files\nclient.list()\n</code></pre>"},{"location":"video/downloading/#understanding-the-file-name-formats","title":"Understanding the file name formats","text":"<p>An example output from listing available files could be:</p> <p><pre><code>'video_BYEDP000105_2019-08-13_103035.jpg'\n'video_BYEDP000105_2019-08-13_103035.mp4'\n'picture_BYEDP000105_2019-09-27_074152.431.jpg',\n</code></pre> The format of the file names are described below.</p>"},{"location":"video/downloading/#video-files","title":"Video files","text":"<p>For each video recorded on the drone two files will be created, a <code>.mp4</code> file with the actual video, and a <code>.jpg</code> file with a thumbnail image from the video file. Other than the file extension the file names will be identical. An example of a video + thumbnail pair could be: <pre><code>'video_BYEDP000105_2019-08-13_103035.jpg'\n'video_BYEDP000105_2019-08-13_103035.mp4'\n</code></pre> The file names break down to:</p> File Type Prefix Drone Serial Number Timestamp (yyyy-MM-dd_hhmmss) File Extension video BYEDP000105 2019-08-13_103035 .mp4 video BYEDP000105 2019-08-13_103035 .jpg"},{"location":"video/downloading/#image-files","title":"Image files","text":"<p>Image files are images captured with the still image function. The file name for image files follow the same format as the video files, but the time stamp is extended with milliseconds to differentiate still images captured within the same second.</p> <p>An example still image file could be:</p> <p><pre><code>'picture_BYEDP000105_2019-09-27_074152.431.jpg',\n</code></pre> The file name breaks down to:</p> File Type Prefix Drone Serial Number Timestamp (yyyy-MM-dd_hhmmss.SSS) File Extension picture BYEDP000105 2019-09-27_074152.431 .jpg"},{"location":"video/gstreamer-for-video-streaming/","title":"GStreamer for video streaming","text":"<p>GStreamer is the lowest latency alternative for streaming video from the drone to your laptop.</p>"},{"location":"video/gstreamer-for-video-streaming/#installing-gstreamer","title":"Installing GStreamer","text":"<p>To run the streaming pipeline in the next section you will need a runtime installation of GStreamer. The instructions below show the basic steps for installing GStreamer on the most common operating systems. You can find more in depth instruction for your specific operating system in the <code>GStreamer docs</code>.</p> Windows <p>On Windows the basic installation steps are:</p> <ol> <li>Download the relevant installer for your computer from https://gstreamer.freedesktop.org/download . Using the latest stable relase should be fine, at the time of writing that is <code>1.16.1 runtime installer</code></li> <li>Run the installer. When asked to choose a setup type choose to do a complete installation. This is because some plugins that are needed for the basic pipeline later are not included if you choose to install the typical setup</li> <li>To run GStreamer commands form the terminal, GStreamer must be added to the PATH environment variable. This can be done from the advanced system settings. Add <code>%GSTREAMER_1_0_ROOT_X86_64%\\bin</code> to path. Alternatively you can choose to run gst-launch-1.0.exe from the folder it is installed in, typically <code>C:\\gstreamer\\1.0\\x86_64\\bin</code></li> </ol> Mac OS <p>On Mac OS GStreamer and its plugins can be installed using brew <pre><code>brew install gstreamer gst-plugins-base gst-plugins-good gst-plugins-bad gst-plugins-ugly gst-libav\n</code></pre></p> Linux <p>On Ubuntu and Debian GStreamer and its plugins can be installed using apt. <pre><code>apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\\ngstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc \\\ngstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa\n</code></pre></p> <p>You can test the installation by trying the basic pipeline from the next section when connected to a drone. Or with</p> <pre><code>gst-launch-1.0 videotestsrc ! autovideosink\n</code></pre>"},{"location":"video/gstreamer-for-video-streaming/#basic-streaming-pipeline","title":"Basic streaming pipeline","text":"<p>After installing you can run this pipeline in your terminal:</p> Windows <pre><code>gst-launch-1.0 rtspsrc location=rtsp://192.168.1.101:8554/test latency=0 ! rtph264depay ! avdec_h264 ! videoconvert ! fpsdisplaysink sync=false\n</code></pre> Linux and macOS <pre><code>gst-launch-1.0 rtspsrc location=rtsp://192.168.1.101:8554/test latency=0 \\\n! rtph264depay \\\n! avdec_h264 \\\n! videoconvert \\\n! fpsdisplaysink sync=false\n</code></pre> <p>Running the pipeline will open a window with the camera stream and information about packet loss and camera frame rate.</p>"},{"location":"video/gstreamer-for-video-streaming/#external-camera-streaming-pipeline","title":"External camera streaming pipeline","text":"<p>If you have a X3 drone with an external camera connected you can use the following pipeline:</p> Windows <pre><code>gst-launch-1.0 rtspsrc location=rtsp://192.168.1.101:8555/guestport_cam latency=0 ! rtph264depay ! avdec_h264 ! videoconvert ! autovideosink sync=false\n</code></pre> Linux and macOS <pre><code>gst-launch-1.0 rtspsrc location=rtsp://192.168.1.101:8555/guestport_cam latency=0 \\\n! rtph264depay \\\n! avdec_h264 \\\n! videoconvert \\\n! autovideosink sync=false\n</code></pre> <p>Running the pipeline will open a window with the external camera stream.</p>"}]}